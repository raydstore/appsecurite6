{"remainingRequest":"D:\\Development\\AngularProject\\appsecurite6\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Development\\AngularProject\\appsecurite6\\node_modules\\pdfjs-dist\\build\\pdf.js","dependencies":[{"path":"D:\\Development\\AngularProject\\appsecurite6\\node_modules\\pdfjs-dist\\build\\pdf.js","mtime":1563198747294},{"path":"D:\\Development\\AngularProject\\appsecurite6\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1563198691178},{"path":"D:\\Development\\AngularProject\\appsecurite6\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1563198608965}],"contextDependencies":[],"result":["/**\r\n * @licstart The following is the entire license notice for the\r\n * Javascript code in this page\r\n *\r\n * Copyright 2017 Mozilla Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * @licend The above is the entire license notice for the\r\n * Javascript code in this page\r\n */\r\n\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\tmodule.exports = factory();\r\n\telse if(typeof define === 'function' && define.amd)\r\n\t\tdefine(\"pdfjs-dist/build/pdf\", [], factory);\r\n\telse if(typeof exports === 'object')\r\n\t\texports[\"pdfjs-dist/build/pdf\"] = factory();\r\n\telse\r\n\t\troot[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory();\r\n})(typeof self !== 'undefined' ? self : this, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__w_pdfjs_require__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__w_pdfjs_require__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__w_pdfjs_require__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__w_pdfjs_require__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, {\r\n/******/ \t\t\t\tconfigurable: false,\r\n/******/ \t\t\t\tenumerable: true,\r\n/******/ \t\t\t\tget: getter\r\n/******/ \t\t\t});\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__w_pdfjs_require__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__w_pdfjs_require__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__w_pdfjs_require__.p = \"\";\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __w_pdfjs_require__(__w_pdfjs_require__.s = 60);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.unreachable = exports.warn = exports.utf8StringToString = exports.stringToUTF8String = exports.stringToPDFString = exports.stringToBytes = exports.string32 = exports.shadow = exports.setVerbosityLevel = exports.ReadableStream = exports.removeNullCharacters = exports.readUint32 = exports.readUint16 = exports.readInt8 = exports.log2 = exports.isEvalSupported = exports.isLittleEndian = exports.createValidAbsoluteUrl = exports.isSameOrigin = exports.isSpace = exports.isString = exports.isNum = exports.isEmptyObj = exports.isBool = exports.isArrayBuffer = exports.info = exports.getVerbosityLevel = exports.getLookupTableFactory = exports.getInheritableProperty = exports.deprecated = exports.createObjectURL = exports.createPromiseCapability = exports.createBlob = exports.bytesToString = exports.assert = exports.arraysToBytes = exports.arrayByteLength = exports.FormatError = exports.XRefParseException = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PasswordResponses = exports.PasswordException = exports.PageViewport = exports.NotImplementedException = exports.NativeImageDecoding = exports.MissingPDFException = exports.MissingDataException = exports.MessageHandler = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VerbosityLevel = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = undefined;\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\n__w_pdfjs_require__(61);\r\n\r\nvar _streams_polyfill = __w_pdfjs_require__(115);\r\n\r\nvar FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\r\nvar NativeImageDecoding = {\r\n  NONE: 'none',\r\n  DECODE: 'decode',\r\n  DISPLAY: 'display'\r\n};\r\nvar TextRenderingMode = {\r\n  FILL: 0,\r\n  STROKE: 1,\r\n  FILL_STROKE: 2,\r\n  INVISIBLE: 3,\r\n  FILL_ADD_TO_PATH: 4,\r\n  STROKE_ADD_TO_PATH: 5,\r\n  FILL_STROKE_ADD_TO_PATH: 6,\r\n  ADD_TO_PATH: 7,\r\n  FILL_STROKE_MASK: 3,\r\n  ADD_TO_PATH_FLAG: 4\r\n};\r\nvar ImageKind = {\r\n  GRAYSCALE_1BPP: 1,\r\n  RGB_24BPP: 2,\r\n  RGBA_32BPP: 3\r\n};\r\nvar AnnotationType = {\r\n  TEXT: 1,\r\n  LINK: 2,\r\n  FREETEXT: 3,\r\n  LINE: 4,\r\n  SQUARE: 5,\r\n  CIRCLE: 6,\r\n  POLYGON: 7,\r\n  POLYLINE: 8,\r\n  HIGHLIGHT: 9,\r\n  UNDERLINE: 10,\r\n  SQUIGGLY: 11,\r\n  STRIKEOUT: 12,\r\n  STAMP: 13,\r\n  CARET: 14,\r\n  INK: 15,\r\n  POPUP: 16,\r\n  FILEATTACHMENT: 17,\r\n  SOUND: 18,\r\n  MOVIE: 19,\r\n  WIDGET: 20,\r\n  SCREEN: 21,\r\n  PRINTERMARK: 22,\r\n  TRAPNET: 23,\r\n  WATERMARK: 24,\r\n  THREED: 25,\r\n  REDACT: 26\r\n};\r\nvar AnnotationFlag = {\r\n  INVISIBLE: 0x01,\r\n  HIDDEN: 0x02,\r\n  PRINT: 0x04,\r\n  NOZOOM: 0x08,\r\n  NOROTATE: 0x10,\r\n  NOVIEW: 0x20,\r\n  READONLY: 0x40,\r\n  LOCKED: 0x80,\r\n  TOGGLENOVIEW: 0x100,\r\n  LOCKEDCONTENTS: 0x200\r\n};\r\nvar AnnotationFieldFlag = {\r\n  READONLY: 0x0000001,\r\n  REQUIRED: 0x0000002,\r\n  NOEXPORT: 0x0000004,\r\n  MULTILINE: 0x0001000,\r\n  PASSWORD: 0x0002000,\r\n  NOTOGGLETOOFF: 0x0004000,\r\n  RADIO: 0x0008000,\r\n  PUSHBUTTON: 0x0010000,\r\n  COMBO: 0x0020000,\r\n  EDIT: 0x0040000,\r\n  SORT: 0x0080000,\r\n  FILESELECT: 0x0100000,\r\n  MULTISELECT: 0x0200000,\r\n  DONOTSPELLCHECK: 0x0400000,\r\n  DONOTSCROLL: 0x0800000,\r\n  COMB: 0x1000000,\r\n  RICHTEXT: 0x2000000,\r\n  RADIOSINUNISON: 0x2000000,\r\n  COMMITONSELCHANGE: 0x4000000\r\n};\r\nvar AnnotationBorderStyleType = {\r\n  SOLID: 1,\r\n  DASHED: 2,\r\n  BEVELED: 3,\r\n  INSET: 4,\r\n  UNDERLINE: 5\r\n};\r\nvar StreamType = {\r\n  UNKNOWN: 0,\r\n  FLATE: 1,\r\n  LZW: 2,\r\n  DCT: 3,\r\n  JPX: 4,\r\n  JBIG: 5,\r\n  A85: 6,\r\n  AHX: 7,\r\n  CCF: 8,\r\n  RL: 9\r\n};\r\nvar FontType = {\r\n  UNKNOWN: 0,\r\n  TYPE1: 1,\r\n  TYPE1C: 2,\r\n  CIDFONTTYPE0: 3,\r\n  CIDFONTTYPE0C: 4,\r\n  TRUETYPE: 5,\r\n  CIDFONTTYPE2: 6,\r\n  TYPE3: 7,\r\n  OPENTYPE: 8,\r\n  TYPE0: 9,\r\n  MMTYPE1: 10\r\n};\r\nvar VerbosityLevel = {\r\n  ERRORS: 0,\r\n  WARNINGS: 1,\r\n  INFOS: 5\r\n};\r\nvar CMapCompressionType = {\r\n  NONE: 0,\r\n  BINARY: 1,\r\n  STREAM: 2\r\n};\r\nvar OPS = {\r\n  dependency: 1,\r\n  setLineWidth: 2,\r\n  setLineCap: 3,\r\n  setLineJoin: 4,\r\n  setMiterLimit: 5,\r\n  setDash: 6,\r\n  setRenderingIntent: 7,\r\n  setFlatness: 8,\r\n  setGState: 9,\r\n  save: 10,\r\n  restore: 11,\r\n  transform: 12,\r\n  moveTo: 13,\r\n  lineTo: 14,\r\n  curveTo: 15,\r\n  curveTo2: 16,\r\n  curveTo3: 17,\r\n  closePath: 18,\r\n  rectangle: 19,\r\n  stroke: 20,\r\n  closeStroke: 21,\r\n  fill: 22,\r\n  eoFill: 23,\r\n  fillStroke: 24,\r\n  eoFillStroke: 25,\r\n  closeFillStroke: 26,\r\n  closeEOFillStroke: 27,\r\n  endPath: 28,\r\n  clip: 29,\r\n  eoClip: 30,\r\n  beginText: 31,\r\n  endText: 32,\r\n  setCharSpacing: 33,\r\n  setWordSpacing: 34,\r\n  setHScale: 35,\r\n  setLeading: 36,\r\n  setFont: 37,\r\n  setTextRenderingMode: 38,\r\n  setTextRise: 39,\r\n  moveText: 40,\r\n  setLeadingMoveText: 41,\r\n  setTextMatrix: 42,\r\n  nextLine: 43,\r\n  showText: 44,\r\n  showSpacedText: 45,\r\n  nextLineShowText: 46,\r\n  nextLineSetSpacingShowText: 47,\r\n  setCharWidth: 48,\r\n  setCharWidthAndBounds: 49,\r\n  setStrokeColorSpace: 50,\r\n  setFillColorSpace: 51,\r\n  setStrokeColor: 52,\r\n  setStrokeColorN: 53,\r\n  setFillColor: 54,\r\n  setFillColorN: 55,\r\n  setStrokeGray: 56,\r\n  setFillGray: 57,\r\n  setStrokeRGBColor: 58,\r\n  setFillRGBColor: 59,\r\n  setStrokeCMYKColor: 60,\r\n  setFillCMYKColor: 61,\r\n  shadingFill: 62,\r\n  beginInlineImage: 63,\r\n  beginImageData: 64,\r\n  endInlineImage: 65,\r\n  paintXObject: 66,\r\n  markPoint: 67,\r\n  markPointProps: 68,\r\n  beginMarkedContent: 69,\r\n  beginMarkedContentProps: 70,\r\n  endMarkedContent: 71,\r\n  beginCompat: 72,\r\n  endCompat: 73,\r\n  paintFormXObjectBegin: 74,\r\n  paintFormXObjectEnd: 75,\r\n  beginGroup: 76,\r\n  endGroup: 77,\r\n  beginAnnotations: 78,\r\n  endAnnotations: 79,\r\n  beginAnnotation: 80,\r\n  endAnnotation: 81,\r\n  paintJpegXObject: 82,\r\n  paintImageMaskXObject: 83,\r\n  paintImageMaskXObjectGroup: 84,\r\n  paintImageXObject: 85,\r\n  paintInlineImageXObject: 86,\r\n  paintInlineImageXObjectGroup: 87,\r\n  paintImageXObjectRepeat: 88,\r\n  paintImageMaskXObjectRepeat: 89,\r\n  paintSolidColorImageMask: 90,\r\n  constructPath: 91\r\n};\r\nvar verbosity = VerbosityLevel.WARNINGS;\r\nfunction setVerbosityLevel(level) {\r\n  if (Number.isInteger(level)) {\r\n    verbosity = level;\r\n  }\r\n}\r\nfunction getVerbosityLevel() {\r\n  return verbosity;\r\n}\r\nfunction info(msg) {\r\n  if (verbosity >= VerbosityLevel.INFOS) {\r\n    console.log('Info: ' + msg);\r\n  }\r\n}\r\nfunction warn(msg) {\r\n  if (verbosity >= VerbosityLevel.WARNINGS) {\r\n    console.log('Warning: ' + msg);\r\n  }\r\n}\r\nfunction deprecated(details) {\r\n  console.log('Deprecated API usage: ' + details);\r\n}\r\nfunction unreachable(msg) {\r\n  throw new Error(msg);\r\n}\r\nfunction assert(cond, msg) {\r\n  if (!cond) {\r\n    unreachable(msg);\r\n  }\r\n}\r\nvar UNSUPPORTED_FEATURES = {\r\n  unknown: 'unknown',\r\n  forms: 'forms',\r\n  javaScript: 'javaScript',\r\n  smask: 'smask',\r\n  shadingPattern: 'shadingPattern',\r\n  font: 'font'\r\n};\r\nfunction isSameOrigin(baseUrl, otherUrl) {\r\n  try {\r\n    var base = new URL(baseUrl);\r\n    if (!base.origin || base.origin === 'null') {\r\n      return false;\r\n    }\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n  var other = new URL(otherUrl, base);\r\n  return base.origin === other.origin;\r\n}\r\nfunction isValidProtocol(url) {\r\n  if (!url) {\r\n    return false;\r\n  }\r\n  switch (url.protocol) {\r\n    case 'http:':\r\n    case 'https:':\r\n    case 'ftp:':\r\n    case 'mailto:':\r\n    case 'tel:':\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\nfunction createValidAbsoluteUrl(url, baseUrl) {\r\n  if (!url) {\r\n    return null;\r\n  }\r\n  try {\r\n    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\r\n    if (isValidProtocol(absoluteUrl)) {\r\n      return absoluteUrl;\r\n    }\r\n  } catch (ex) {}\r\n  return null;\r\n}\r\nfunction shadow(obj, prop, value) {\r\n  Object.defineProperty(obj, prop, {\r\n    value: value,\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: false\r\n  });\r\n  return value;\r\n}\r\nfunction getLookupTableFactory(initializer) {\r\n  var lookup;\r\n  return function () {\r\n    if (initializer) {\r\n      lookup = Object.create(null);\r\n      initializer(lookup);\r\n      initializer = null;\r\n    }\r\n    return lookup;\r\n  };\r\n}\r\nvar PasswordResponses = {\r\n  NEED_PASSWORD: 1,\r\n  INCORRECT_PASSWORD: 2\r\n};\r\nvar PasswordException = function PasswordExceptionClosure() {\r\n  function PasswordException(msg, code) {\r\n    this.name = 'PasswordException';\r\n    this.message = msg;\r\n    this.code = code;\r\n  }\r\n  PasswordException.prototype = new Error();\r\n  PasswordException.constructor = PasswordException;\r\n  return PasswordException;\r\n}();\r\nvar UnknownErrorException = function UnknownErrorExceptionClosure() {\r\n  function UnknownErrorException(msg, details) {\r\n    this.name = 'UnknownErrorException';\r\n    this.message = msg;\r\n    this.details = details;\r\n  }\r\n  UnknownErrorException.prototype = new Error();\r\n  UnknownErrorException.constructor = UnknownErrorException;\r\n  return UnknownErrorException;\r\n}();\r\nvar InvalidPDFException = function InvalidPDFExceptionClosure() {\r\n  function InvalidPDFException(msg) {\r\n    this.name = 'InvalidPDFException';\r\n    this.message = msg;\r\n  }\r\n  InvalidPDFException.prototype = new Error();\r\n  InvalidPDFException.constructor = InvalidPDFException;\r\n  return InvalidPDFException;\r\n}();\r\nvar MissingPDFException = function MissingPDFExceptionClosure() {\r\n  function MissingPDFException(msg) {\r\n    this.name = 'MissingPDFException';\r\n    this.message = msg;\r\n  }\r\n  MissingPDFException.prototype = new Error();\r\n  MissingPDFException.constructor = MissingPDFException;\r\n  return MissingPDFException;\r\n}();\r\nvar UnexpectedResponseException = function UnexpectedResponseExceptionClosure() {\r\n  function UnexpectedResponseException(msg, status) {\r\n    this.name = 'UnexpectedResponseException';\r\n    this.message = msg;\r\n    this.status = status;\r\n  }\r\n  UnexpectedResponseException.prototype = new Error();\r\n  UnexpectedResponseException.constructor = UnexpectedResponseException;\r\n  return UnexpectedResponseException;\r\n}();\r\nvar NotImplementedException = function NotImplementedExceptionClosure() {\r\n  function NotImplementedException(msg) {\r\n    this.message = msg;\r\n  }\r\n  NotImplementedException.prototype = new Error();\r\n  NotImplementedException.prototype.name = 'NotImplementedException';\r\n  NotImplementedException.constructor = NotImplementedException;\r\n  return NotImplementedException;\r\n}();\r\nvar MissingDataException = function MissingDataExceptionClosure() {\r\n  function MissingDataException(begin, end) {\r\n    this.begin = begin;\r\n    this.end = end;\r\n    this.message = 'Missing data [' + begin + ', ' + end + ')';\r\n  }\r\n  MissingDataException.prototype = new Error();\r\n  MissingDataException.prototype.name = 'MissingDataException';\r\n  MissingDataException.constructor = MissingDataException;\r\n  return MissingDataException;\r\n}();\r\nvar XRefParseException = function XRefParseExceptionClosure() {\r\n  function XRefParseException(msg) {\r\n    this.message = msg;\r\n  }\r\n  XRefParseException.prototype = new Error();\r\n  XRefParseException.prototype.name = 'XRefParseException';\r\n  XRefParseException.constructor = XRefParseException;\r\n  return XRefParseException;\r\n}();\r\nvar FormatError = function FormatErrorClosure() {\r\n  function FormatError(msg) {\r\n    this.message = msg;\r\n  }\r\n  FormatError.prototype = new Error();\r\n  FormatError.prototype.name = 'FormatError';\r\n  FormatError.constructor = FormatError;\r\n  return FormatError;\r\n}();\r\nvar AbortException = function AbortExceptionClosure() {\r\n  function AbortException(msg) {\r\n    this.name = 'AbortException';\r\n    this.message = msg;\r\n  }\r\n  AbortException.prototype = new Error();\r\n  AbortException.constructor = AbortException;\r\n  return AbortException;\r\n}();\r\nvar NullCharactersRegExp = /\\x00/g;\r\nfunction removeNullCharacters(str) {\r\n  if (typeof str !== 'string') {\r\n    warn('The argument for removeNullCharacters must be a string.');\r\n    return str;\r\n  }\r\n  return str.replace(NullCharactersRegExp, '');\r\n}\r\nfunction bytesToString(bytes) {\r\n  assert(bytes !== null && (typeof bytes === 'undefined' ? 'undefined' : _typeof(bytes)) === 'object' && bytes.length !== undefined, 'Invalid argument for bytesToString');\r\n  var length = bytes.length;\r\n  var MAX_ARGUMENT_COUNT = 8192;\r\n  if (length < MAX_ARGUMENT_COUNT) {\r\n    return String.fromCharCode.apply(null, bytes);\r\n  }\r\n  var strBuf = [];\r\n  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\r\n    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\r\n    var chunk = bytes.subarray(i, chunkEnd);\r\n    strBuf.push(String.fromCharCode.apply(null, chunk));\r\n  }\r\n  return strBuf.join('');\r\n}\r\nfunction stringToBytes(str) {\r\n  assert(typeof str === 'string', 'Invalid argument for stringToBytes');\r\n  var length = str.length;\r\n  var bytes = new Uint8Array(length);\r\n  for (var i = 0; i < length; ++i) {\r\n    bytes[i] = str.charCodeAt(i) & 0xFF;\r\n  }\r\n  return bytes;\r\n}\r\nfunction arrayByteLength(arr) {\r\n  if (arr.length !== undefined) {\r\n    return arr.length;\r\n  }\r\n  assert(arr.byteLength !== undefined);\r\n  return arr.byteLength;\r\n}\r\nfunction arraysToBytes(arr) {\r\n  if (arr.length === 1 && arr[0] instanceof Uint8Array) {\r\n    return arr[0];\r\n  }\r\n  var resultLength = 0;\r\n  var i,\r\n      ii = arr.length;\r\n  var item, itemLength;\r\n  for (i = 0; i < ii; i++) {\r\n    item = arr[i];\r\n    itemLength = arrayByteLength(item);\r\n    resultLength += itemLength;\r\n  }\r\n  var pos = 0;\r\n  var data = new Uint8Array(resultLength);\r\n  for (i = 0; i < ii; i++) {\r\n    item = arr[i];\r\n    if (!(item instanceof Uint8Array)) {\r\n      if (typeof item === 'string') {\r\n        item = stringToBytes(item);\r\n      } else {\r\n        item = new Uint8Array(item);\r\n      }\r\n    }\r\n    itemLength = item.byteLength;\r\n    data.set(item, pos);\r\n    pos += itemLength;\r\n  }\r\n  return data;\r\n}\r\nfunction string32(value) {\r\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\r\n}\r\nfunction log2(x) {\r\n  if (x <= 0) {\r\n    return 0;\r\n  }\r\n  return Math.ceil(Math.log2(x));\r\n}\r\nfunction readInt8(data, start) {\r\n  return data[start] << 24 >> 24;\r\n}\r\nfunction readUint16(data, offset) {\r\n  return data[offset] << 8 | data[offset + 1];\r\n}\r\nfunction readUint32(data, offset) {\r\n  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;\r\n}\r\nfunction isLittleEndian() {\r\n  var buffer8 = new Uint8Array(4);\r\n  buffer8[0] = 1;\r\n  var view32 = new Uint32Array(buffer8.buffer, 0, 1);\r\n  return view32[0] === 1;\r\n}\r\nfunction isEvalSupported() {\r\n  try {\r\n    new Function('');\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\nfunction getInheritableProperty(_ref) {\r\n  var dict = _ref.dict,\r\n      key = _ref.key,\r\n      _ref$getArray = _ref.getArray,\r\n      getArray = _ref$getArray === undefined ? false : _ref$getArray,\r\n      _ref$stopWhenFound = _ref.stopWhenFound,\r\n      stopWhenFound = _ref$stopWhenFound === undefined ? true : _ref$stopWhenFound;\r\n\r\n  var LOOP_LIMIT = 100;\r\n  var loopCount = 0;\r\n  var values = void 0;\r\n  while (dict) {\r\n    var value = getArray ? dict.getArray(key) : dict.get(key);\r\n    if (value !== undefined) {\r\n      if (stopWhenFound) {\r\n        return value;\r\n      }\r\n      if (!values) {\r\n        values = [];\r\n      }\r\n      values.push(value);\r\n    }\r\n    if (++loopCount > LOOP_LIMIT) {\r\n      warn('getInheritableProperty: maximum loop count exceeded for \"' + key + '\"');\r\n      break;\r\n    }\r\n    dict = dict.get('Parent');\r\n  }\r\n  return values;\r\n}\r\nvar IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\r\nvar Util = function UtilClosure() {\r\n  function Util() {}\r\n  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];\r\n  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {\r\n    rgbBuf[1] = r;\r\n    rgbBuf[3] = g;\r\n    rgbBuf[5] = b;\r\n    return rgbBuf.join('');\r\n  };\r\n  Util.transform = function Util_transform(m1, m2) {\r\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\r\n  };\r\n  Util.applyTransform = function Util_applyTransform(p, m) {\r\n    var xt = p[0] * m[0] + p[1] * m[2] + m[4];\r\n    var yt = p[0] * m[1] + p[1] * m[3] + m[5];\r\n    return [xt, yt];\r\n  };\r\n  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {\r\n    var d = m[0] * m[3] - m[1] * m[2];\r\n    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\r\n    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\r\n    return [xt, yt];\r\n  };\r\n  Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {\r\n    var p1 = Util.applyTransform(r, m);\r\n    var p2 = Util.applyTransform(r.slice(2, 4), m);\r\n    var p3 = Util.applyTransform([r[0], r[3]], m);\r\n    var p4 = Util.applyTransform([r[2], r[1]], m);\r\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\r\n  };\r\n  Util.inverseTransform = function Util_inverseTransform(m) {\r\n    var d = m[0] * m[3] - m[1] * m[2];\r\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\r\n  };\r\n  Util.apply3dTransform = function Util_apply3dTransform(m, v) {\r\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\r\n  };\r\n  Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {\r\n    var transpose = [m[0], m[2], m[1], m[3]];\r\n    var a = m[0] * transpose[0] + m[1] * transpose[2];\r\n    var b = m[0] * transpose[1] + m[1] * transpose[3];\r\n    var c = m[2] * transpose[0] + m[3] * transpose[2];\r\n    var d = m[2] * transpose[1] + m[3] * transpose[3];\r\n    var first = (a + d) / 2;\r\n    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\r\n    var sx = first + second || 1;\r\n    var sy = first - second || 1;\r\n    return [Math.sqrt(sx), Math.sqrt(sy)];\r\n  };\r\n  Util.normalizeRect = function Util_normalizeRect(rect) {\r\n    var r = rect.slice(0);\r\n    if (rect[0] > rect[2]) {\r\n      r[0] = rect[2];\r\n      r[2] = rect[0];\r\n    }\r\n    if (rect[1] > rect[3]) {\r\n      r[1] = rect[3];\r\n      r[3] = rect[1];\r\n    }\r\n    return r;\r\n  };\r\n  Util.intersect = function Util_intersect(rect1, rect2) {\r\n    function compare(a, b) {\r\n      return a - b;\r\n    }\r\n    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),\r\n        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),\r\n        result = [];\r\n    rect1 = Util.normalizeRect(rect1);\r\n    rect2 = Util.normalizeRect(rect2);\r\n    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\r\n      result[0] = orderedX[1];\r\n      result[2] = orderedX[2];\r\n    } else {\r\n      return false;\r\n    }\r\n    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\r\n      result[1] = orderedY[1];\r\n      result[3] = orderedY[2];\r\n    } else {\r\n      return false;\r\n    }\r\n    return result;\r\n  };\r\n  var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];\r\n  Util.toRoman = function Util_toRoman(number, lowerCase) {\r\n    assert(Number.isInteger(number) && number > 0, 'The number should be a positive integer.');\r\n    var pos,\r\n        romanBuf = [];\r\n    while (number >= 1000) {\r\n      number -= 1000;\r\n      romanBuf.push('M');\r\n    }\r\n    pos = number / 100 | 0;\r\n    number %= 100;\r\n    romanBuf.push(ROMAN_NUMBER_MAP[pos]);\r\n    pos = number / 10 | 0;\r\n    number %= 10;\r\n    romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);\r\n    romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);\r\n    var romanStr = romanBuf.join('');\r\n    return lowerCase ? romanStr.toLowerCase() : romanStr;\r\n  };\r\n  Util.appendToArray = function Util_appendToArray(arr1, arr2) {\r\n    Array.prototype.push.apply(arr1, arr2);\r\n  };\r\n  Util.prependToArray = function Util_prependToArray(arr1, arr2) {\r\n    Array.prototype.unshift.apply(arr1, arr2);\r\n  };\r\n  Util.extendObj = function extendObj(obj1, obj2) {\r\n    for (var key in obj2) {\r\n      obj1[key] = obj2[key];\r\n    }\r\n  };\r\n  Util.inherit = function Util_inherit(sub, base, prototype) {\r\n    sub.prototype = Object.create(base.prototype);\r\n    sub.prototype.constructor = sub;\r\n    for (var prop in prototype) {\r\n      sub.prototype[prop] = prototype[prop];\r\n    }\r\n  };\r\n  Util.loadScript = function Util_loadScript(src, callback) {\r\n    var script = document.createElement('script');\r\n    var loaded = false;\r\n    script.setAttribute('src', src);\r\n    if (callback) {\r\n      script.onload = function () {\r\n        if (!loaded) {\r\n          callback();\r\n        }\r\n        loaded = true;\r\n      };\r\n    }\r\n    document.getElementsByTagName('head')[0].appendChild(script);\r\n  };\r\n  return Util;\r\n}();\r\nvar PageViewport = function PageViewportClosure() {\r\n  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {\r\n    this.viewBox = viewBox;\r\n    this.scale = scale;\r\n    this.rotation = rotation;\r\n    this.offsetX = offsetX;\r\n    this.offsetY = offsetY;\r\n    var centerX = (viewBox[2] + viewBox[0]) / 2;\r\n    var centerY = (viewBox[3] + viewBox[1]) / 2;\r\n    var rotateA, rotateB, rotateC, rotateD;\r\n    rotation = rotation % 360;\r\n    rotation = rotation < 0 ? rotation + 360 : rotation;\r\n    switch (rotation) {\r\n      case 180:\r\n        rotateA = -1;\r\n        rotateB = 0;\r\n        rotateC = 0;\r\n        rotateD = 1;\r\n        break;\r\n      case 90:\r\n        rotateA = 0;\r\n        rotateB = 1;\r\n        rotateC = 1;\r\n        rotateD = 0;\r\n        break;\r\n      case 270:\r\n        rotateA = 0;\r\n        rotateB = -1;\r\n        rotateC = -1;\r\n        rotateD = 0;\r\n        break;\r\n      default:\r\n        rotateA = 1;\r\n        rotateB = 0;\r\n        rotateC = 0;\r\n        rotateD = -1;\r\n        break;\r\n    }\r\n    if (dontFlip) {\r\n      rotateC = -rotateC;\r\n      rotateD = -rotateD;\r\n    }\r\n    var offsetCanvasX, offsetCanvasY;\r\n    var width, height;\r\n    if (rotateA === 0) {\r\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\r\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\r\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\r\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\r\n    } else {\r\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\r\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\r\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\r\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\r\n    }\r\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\r\n    this.width = width;\r\n    this.height = height;\r\n    this.fontScale = scale;\r\n  }\r\n  PageViewport.prototype = {\r\n    clone: function PageViewPort_clone(args) {\r\n      args = args || {};\r\n      var scale = 'scale' in args ? args.scale : this.scale;\r\n      var rotation = 'rotation' in args ? args.rotation : this.rotation;\r\n      return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);\r\n    },\r\n    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {\r\n      return Util.applyTransform([x, y], this.transform);\r\n    },\r\n    convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {\r\n      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);\r\n      var br = Util.applyTransform([rect[2], rect[3]], this.transform);\r\n      return [tl[0], tl[1], br[0], br[1]];\r\n    },\r\n    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {\r\n      return Util.applyInverseTransform([x, y], this.transform);\r\n    }\r\n  };\r\n  return PageViewport;\r\n}();\r\nvar PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];\r\nfunction stringToPDFString(str) {\r\n  var i,\r\n      n = str.length,\r\n      strBuf = [];\r\n  if (str[0] === '\\xFE' && str[1] === '\\xFF') {\r\n    for (i = 2; i < n; i += 2) {\r\n      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\r\n    }\r\n  } else {\r\n    for (i = 0; i < n; ++i) {\r\n      var code = PDFStringTranslateTable[str.charCodeAt(i)];\r\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\r\n    }\r\n  }\r\n  return strBuf.join('');\r\n}\r\nfunction stringToUTF8String(str) {\r\n  return decodeURIComponent(escape(str));\r\n}\r\nfunction utf8StringToString(str) {\r\n  return unescape(encodeURIComponent(str));\r\n}\r\nfunction isEmptyObj(obj) {\r\n  for (var key in obj) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nfunction isBool(v) {\r\n  return typeof v === 'boolean';\r\n}\r\nfunction isNum(v) {\r\n  return typeof v === 'number';\r\n}\r\nfunction isString(v) {\r\n  return typeof v === 'string';\r\n}\r\nfunction isArrayBuffer(v) {\r\n  return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && v !== null && v.byteLength !== undefined;\r\n}\r\nfunction isSpace(ch) {\r\n  return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;\r\n}\r\nfunction createPromiseCapability() {\r\n  var capability = {};\r\n  capability.promise = new Promise(function (resolve, reject) {\r\n    capability.resolve = resolve;\r\n    capability.reject = reject;\r\n  });\r\n  return capability;\r\n}\r\nvar createBlob = function createBlob(data, contentType) {\r\n  if (typeof Blob !== 'undefined') {\r\n    return new Blob([data], { type: contentType });\r\n  }\r\n  throw new Error('The \"Blob\" constructor is not supported.');\r\n};\r\nvar createObjectURL = function createObjectURLClosure() {\r\n  var digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n  return function createObjectURL(data, contentType) {\r\n    var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n\r\n    if (!forceDataSchema && URL.createObjectURL) {\r\n      var blob = createBlob(data, contentType);\r\n      return URL.createObjectURL(blob);\r\n    }\r\n    var buffer = 'data:' + contentType + ';base64,';\r\n    for (var i = 0, ii = data.length; i < ii; i += 3) {\r\n      var b1 = data[i] & 0xFF;\r\n      var b2 = data[i + 1] & 0xFF;\r\n      var b3 = data[i + 2] & 0xFF;\r\n      var d1 = b1 >> 2,\r\n          d2 = (b1 & 3) << 4 | b2 >> 4;\r\n      var d3 = i + 1 < ii ? (b2 & 0xF) << 2 | b3 >> 6 : 64;\r\n      var d4 = i + 2 < ii ? b3 & 0x3F : 64;\r\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\r\n    }\r\n    return buffer;\r\n  };\r\n}();\r\nfunction resolveCall(fn, args) {\r\n  var thisArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\r\n\r\n  if (!fn) {\r\n    return Promise.resolve(undefined);\r\n  }\r\n  return new Promise(function (resolve, reject) {\r\n    resolve(fn.apply(thisArg, args));\r\n  });\r\n}\r\nfunction wrapReason(reason) {\r\n  if ((typeof reason === 'undefined' ? 'undefined' : _typeof(reason)) !== 'object') {\r\n    return reason;\r\n  }\r\n  switch (reason.name) {\r\n    case 'AbortException':\r\n      return new AbortException(reason.message);\r\n    case 'MissingPDFException':\r\n      return new MissingPDFException(reason.message);\r\n    case 'UnexpectedResponseException':\r\n      return new UnexpectedResponseException(reason.message, reason.status);\r\n    default:\r\n      return new UnknownErrorException(reason.message, reason.details);\r\n  }\r\n}\r\nfunction makeReasonSerializable(reason) {\r\n  if (!(reason instanceof Error) || reason instanceof AbortException || reason instanceof MissingPDFException || reason instanceof UnexpectedResponseException || reason instanceof UnknownErrorException) {\r\n    return reason;\r\n  }\r\n  return new UnknownErrorException(reason.message, reason.toString());\r\n}\r\nfunction resolveOrReject(capability, success, reason) {\r\n  if (success) {\r\n    capability.resolve();\r\n  } else {\r\n    capability.reject(reason);\r\n  }\r\n}\r\nfunction finalize(promise) {\r\n  return Promise.resolve(promise).catch(function () {});\r\n}\r\nfunction MessageHandler(sourceName, targetName, comObj) {\r\n  var _this = this;\r\n\r\n  this.sourceName = sourceName;\r\n  this.targetName = targetName;\r\n  this.comObj = comObj;\r\n  this.callbackId = 1;\r\n  this.streamId = 1;\r\n  this.postMessageTransfers = true;\r\n  this.streamSinks = Object.create(null);\r\n  this.streamControllers = Object.create(null);\r\n  var callbacksCapabilities = this.callbacksCapabilities = Object.create(null);\r\n  var ah = this.actionHandler = Object.create(null);\r\n  this._onComObjOnMessage = function (event) {\r\n    var data = event.data;\r\n    if (data.targetName !== _this.sourceName) {\r\n      return;\r\n    }\r\n    if (data.stream) {\r\n      _this._processStreamMessage(data);\r\n    } else if (data.isReply) {\r\n      var callbackId = data.callbackId;\r\n      if (data.callbackId in callbacksCapabilities) {\r\n        var callback = callbacksCapabilities[callbackId];\r\n        delete callbacksCapabilities[callbackId];\r\n        if ('error' in data) {\r\n          callback.reject(wrapReason(data.error));\r\n        } else {\r\n          callback.resolve(data.data);\r\n        }\r\n      } else {\r\n        throw new Error('Cannot resolve callback ' + callbackId);\r\n      }\r\n    } else if (data.action in ah) {\r\n      var action = ah[data.action];\r\n      if (data.callbackId) {\r\n        var _sourceName = _this.sourceName;\r\n        var _targetName = data.sourceName;\r\n        Promise.resolve().then(function () {\r\n          return action[0].call(action[1], data.data);\r\n        }).then(function (result) {\r\n          comObj.postMessage({\r\n            sourceName: _sourceName,\r\n            targetName: _targetName,\r\n            isReply: true,\r\n            callbackId: data.callbackId,\r\n            data: result\r\n          });\r\n        }, function (reason) {\r\n          comObj.postMessage({\r\n            sourceName: _sourceName,\r\n            targetName: _targetName,\r\n            isReply: true,\r\n            callbackId: data.callbackId,\r\n            error: makeReasonSerializable(reason)\r\n          });\r\n        });\r\n      } else if (data.streamId) {\r\n        _this._createStreamSink(data);\r\n      } else {\r\n        action[0].call(action[1], data.data);\r\n      }\r\n    } else {\r\n      throw new Error('Unknown action from worker: ' + data.action);\r\n    }\r\n  };\r\n  comObj.addEventListener('message', this._onComObjOnMessage);\r\n}\r\nMessageHandler.prototype = {\r\n  on: function on(actionName, handler, scope) {\r\n    var ah = this.actionHandler;\r\n    if (ah[actionName]) {\r\n      throw new Error('There is already an actionName called \"' + actionName + '\"');\r\n    }\r\n    ah[actionName] = [handler, scope];\r\n  },\r\n  send: function send(actionName, data, transfers) {\r\n    var message = {\r\n      sourceName: this.sourceName,\r\n      targetName: this.targetName,\r\n      action: actionName,\r\n      data: data\r\n    };\r\n    this.postMessage(message, transfers);\r\n  },\r\n  sendWithPromise: function sendWithPromise(actionName, data, transfers) {\r\n    var callbackId = this.callbackId++;\r\n    var message = {\r\n      sourceName: this.sourceName,\r\n      targetName: this.targetName,\r\n      action: actionName,\r\n      data: data,\r\n      callbackId: callbackId\r\n    };\r\n    var capability = createPromiseCapability();\r\n    this.callbacksCapabilities[callbackId] = capability;\r\n    try {\r\n      this.postMessage(message, transfers);\r\n    } catch (e) {\r\n      capability.reject(e);\r\n    }\r\n    return capability.promise;\r\n  },\r\n  sendWithStream: function sendWithStream(actionName, data, queueingStrategy, transfers) {\r\n    var _this2 = this;\r\n\r\n    var streamId = this.streamId++;\r\n    var sourceName = this.sourceName;\r\n    var targetName = this.targetName;\r\n    return new _streams_polyfill.ReadableStream({\r\n      start: function start(controller) {\r\n        var startCapability = createPromiseCapability();\r\n        _this2.streamControllers[streamId] = {\r\n          controller: controller,\r\n          startCall: startCapability,\r\n          isClosed: false\r\n        };\r\n        _this2.postMessage({\r\n          sourceName: sourceName,\r\n          targetName: targetName,\r\n          action: actionName,\r\n          streamId: streamId,\r\n          data: data,\r\n          desiredSize: controller.desiredSize\r\n        });\r\n        return startCapability.promise;\r\n      },\r\n      pull: function pull(controller) {\r\n        var pullCapability = createPromiseCapability();\r\n        _this2.streamControllers[streamId].pullCall = pullCapability;\r\n        _this2.postMessage({\r\n          sourceName: sourceName,\r\n          targetName: targetName,\r\n          stream: 'pull',\r\n          streamId: streamId,\r\n          desiredSize: controller.desiredSize\r\n        });\r\n        return pullCapability.promise;\r\n      },\r\n      cancel: function cancel(reason) {\r\n        var cancelCapability = createPromiseCapability();\r\n        _this2.streamControllers[streamId].cancelCall = cancelCapability;\r\n        _this2.streamControllers[streamId].isClosed = true;\r\n        _this2.postMessage({\r\n          sourceName: sourceName,\r\n          targetName: targetName,\r\n          stream: 'cancel',\r\n          reason: reason,\r\n          streamId: streamId\r\n        });\r\n        return cancelCapability.promise;\r\n      }\r\n    }, queueingStrategy);\r\n  },\r\n  _createStreamSink: function _createStreamSink(data) {\r\n    var _this3 = this;\r\n\r\n    var self = this;\r\n    var action = this.actionHandler[data.action];\r\n    var streamId = data.streamId;\r\n    var desiredSize = data.desiredSize;\r\n    var sourceName = this.sourceName;\r\n    var targetName = data.sourceName;\r\n    var capability = createPromiseCapability();\r\n    var sendStreamRequest = function sendStreamRequest(_ref2) {\r\n      var stream = _ref2.stream,\r\n          chunk = _ref2.chunk,\r\n          transfers = _ref2.transfers,\r\n          success = _ref2.success,\r\n          reason = _ref2.reason;\r\n\r\n      _this3.postMessage({\r\n        sourceName: sourceName,\r\n        targetName: targetName,\r\n        stream: stream,\r\n        streamId: streamId,\r\n        chunk: chunk,\r\n        success: success,\r\n        reason: reason\r\n      }, transfers);\r\n    };\r\n    var streamSink = {\r\n      enqueue: function enqueue(chunk) {\r\n        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\r\n        var transfers = arguments[2];\r\n\r\n        if (this.isCancelled) {\r\n          return;\r\n        }\r\n        var lastDesiredSize = this.desiredSize;\r\n        this.desiredSize -= size;\r\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\r\n          this.sinkCapability = createPromiseCapability();\r\n          this.ready = this.sinkCapability.promise;\r\n        }\r\n        sendStreamRequest({\r\n          stream: 'enqueue',\r\n          chunk: chunk,\r\n          transfers: transfers\r\n        });\r\n      },\r\n      close: function close() {\r\n        if (this.isCancelled) {\r\n          return;\r\n        }\r\n        this.isCancelled = true;\r\n        sendStreamRequest({ stream: 'close' });\r\n        delete self.streamSinks[streamId];\r\n      },\r\n      error: function error(reason) {\r\n        if (this.isCancelled) {\r\n          return;\r\n        }\r\n        this.isCancelled = true;\r\n        sendStreamRequest({\r\n          stream: 'error',\r\n          reason: reason\r\n        });\r\n      },\r\n\r\n      sinkCapability: capability,\r\n      onPull: null,\r\n      onCancel: null,\r\n      isCancelled: false,\r\n      desiredSize: desiredSize,\r\n      ready: null\r\n    };\r\n    streamSink.sinkCapability.resolve();\r\n    streamSink.ready = streamSink.sinkCapability.promise;\r\n    this.streamSinks[streamId] = streamSink;\r\n    resolveCall(action[0], [data.data, streamSink], action[1]).then(function () {\r\n      sendStreamRequest({\r\n        stream: 'start_complete',\r\n        success: true\r\n      });\r\n    }, function (reason) {\r\n      sendStreamRequest({\r\n        stream: 'start_complete',\r\n        success: false,\r\n        reason: reason\r\n      });\r\n    });\r\n  },\r\n  _processStreamMessage: function _processStreamMessage(data) {\r\n    var _this4 = this;\r\n\r\n    var sourceName = this.sourceName;\r\n    var targetName = data.sourceName;\r\n    var streamId = data.streamId;\r\n    var sendStreamResponse = function sendStreamResponse(_ref3) {\r\n      var stream = _ref3.stream,\r\n          success = _ref3.success,\r\n          reason = _ref3.reason;\r\n\r\n      _this4.comObj.postMessage({\r\n        sourceName: sourceName,\r\n        targetName: targetName,\r\n        stream: stream,\r\n        success: success,\r\n        streamId: streamId,\r\n        reason: reason\r\n      });\r\n    };\r\n    var deleteStreamController = function deleteStreamController() {\r\n      Promise.all([_this4.streamControllers[data.streamId].startCall, _this4.streamControllers[data.streamId].pullCall, _this4.streamControllers[data.streamId].cancelCall].map(function (capability) {\r\n        return capability && finalize(capability.promise);\r\n      })).then(function () {\r\n        delete _this4.streamControllers[data.streamId];\r\n      });\r\n    };\r\n    switch (data.stream) {\r\n      case 'start_complete':\r\n        resolveOrReject(this.streamControllers[data.streamId].startCall, data.success, wrapReason(data.reason));\r\n        break;\r\n      case 'pull_complete':\r\n        resolveOrReject(this.streamControllers[data.streamId].pullCall, data.success, wrapReason(data.reason));\r\n        break;\r\n      case 'pull':\r\n        if (!this.streamSinks[data.streamId]) {\r\n          sendStreamResponse({\r\n            stream: 'pull_complete',\r\n            success: true\r\n          });\r\n          break;\r\n        }\r\n        if (this.streamSinks[data.streamId].desiredSize <= 0 && data.desiredSize > 0) {\r\n          this.streamSinks[data.streamId].sinkCapability.resolve();\r\n        }\r\n        this.streamSinks[data.streamId].desiredSize = data.desiredSize;\r\n        resolveCall(this.streamSinks[data.streamId].onPull).then(function () {\r\n          sendStreamResponse({\r\n            stream: 'pull_complete',\r\n            success: true\r\n          });\r\n        }, function (reason) {\r\n          sendStreamResponse({\r\n            stream: 'pull_complete',\r\n            success: false,\r\n            reason: reason\r\n          });\r\n        });\r\n        break;\r\n      case 'enqueue':\r\n        assert(this.streamControllers[data.streamId], 'enqueue should have stream controller');\r\n        if (!this.streamControllers[data.streamId].isClosed) {\r\n          this.streamControllers[data.streamId].controller.enqueue(data.chunk);\r\n        }\r\n        break;\r\n      case 'close':\r\n        assert(this.streamControllers[data.streamId], 'close should have stream controller');\r\n        if (this.streamControllers[data.streamId].isClosed) {\r\n          break;\r\n        }\r\n        this.streamControllers[data.streamId].isClosed = true;\r\n        this.streamControllers[data.streamId].controller.close();\r\n        deleteStreamController();\r\n        break;\r\n      case 'error':\r\n        assert(this.streamControllers[data.streamId], 'error should have stream controller');\r\n        this.streamControllers[data.streamId].controller.error(wrapReason(data.reason));\r\n        deleteStreamController();\r\n        break;\r\n      case 'cancel_complete':\r\n        resolveOrReject(this.streamControllers[data.streamId].cancelCall, data.success, wrapReason(data.reason));\r\n        deleteStreamController();\r\n        break;\r\n      case 'cancel':\r\n        if (!this.streamSinks[data.streamId]) {\r\n          break;\r\n        }\r\n        resolveCall(this.streamSinks[data.streamId].onCancel, [wrapReason(data.reason)]).then(function () {\r\n          sendStreamResponse({\r\n            stream: 'cancel_complete',\r\n            success: true\r\n          });\r\n        }, function (reason) {\r\n          sendStreamResponse({\r\n            stream: 'cancel_complete',\r\n            success: false,\r\n            reason: reason\r\n          });\r\n        });\r\n        this.streamSinks[data.streamId].sinkCapability.reject(wrapReason(data.reason));\r\n        this.streamSinks[data.streamId].isCancelled = true;\r\n        delete this.streamSinks[data.streamId];\r\n        break;\r\n      default:\r\n        throw new Error('Unexpected stream case');\r\n    }\r\n  },\r\n  postMessage: function postMessage(message, transfers) {\r\n    if (transfers && this.postMessageTransfers) {\r\n      this.comObj.postMessage(message, transfers);\r\n    } else {\r\n      this.comObj.postMessage(message);\r\n    }\r\n  },\r\n  destroy: function destroy() {\r\n    this.comObj.removeEventListener('message', this._onComObjOnMessage);\r\n  }\r\n};\r\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\r\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\r\nexports.OPS = OPS;\r\nexports.VerbosityLevel = VerbosityLevel;\r\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\r\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\r\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\r\nexports.AnnotationFlag = AnnotationFlag;\r\nexports.AnnotationType = AnnotationType;\r\nexports.FontType = FontType;\r\nexports.ImageKind = ImageKind;\r\nexports.CMapCompressionType = CMapCompressionType;\r\nexports.AbortException = AbortException;\r\nexports.InvalidPDFException = InvalidPDFException;\r\nexports.MessageHandler = MessageHandler;\r\nexports.MissingDataException = MissingDataException;\r\nexports.MissingPDFException = MissingPDFException;\r\nexports.NativeImageDecoding = NativeImageDecoding;\r\nexports.NotImplementedException = NotImplementedException;\r\nexports.PageViewport = PageViewport;\r\nexports.PasswordException = PasswordException;\r\nexports.PasswordResponses = PasswordResponses;\r\nexports.StreamType = StreamType;\r\nexports.TextRenderingMode = TextRenderingMode;\r\nexports.UnexpectedResponseException = UnexpectedResponseException;\r\nexports.UnknownErrorException = UnknownErrorException;\r\nexports.Util = Util;\r\nexports.XRefParseException = XRefParseException;\r\nexports.FormatError = FormatError;\r\nexports.arrayByteLength = arrayByteLength;\r\nexports.arraysToBytes = arraysToBytes;\r\nexports.assert = assert;\r\nexports.bytesToString = bytesToString;\r\nexports.createBlob = createBlob;\r\nexports.createPromiseCapability = createPromiseCapability;\r\nexports.createObjectURL = createObjectURL;\r\nexports.deprecated = deprecated;\r\nexports.getInheritableProperty = getInheritableProperty;\r\nexports.getLookupTableFactory = getLookupTableFactory;\r\nexports.getVerbosityLevel = getVerbosityLevel;\r\nexports.info = info;\r\nexports.isArrayBuffer = isArrayBuffer;\r\nexports.isBool = isBool;\r\nexports.isEmptyObj = isEmptyObj;\r\nexports.isNum = isNum;\r\nexports.isString = isString;\r\nexports.isSpace = isSpace;\r\nexports.isSameOrigin = isSameOrigin;\r\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\r\nexports.isLittleEndian = isLittleEndian;\r\nexports.isEvalSupported = isEvalSupported;\r\nexports.log2 = log2;\r\nexports.readInt8 = readInt8;\r\nexports.readUint16 = readUint16;\r\nexports.readUint32 = readUint32;\r\nexports.removeNullCharacters = removeNullCharacters;\r\nexports.ReadableStream = _streams_polyfill.ReadableStream;\r\nexports.setVerbosityLevel = setVerbosityLevel;\r\nexports.shadow = shadow;\r\nexports.string32 = string32;\r\nexports.stringToBytes = stringToBytes;\r\nexports.stringToPDFString = stringToPDFString;\r\nexports.stringToUTF8String = stringToUTF8String;\r\nexports.utf8StringToString = utf8StringToString;\r\nexports.warn = warn;\r\nexports.unreachable = unreachable;\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar store = __w_pdfjs_require__(42)('wks');\r\nvar uid = __w_pdfjs_require__(19);\r\nvar _Symbol = __w_pdfjs_require__(4).Symbol;\r\nvar USE_SYMBOL = typeof _Symbol == 'function';\r\nvar $exports = module.exports = function (name) {\r\n  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));\r\n};\r\n$exports.store = store;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nmodule.exports = function (it) {\r\n  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';\r\n};\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar global = __w_pdfjs_require__(4);\r\nvar core = __w_pdfjs_require__(5);\r\nvar hide = __w_pdfjs_require__(10);\r\nvar redefine = __w_pdfjs_require__(7);\r\nvar ctx = __w_pdfjs_require__(9);\r\nvar PROTOTYPE = 'prototype';\r\nvar $export = function $export(type, name, source) {\r\n  var IS_FORCED = type & $export.F;\r\n  var IS_GLOBAL = type & $export.G;\r\n  var IS_STATIC = type & $export.S;\r\n  var IS_PROTO = type & $export.P;\r\n  var IS_BIND = type & $export.B;\r\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\r\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\r\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\r\n  var key, own, out, exp;\r\n  if (IS_GLOBAL) source = name;\r\n  for (key in source) {\r\n    own = !IS_FORCED && target && target[key] !== undefined;\r\n    out = (own ? target : source)[key];\r\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\r\n    if (target) redefine(target, key, out, type & $export.U);\r\n    if (exports[key] != out) hide(exports, key, exp);\r\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\r\n  }\r\n};\r\nglobal.core = core;\r\n$export.F = 1;\r\n$export.G = 2;\r\n$export.S = 4;\r\n$export.P = 8;\r\n$export.B = 16;\r\n$export.W = 32;\r\n$export.U = 64;\r\n$export.R = 128;\r\nmodule.exports = $export;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\r\nif (typeof __g == 'number') __g = global;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar core = module.exports = { version: '2.5.5' };\r\nif (typeof __e == 'number') __e = core;\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nmodule.exports = function (it) {\r\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\r\n  return it;\r\n};\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar global = __w_pdfjs_require__(4);\r\nvar hide = __w_pdfjs_require__(10);\r\nvar has = __w_pdfjs_require__(8);\r\nvar SRC = __w_pdfjs_require__(19)('src');\r\nvar TO_STRING = 'toString';\r\nvar $toString = Function[TO_STRING];\r\nvar TPL = ('' + $toString).split(TO_STRING);\r\n__w_pdfjs_require__(5).inspectSource = function (it) {\r\n  return $toString.call(it);\r\n};\r\n(module.exports = function (O, key, val, safe) {\r\n  var isFunction = typeof val == 'function';\r\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\r\n  if (O[key] === val) return;\r\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\r\n  if (O === global) {\r\n    O[key] = val;\r\n  } else if (!safe) {\r\n    delete O[key];\r\n    hide(O, key, val);\r\n  } else if (O[key]) {\r\n    O[key] = val;\r\n  } else {\r\n    hide(O, key, val);\r\n  }\r\n})(Function.prototype, TO_STRING, function toString() {\r\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\r\n});\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar hasOwnProperty = {}.hasOwnProperty;\r\nmodule.exports = function (it, key) {\r\n  return hasOwnProperty.call(it, key);\r\n};\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar aFunction = __w_pdfjs_require__(15);\r\nmodule.exports = function (fn, that, length) {\r\n  aFunction(fn);\r\n  if (that === undefined) return fn;\r\n  switch (length) {\r\n    case 1:\r\n      return function (a) {\r\n        return fn.call(that, a);\r\n      };\r\n    case 2:\r\n      return function (a, b) {\r\n        return fn.call(that, a, b);\r\n      };\r\n    case 3:\r\n      return function (a, b, c) {\r\n        return fn.call(that, a, b, c);\r\n      };\r\n  }\r\n  return function () {\r\n    return fn.apply(that, arguments);\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar dP = __w_pdfjs_require__(14);\r\nvar createDesc = __w_pdfjs_require__(27);\r\nmodule.exports = __w_pdfjs_require__(11) ? function (object, key, value) {\r\n  return dP.f(object, key, createDesc(1, value));\r\n} : function (object, key, value) {\r\n  object[key] = value;\r\n  return object;\r\n};\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = !__w_pdfjs_require__(12)(function () {\r\n  return Object.defineProperty({}, 'a', {\r\n    get: function get() {\r\n      return 7;\r\n    }\r\n  }).a != 7;\r\n});\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (exec) {\r\n  try {\r\n    return !!exec();\r\n  } catch (e) {\r\n    return true;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar toString = {}.toString;\r\nmodule.exports = function (it) {\r\n  return toString.call(it).slice(8, -1);\r\n};\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(40);\r\nvar toPrimitive = __w_pdfjs_require__(41);\r\nvar dP = Object.defineProperty;\r\nexports.f = __w_pdfjs_require__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\r\n  anObject(O);\r\n  P = toPrimitive(P, true);\r\n  anObject(Attributes);\r\n  if (IE8_DOM_DEFINE) try {\r\n    return dP(O, P, Attributes);\r\n  } catch (e) {}\r\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\r\n  if ('value' in Attributes) O[P] = Attributes.value;\r\n  return O;\r\n};\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (it) {\r\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\r\n  return it;\r\n};\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar IObject = __w_pdfjs_require__(28);\r\nvar defined = __w_pdfjs_require__(20);\r\nmodule.exports = function (it) {\r\n  return IObject(defined(it));\r\n};\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = {};\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = typeof window !== 'undefined' && window.Math === Math ? window : typeof global !== 'undefined' && global.Math === Math ? global : typeof self !== 'undefined' && self.Math === Math ? self : {};\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar id = 0;\r\nvar px = Math.random();\r\nmodule.exports = function (key) {\r\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\r\n};\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (it) {\r\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\r\n  return it;\r\n};\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $keys = __w_pdfjs_require__(83);\r\nvar enumBugKeys = __w_pdfjs_require__(48);\r\nmodule.exports = Object.keys || function keys(O) {\r\n  return $keys(O, enumBugKeys);\r\n};\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar def = __w_pdfjs_require__(14).f;\r\nvar has = __w_pdfjs_require__(8);\r\nvar TAG = __w_pdfjs_require__(1)('toStringTag');\r\nmodule.exports = function (it, tag, stat) {\r\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {\r\n    configurable: true,\r\n    value: tag\r\n  });\r\n};\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar ctx = __w_pdfjs_require__(9);\r\nvar call = __w_pdfjs_require__(88);\r\nvar isArrayIter = __w_pdfjs_require__(89);\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar toLength = __w_pdfjs_require__(29);\r\nvar getIterFn = __w_pdfjs_require__(90);\r\nvar BREAK = {};\r\nvar RETURN = {};\r\nvar _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\r\n  var iterFn = ITERATOR ? function () {\r\n    return iterable;\r\n  } : getIterFn(iterable);\r\n  var f = ctx(fn, that, entries ? 2 : 1);\r\n  var index = 0;\r\n  var length, step, iterator, result;\r\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\r\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\r\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\r\n    if (result === BREAK || result === RETURN) return result;\r\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\r\n    result = call(iterator, f, step.value, entries);\r\n    if (result === BREAK || result === RETURN) return result;\r\n  }\r\n};\r\n_exports.BREAK = BREAK;\r\n_exports.RETURN = RETURN;\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DummyStatTimer = exports.StatTimer = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.LinkTarget = exports.getFilenameFromUrl = exports.addLinkAttributes = exports.RenderingCancelledException = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar DEFAULT_LINK_REL = 'noopener noreferrer nofollow';\r\nvar SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nvar DOMCanvasFactory = function () {\r\n  function DOMCanvasFactory() {\r\n    _classCallCheck(this, DOMCanvasFactory);\r\n  }\r\n\r\n  _createClass(DOMCanvasFactory, [{\r\n    key: 'create',\r\n    value: function create(width, height) {\r\n      if (width <= 0 || height <= 0) {\r\n        throw new Error('invalid canvas size');\r\n      }\r\n      var canvas = document.createElement('canvas');\r\n      var context = canvas.getContext('2d');\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      return {\r\n        canvas: canvas,\r\n        context: context\r\n      };\r\n    }\r\n  }, {\r\n    key: 'reset',\r\n    value: function reset(canvasAndContext, width, height) {\r\n      if (!canvasAndContext.canvas) {\r\n        throw new Error('canvas is not specified');\r\n      }\r\n      if (width <= 0 || height <= 0) {\r\n        throw new Error('invalid canvas size');\r\n      }\r\n      canvasAndContext.canvas.width = width;\r\n      canvasAndContext.canvas.height = height;\r\n    }\r\n  }, {\r\n    key: 'destroy',\r\n    value: function destroy(canvasAndContext) {\r\n      if (!canvasAndContext.canvas) {\r\n        throw new Error('canvas is not specified');\r\n      }\r\n      canvasAndContext.canvas.width = 0;\r\n      canvasAndContext.canvas.height = 0;\r\n      canvasAndContext.canvas = null;\r\n      canvasAndContext.context = null;\r\n    }\r\n  }]);\r\n\r\n  return DOMCanvasFactory;\r\n}();\r\n\r\nvar DOMCMapReaderFactory = function () {\r\n  function DOMCMapReaderFactory(_ref) {\r\n    var _ref$baseUrl = _ref.baseUrl,\r\n        baseUrl = _ref$baseUrl === undefined ? null : _ref$baseUrl,\r\n        _ref$isCompressed = _ref.isCompressed,\r\n        isCompressed = _ref$isCompressed === undefined ? false : _ref$isCompressed;\r\n\r\n    _classCallCheck(this, DOMCMapReaderFactory);\r\n\r\n    this.baseUrl = baseUrl;\r\n    this.isCompressed = isCompressed;\r\n  }\r\n\r\n  _createClass(DOMCMapReaderFactory, [{\r\n    key: 'fetch',\r\n    value: function fetch(_ref2) {\r\n      var _this = this;\r\n\r\n      var name = _ref2.name;\r\n\r\n      if (!this.baseUrl) {\r\n        return Promise.reject(new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.'));\r\n      }\r\n      if (!name) {\r\n        return Promise.reject(new Error('CMap name must be specified.'));\r\n      }\r\n      return new Promise(function (resolve, reject) {\r\n        var url = _this.baseUrl + name + (_this.isCompressed ? '.bcmap' : '');\r\n        var request = new XMLHttpRequest();\r\n        request.open('GET', url, true);\r\n        if (_this.isCompressed) {\r\n          request.responseType = 'arraybuffer';\r\n        }\r\n        request.onreadystatechange = function () {\r\n          if (request.readyState !== XMLHttpRequest.DONE) {\r\n            return;\r\n          }\r\n          if (request.status === 200 || request.status === 0) {\r\n            var data = void 0;\r\n            if (_this.isCompressed && request.response) {\r\n              data = new Uint8Array(request.response);\r\n            } else if (!_this.isCompressed && request.responseText) {\r\n              data = (0, _util.stringToBytes)(request.responseText);\r\n            }\r\n            if (data) {\r\n              resolve({\r\n                cMapData: data,\r\n                compressionType: _this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE\r\n              });\r\n              return;\r\n            }\r\n          }\r\n          reject(new Error('Unable to load ' + (_this.isCompressed ? 'binary ' : '') + 'CMap at: ' + url));\r\n        };\r\n        request.send(null);\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return DOMCMapReaderFactory;\r\n}();\r\n\r\nvar DOMSVGFactory = function () {\r\n  function DOMSVGFactory() {\r\n    _classCallCheck(this, DOMSVGFactory);\r\n  }\r\n\r\n  _createClass(DOMSVGFactory, [{\r\n    key: 'create',\r\n    value: function create(width, height) {\r\n      (0, _util.assert)(width > 0 && height > 0, 'Invalid SVG dimensions');\r\n      var svg = document.createElementNS(SVG_NS, 'svg:svg');\r\n      svg.setAttribute('version', '1.1');\r\n      svg.setAttribute('width', width + 'px');\r\n      svg.setAttribute('height', height + 'px');\r\n      svg.setAttribute('preserveAspectRatio', 'none');\r\n      svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);\r\n      return svg;\r\n    }\r\n  }, {\r\n    key: 'createElement',\r\n    value: function createElement(type) {\r\n      (0, _util.assert)(typeof type === 'string', 'Invalid SVG element type');\r\n      return document.createElementNS(SVG_NS, type);\r\n    }\r\n  }]);\r\n\r\n  return DOMSVGFactory;\r\n}();\r\n\r\nvar RenderingCancelledException = function RenderingCancelledException() {\r\n  function RenderingCancelledException(msg, type) {\r\n    this.message = msg;\r\n    this.type = type;\r\n  }\r\n  RenderingCancelledException.prototype = new Error();\r\n  RenderingCancelledException.prototype.name = 'RenderingCancelledException';\r\n  RenderingCancelledException.constructor = RenderingCancelledException;\r\n  return RenderingCancelledException;\r\n}();\r\nvar LinkTarget = {\r\n  NONE: 0,\r\n  SELF: 1,\r\n  BLANK: 2,\r\n  PARENT: 3,\r\n  TOP: 4\r\n};\r\nvar LinkTargetStringMap = ['', '_self', '_blank', '_parent', '_top'];\r\nfunction addLinkAttributes(link) {\r\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n      url = _ref3.url,\r\n      target = _ref3.target,\r\n      rel = _ref3.rel;\r\n\r\n  link.href = link.title = url ? (0, _util.removeNullCharacters)(url) : '';\r\n  if (url) {\r\n    var LinkTargetValues = Object.values(LinkTarget);\r\n    var targetIndex = LinkTargetValues.includes(target) ? target : LinkTarget.NONE;\r\n    link.target = LinkTargetStringMap[targetIndex];\r\n    link.rel = typeof rel === 'string' ? rel : DEFAULT_LINK_REL;\r\n  }\r\n}\r\nfunction getFilenameFromUrl(url) {\r\n  var anchor = url.indexOf('#');\r\n  var query = url.indexOf('?');\r\n  var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\r\n  return url.substring(url.lastIndexOf('/', end) + 1, end);\r\n}\r\n\r\nvar StatTimer = function () {\r\n  function StatTimer() {\r\n    var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n\r\n    _classCallCheck(this, StatTimer);\r\n\r\n    this.enabled = !!enable;\r\n    this.started = Object.create(null);\r\n    this.times = [];\r\n  }\r\n\r\n  _createClass(StatTimer, [{\r\n    key: 'time',\r\n    value: function time(name) {\r\n      if (!this.enabled) {\r\n        return;\r\n      }\r\n      if (name in this.started) {\r\n        (0, _util.warn)('Timer is already running for ' + name);\r\n      }\r\n      this.started[name] = Date.now();\r\n    }\r\n  }, {\r\n    key: 'timeEnd',\r\n    value: function timeEnd(name) {\r\n      if (!this.enabled) {\r\n        return;\r\n      }\r\n      if (!(name in this.started)) {\r\n        (0, _util.warn)('Timer has not been started for ' + name);\r\n      }\r\n      this.times.push({\r\n        'name': name,\r\n        'start': this.started[name],\r\n        'end': Date.now()\r\n      });\r\n      delete this.started[name];\r\n    }\r\n  }, {\r\n    key: 'toString',\r\n    value: function toString() {\r\n      var times = this.times;\r\n      var out = '',\r\n          longest = 0;\r\n      for (var i = 0, ii = times.length; i < ii; ++i) {\r\n        var name = times[i]['name'];\r\n        if (name.length > longest) {\r\n          longest = name.length;\r\n        }\r\n      }\r\n      for (var _i = 0, _ii = times.length; _i < _ii; ++_i) {\r\n        var span = times[_i];\r\n        var duration = span.end - span.start;\r\n        out += span['name'].padEnd(longest) + ' ' + duration + 'ms\\n';\r\n      }\r\n      return out;\r\n    }\r\n  }]);\r\n\r\n  return StatTimer;\r\n}();\r\n\r\nvar DummyStatTimer = function () {\r\n  function DummyStatTimer() {\r\n    _classCallCheck(this, DummyStatTimer);\r\n\r\n    (0, _util.unreachable)('Cannot initialize DummyStatTimer.');\r\n  }\r\n\r\n  _createClass(DummyStatTimer, null, [{\r\n    key: 'time',\r\n    value: function time(name) {}\r\n  }, {\r\n    key: 'timeEnd',\r\n    value: function timeEnd(name) {}\r\n  }, {\r\n    key: 'toString',\r\n    value: function toString() {\r\n      return '';\r\n    }\r\n  }]);\r\n\r\n  return DummyStatTimer;\r\n}();\r\n\r\nexports.RenderingCancelledException = RenderingCancelledException;\r\nexports.addLinkAttributes = addLinkAttributes;\r\nexports.getFilenameFromUrl = getFilenameFromUrl;\r\nexports.LinkTarget = LinkTarget;\r\nexports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;\r\nexports.DOMCanvasFactory = DOMCanvasFactory;\r\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\r\nexports.DOMSVGFactory = DOMSVGFactory;\r\nexports.StatTimer = StatTimer;\r\nexports.DummyStatTimer = DummyStatTimer;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nmodule.exports = function isNodeJS() {\r\n  return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process + '' === '[object process]';\r\n};\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar document = __w_pdfjs_require__(4).document;\r\nvar is = isObject(document) && isObject(document.createElement);\r\nmodule.exports = function (it) {\r\n  return is ? document.createElement(it) : {};\r\n};\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (bitmap, value) {\r\n  return {\r\n    enumerable: !(bitmap & 1),\r\n    configurable: !(bitmap & 2),\r\n    writable: !(bitmap & 4),\r\n    value: value\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar cof = __w_pdfjs_require__(13);\r\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\r\n  return cof(it) == 'String' ? it.split('') : Object(it);\r\n};\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar toInteger = __w_pdfjs_require__(30);\r\nvar min = Math.min;\r\nmodule.exports = function (it) {\r\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;\r\n};\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar ceil = Math.ceil;\r\nvar floor = Math.floor;\r\nmodule.exports = function (it) {\r\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\r\n};\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar cof = __w_pdfjs_require__(13);\r\nvar TAG = __w_pdfjs_require__(1)('toStringTag');\r\nvar ARG = cof(function () {\r\n  return arguments;\r\n}()) == 'Arguments';\r\nvar tryGet = function tryGet(it, key) {\r\n  try {\r\n    return it[key];\r\n  } catch (e) {}\r\n};\r\nmodule.exports = function (it) {\r\n  var O, T, B;\r\n  return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\r\n};\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar shared = __w_pdfjs_require__(42)('keys');\r\nvar uid = __w_pdfjs_require__(19);\r\nmodule.exports = function (key) {\r\n  return shared[key] || (shared[key] = uid(key));\r\n};\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar defined = __w_pdfjs_require__(20);\r\nmodule.exports = function (it) {\r\n  return Object(defined(it));\r\n};\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (it, Constructor, name, forbiddenField) {\r\n  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {\r\n    throw TypeError(name + ': incorrect invocation!');\r\n  }\r\n  return it;\r\n};\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar aFunction = __w_pdfjs_require__(15);\r\nfunction PromiseCapability(C) {\r\n  var resolve, reject;\r\n  this.promise = new C(function ($$resolve, $$reject) {\r\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\r\n    resolve = $$resolve;\r\n    reject = $$reject;\r\n  });\r\n  this.resolve = aFunction(resolve);\r\n  this.reject = aFunction(reject);\r\n}\r\nmodule.exports.f = function (C) {\r\n  return new PromiseCapability(C);\r\n};\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar redefine = __w_pdfjs_require__(7);\r\nmodule.exports = function (target, src, safe) {\r\n  for (var key in src) {\r\n    redefine(target, key, src[key], safe);\r\n  }return target;\r\n};\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar META = __w_pdfjs_require__(19)('meta');\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar has = __w_pdfjs_require__(8);\r\nvar setDesc = __w_pdfjs_require__(14).f;\r\nvar id = 0;\r\nvar isExtensible = Object.isExtensible || function () {\r\n  return true;\r\n};\r\nvar FREEZE = !__w_pdfjs_require__(12)(function () {\r\n  return isExtensible(Object.preventExtensions({}));\r\n});\r\nvar setMeta = function setMeta(it) {\r\n  setDesc(it, META, {\r\n    value: {\r\n      i: 'O' + ++id,\r\n      w: {}\r\n    }\r\n  });\r\n};\r\nvar fastKey = function fastKey(it, create) {\r\n  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\r\n  if (!has(it, META)) {\r\n    if (!isExtensible(it)) return 'F';\r\n    if (!create) return 'E';\r\n    setMeta(it);\r\n  }\r\n  return it[META].i;\r\n};\r\nvar getWeak = function getWeak(it, create) {\r\n  if (!has(it, META)) {\r\n    if (!isExtensible(it)) return true;\r\n    if (!create) return false;\r\n    setMeta(it);\r\n  }\r\n  return it[META].w;\r\n};\r\nvar onFreeze = function onFreeze(it) {\r\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\r\n  return it;\r\n};\r\nvar meta = module.exports = {\r\n  KEY: META,\r\n  NEED: false,\r\n  fastKey: fastKey,\r\n  getWeak: getWeak,\r\n  onFreeze: onFreeze\r\n};\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nexports.f = {}.propertyIsEnumerable;\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.validateResponseStatus = exports.validateRangeRequestCapabilities = exports.extractFilenameFromHeader = exports.createResponseStatusError = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _content_disposition = __w_pdfjs_require__(129);\r\n\r\nfunction validateRangeRequestCapabilities(_ref) {\r\n  var getResponseHeader = _ref.getResponseHeader,\r\n      isHttp = _ref.isHttp,\r\n      rangeChunkSize = _ref.rangeChunkSize,\r\n      disableRange = _ref.disableRange;\r\n\r\n  (0, _util.assert)(rangeChunkSize > 0, 'Range chunk size must be larger than zero');\r\n  var returnValues = {\r\n    allowRangeRequests: false,\r\n    suggestedLength: undefined\r\n  };\r\n  if (disableRange || !isHttp) {\r\n    return returnValues;\r\n  }\r\n  if (getResponseHeader('Accept-Ranges') !== 'bytes') {\r\n    return returnValues;\r\n  }\r\n  var contentEncoding = getResponseHeader('Content-Encoding') || 'identity';\r\n  if (contentEncoding !== 'identity') {\r\n    return returnValues;\r\n  }\r\n  var length = parseInt(getResponseHeader('Content-Length'), 10);\r\n  if (!Number.isInteger(length)) {\r\n    return returnValues;\r\n  }\r\n  returnValues.suggestedLength = length;\r\n  if (length <= 2 * rangeChunkSize) {\r\n    return returnValues;\r\n  }\r\n  returnValues.allowRangeRequests = true;\r\n  return returnValues;\r\n}\r\nfunction extractFilenameFromHeader(getResponseHeader) {\r\n  var contentDisposition = getResponseHeader('Content-Disposition');\r\n  if (contentDisposition) {\r\n    var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\r\n    if (/\\.pdf$/i.test(filename)) {\r\n      return filename;\r\n    }\r\n  }\r\n  return null;\r\n}\r\nfunction createResponseStatusError(status, url) {\r\n  if (status === 404 || status === 0 && /^file:/.test(url)) {\r\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\r\n  }\r\n  return new _util.UnexpectedResponseException('Unexpected server response (' + status + ') while retrieving PDF \"' + url + '\".', status);\r\n}\r\nfunction validateResponseStatus(status) {\r\n  return status === 200 || status === 206;\r\n}\r\nexports.createResponseStatusError = createResponseStatusError;\r\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\r\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\r\nexports.validateResponseStatus = validateResponseStatus;\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = !__w_pdfjs_require__(11) && !__w_pdfjs_require__(12)(function () {\r\n  return Object.defineProperty(__w_pdfjs_require__(26)('div'), 'a', {\r\n    get: function get() {\r\n      return 7;\r\n    }\r\n  }).a != 7;\r\n});\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nmodule.exports = function (it, S) {\r\n  if (!isObject(it)) return it;\r\n  var fn, val;\r\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\r\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\r\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\r\n  throw TypeError(\"Can't convert object to primitive value\");\r\n};\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar global = __w_pdfjs_require__(4);\r\nvar SHARED = '__core-js_shared__';\r\nvar store = global[SHARED] || (global[SHARED] = {});\r\nmodule.exports = function (key) {\r\n  return store[key] || (store[key] = {});\r\n};\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar toIObject = __w_pdfjs_require__(16);\r\nvar toLength = __w_pdfjs_require__(29);\r\nvar toAbsoluteIndex = __w_pdfjs_require__(69);\r\nmodule.exports = function (IS_INCLUDES) {\r\n  return function ($this, el, fromIndex) {\r\n    var O = toIObject($this);\r\n    var length = toLength(O.length);\r\n    var index = toAbsoluteIndex(fromIndex, length);\r\n    var value;\r\n    if (IS_INCLUDES && el != el) while (length > index) {\r\n      value = O[index++];\r\n      if (value != value) return true;\r\n    } else for (; length > index; index++) {\r\n      if (IS_INCLUDES || index in O) {\r\n        if (O[index] === el) return IS_INCLUDES || index || 0;\r\n      }\r\n    }return !IS_INCLUDES && -1;\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar UNSCOPABLES = __w_pdfjs_require__(1)('unscopables');\r\nvar ArrayProto = Array.prototype;\r\nif (ArrayProto[UNSCOPABLES] == undefined) __w_pdfjs_require__(10)(ArrayProto, UNSCOPABLES, {});\r\nmodule.exports = function (key) {\r\n  ArrayProto[UNSCOPABLES][key] = true;\r\n};\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar classof = __w_pdfjs_require__(31);\r\nvar test = {};\r\ntest[__w_pdfjs_require__(1)('toStringTag')] = 'z';\r\nif (test + '' != '[object z]') {\r\n  __w_pdfjs_require__(7)(Object.prototype, 'toString', function toString() {\r\n    return '[object ' + classof(this) + ']';\r\n  }, true);\r\n}\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar LIBRARY = __w_pdfjs_require__(47);\r\nvar $export = __w_pdfjs_require__(3);\r\nvar redefine = __w_pdfjs_require__(7);\r\nvar hide = __w_pdfjs_require__(10);\r\nvar Iterators = __w_pdfjs_require__(17);\r\nvar $iterCreate = __w_pdfjs_require__(80);\r\nvar setToStringTag = __w_pdfjs_require__(22);\r\nvar getPrototypeOf = __w_pdfjs_require__(84);\r\nvar ITERATOR = __w_pdfjs_require__(1)('iterator');\r\nvar BUGGY = !([].keys && 'next' in [].keys());\r\nvar FF_ITERATOR = '@@iterator';\r\nvar KEYS = 'keys';\r\nvar VALUES = 'values';\r\nvar returnThis = function returnThis() {\r\n  return this;\r\n};\r\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\r\n  $iterCreate(Constructor, NAME, next);\r\n  var getMethod = function getMethod(kind) {\r\n    if (!BUGGY && kind in proto) return proto[kind];\r\n    switch (kind) {\r\n      case KEYS:\r\n        return function keys() {\r\n          return new Constructor(this, kind);\r\n        };\r\n      case VALUES:\r\n        return function values() {\r\n          return new Constructor(this, kind);\r\n        };\r\n    }\r\n    return function entries() {\r\n      return new Constructor(this, kind);\r\n    };\r\n  };\r\n  var TAG = NAME + ' Iterator';\r\n  var DEF_VALUES = DEFAULT == VALUES;\r\n  var VALUES_BUG = false;\r\n  var proto = Base.prototype;\r\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\r\n  var $default = $native || getMethod(DEFAULT);\r\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\r\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\r\n  var methods, key, IteratorPrototype;\r\n  if ($anyNative) {\r\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\r\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\r\n      setToStringTag(IteratorPrototype, TAG, true);\r\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\r\n    }\r\n  }\r\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\r\n    VALUES_BUG = true;\r\n    $default = function values() {\r\n      return $native.call(this);\r\n    };\r\n  }\r\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\r\n    hide(proto, ITERATOR, $default);\r\n  }\r\n  Iterators[NAME] = $default;\r\n  Iterators[TAG] = returnThis;\r\n  if (DEFAULT) {\r\n    methods = {\r\n      values: DEF_VALUES ? $default : getMethod(VALUES),\r\n      keys: IS_SET ? $default : getMethod(KEYS),\r\n      entries: $entries\r\n    };\r\n    if (FORCED) for (key in methods) {\r\n      if (!(key in proto)) redefine(proto, key, methods[key]);\r\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\r\n  }\r\n  return methods;\r\n};\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = false;\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');\r\n\r\n/***/ }),\r\n/* 49 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar document = __w_pdfjs_require__(4).document;\r\nmodule.exports = document && document.documentElement;\r\n\r\n/***/ }),\r\n/* 50 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $iterators = __w_pdfjs_require__(85);\r\nvar getKeys = __w_pdfjs_require__(21);\r\nvar redefine = __w_pdfjs_require__(7);\r\nvar global = __w_pdfjs_require__(4);\r\nvar hide = __w_pdfjs_require__(10);\r\nvar Iterators = __w_pdfjs_require__(17);\r\nvar wks = __w_pdfjs_require__(1);\r\nvar ITERATOR = wks('iterator');\r\nvar TO_STRING_TAG = wks('toStringTag');\r\nvar ArrayValues = Iterators.Array;\r\nvar DOMIterables = {\r\n  CSSRuleList: true,\r\n  CSSStyleDeclaration: false,\r\n  CSSValueList: false,\r\n  ClientRectList: false,\r\n  DOMRectList: false,\r\n  DOMStringList: false,\r\n  DOMTokenList: true,\r\n  DataTransferItemList: false,\r\n  FileList: false,\r\n  HTMLAllCollection: false,\r\n  HTMLCollection: false,\r\n  HTMLFormElement: false,\r\n  HTMLSelectElement: false,\r\n  MediaList: true,\r\n  MimeTypeArray: false,\r\n  NamedNodeMap: false,\r\n  NodeList: true,\r\n  PaintRequestList: false,\r\n  Plugin: false,\r\n  PluginArray: false,\r\n  SVGLengthList: false,\r\n  SVGNumberList: false,\r\n  SVGPathSegList: false,\r\n  SVGPointList: false,\r\n  SVGStringList: false,\r\n  SVGTransformList: false,\r\n  SourceBufferList: false,\r\n  StyleSheetList: true,\r\n  TextTrackCueList: false,\r\n  TextTrackList: false,\r\n  TouchList: false\r\n};\r\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\r\n  var NAME = collections[i];\r\n  var explicit = DOMIterables[NAME];\r\n  var Collection = global[NAME];\r\n  var proto = Collection && Collection.prototype;\r\n  var key;\r\n  if (proto) {\r\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\r\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\r\n    Iterators[NAME] = ArrayValues;\r\n    if (explicit) for (key in $iterators) {\r\n      if (!proto[key]) redefine(proto, key, $iterators[key], true);\r\n    }\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 51 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar aFunction = __w_pdfjs_require__(15);\r\nvar SPECIES = __w_pdfjs_require__(1)('species');\r\nmodule.exports = function (O, D) {\r\n  var C = anObject(O).constructor;\r\n  var S;\r\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\r\n};\r\n\r\n/***/ }),\r\n/* 52 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar ctx = __w_pdfjs_require__(9);\r\nvar invoke = __w_pdfjs_require__(91);\r\nvar html = __w_pdfjs_require__(49);\r\nvar cel = __w_pdfjs_require__(26);\r\nvar global = __w_pdfjs_require__(4);\r\nvar process = global.process;\r\nvar setTask = global.setImmediate;\r\nvar clearTask = global.clearImmediate;\r\nvar MessageChannel = global.MessageChannel;\r\nvar Dispatch = global.Dispatch;\r\nvar counter = 0;\r\nvar queue = {};\r\nvar ONREADYSTATECHANGE = 'onreadystatechange';\r\nvar defer, channel, port;\r\nvar run = function run() {\r\n  var id = +this;\r\n  if (queue.hasOwnProperty(id)) {\r\n    var fn = queue[id];\r\n    delete queue[id];\r\n    fn();\r\n  }\r\n};\r\nvar listener = function listener(event) {\r\n  run.call(event.data);\r\n};\r\nif (!setTask || !clearTask) {\r\n  setTask = function setImmediate(fn) {\r\n    var args = [];\r\n    var i = 1;\r\n    while (arguments.length > i) {\r\n      args.push(arguments[i++]);\r\n    }queue[++counter] = function () {\r\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\r\n    };\r\n    defer(counter);\r\n    return counter;\r\n  };\r\n  clearTask = function clearImmediate(id) {\r\n    delete queue[id];\r\n  };\r\n  if (__w_pdfjs_require__(13)(process) == 'process') {\r\n    defer = function defer(id) {\r\n      process.nextTick(ctx(run, id, 1));\r\n    };\r\n  } else if (Dispatch && Dispatch.now) {\r\n    defer = function defer(id) {\r\n      Dispatch.now(ctx(run, id, 1));\r\n    };\r\n  } else if (MessageChannel) {\r\n    channel = new MessageChannel();\r\n    port = channel.port2;\r\n    channel.port1.onmessage = listener;\r\n    defer = ctx(port.postMessage, port, 1);\r\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\r\n    defer = function defer(id) {\r\n      global.postMessage(id + '', '*');\r\n    };\r\n    global.addEventListener('message', listener, false);\r\n  } else if (ONREADYSTATECHANGE in cel('script')) {\r\n    defer = function defer(id) {\r\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\r\n        html.removeChild(this);\r\n        run.call(id);\r\n      };\r\n    };\r\n  } else {\r\n    defer = function defer(id) {\r\n      setTimeout(ctx(run, id, 1), 0);\r\n    };\r\n  }\r\n}\r\nmodule.exports = {\r\n  set: setTask,\r\n  clear: clearTask\r\n};\r\n\r\n/***/ }),\r\n/* 53 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (exec) {\r\n  try {\r\n    return {\r\n      e: false,\r\n      v: exec()\r\n    };\r\n  } catch (e) {\r\n    return {\r\n      e: true,\r\n      v: e\r\n    };\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 54 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar newPromiseCapability = __w_pdfjs_require__(35);\r\nmodule.exports = function (C, x) {\r\n  anObject(C);\r\n  if (isObject(x) && x.constructor === C) return x;\r\n  var promiseCapability = newPromiseCapability.f(C);\r\n  var resolve = promiseCapability.resolve;\r\n  resolve(x);\r\n  return promiseCapability.promise;\r\n};\r\n\r\n/***/ }),\r\n/* 55 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar ITERATOR = __w_pdfjs_require__(1)('iterator');\r\nvar SAFE_CLOSING = false;\r\ntry {\r\n  var riter = [7][ITERATOR]();\r\n  riter['return'] = function () {\r\n    SAFE_CLOSING = true;\r\n  };\r\n  Array.from(riter, function () {\r\n    throw 2;\r\n  });\r\n} catch (e) {}\r\nmodule.exports = function (exec, skipClosing) {\r\n  if (!skipClosing && !SAFE_CLOSING) return false;\r\n  var safe = false;\r\n  try {\r\n    var arr = [7];\r\n    var iter = arr[ITERATOR]();\r\n    iter.next = function () {\r\n      return { done: safe = true };\r\n    };\r\n    arr[ITERATOR] = function () {\r\n      return iter;\r\n    };\r\n    exec(arr);\r\n  } catch (e) {}\r\n  return safe;\r\n};\r\n\r\n/***/ }),\r\n/* 56 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar ctx = __w_pdfjs_require__(9);\r\nvar IObject = __w_pdfjs_require__(28);\r\nvar toObject = __w_pdfjs_require__(33);\r\nvar toLength = __w_pdfjs_require__(29);\r\nvar asc = __w_pdfjs_require__(98);\r\nmodule.exports = function (TYPE, $create) {\r\n  var IS_MAP = TYPE == 1;\r\n  var IS_FILTER = TYPE == 2;\r\n  var IS_SOME = TYPE == 3;\r\n  var IS_EVERY = TYPE == 4;\r\n  var IS_FIND_INDEX = TYPE == 6;\r\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\r\n  var create = $create || asc;\r\n  return function ($this, callbackfn, that) {\r\n    var O = toObject($this);\r\n    var self = IObject(O);\r\n    var f = ctx(callbackfn, that, 3);\r\n    var length = toLength(self.length);\r\n    var index = 0;\r\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\r\n    var val, res;\r\n    for (; length > index; index++) {\r\n      if (NO_HOLES || index in self) {\r\n        val = self[index];\r\n        res = f(val, index, O);\r\n        if (TYPE) {\r\n          if (IS_MAP) result[index] = res;else if (res) switch (TYPE) {\r\n            case 3:\r\n              return true;\r\n            case 5:\r\n              return val;\r\n            case 6:\r\n              return index;\r\n            case 2:\r\n              result.push(val);\r\n          } else if (IS_EVERY) return false;\r\n        }\r\n      }\r\n    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 57 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nmodule.exports = function (it, TYPE) {\r\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\r\n  return it;\r\n};\r\n\r\n/***/ }),\r\n/* 58 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nvar compatibilityParams = Object.create(null);\r\n{\r\n  var userAgent = typeof navigator !== 'undefined' && navigator.userAgent || '';\r\n  var isIE = /Trident/.test(userAgent);\r\n  var isIOS = /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);\r\n  var isIOSChrome = /CriOS/.test(userAgent);\r\n  var isSafari = /Safari\\//.test(userAgent) && !/(Chrome\\/|Android\\s)/.test(userAgent);\r\n  (function checkOnBlobSupport() {\r\n    if (isIE || isIOSChrome) {\r\n      compatibilityParams.disableCreateObjectURL = true;\r\n    }\r\n  })();\r\n  (function checkRangeRequests() {\r\n    if (isSafari || isIOS) {\r\n      compatibilityParams.disableRange = true;\r\n      compatibilityParams.disableStream = true;\r\n    }\r\n  })();\r\n}\r\nvar apiCompatibilityParams = Object.freeze(compatibilityParams);\r\nexports.apiCompatibilityParams = apiCompatibilityParams;\r\n\r\n/***/ }),\r\n/* 59 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nvar GlobalWorkerOptions = Object.create(null);\r\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\r\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? '' : GlobalWorkerOptions.workerSrc;\r\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\r\n\r\n/***/ }),\r\n/* 60 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar pdfjsVersion = '2.0.489';\r\nvar pdfjsBuild = '7d7bc80e';\r\nvar pdfjsSharedUtil = __w_pdfjs_require__(0);\r\nvar pdfjsDisplayAPI = __w_pdfjs_require__(117);\r\nvar pdfjsDisplayTextLayer = __w_pdfjs_require__(125);\r\nvar pdfjsDisplayAnnotationLayer = __w_pdfjs_require__(126);\r\nvar pdfjsDisplayDOMUtils = __w_pdfjs_require__(24);\r\nvar pdfjsDisplaySVG = __w_pdfjs_require__(127);\r\nvar pdfjsDisplayWorkerOptions = __w_pdfjs_require__(59);\r\nvar pdfjsDisplayAPICompatibility = __w_pdfjs_require__(58);\r\n{\r\n  var isNodeJS = __w_pdfjs_require__(25);\r\n  if (isNodeJS()) {\r\n    var PDFNodeStream = __w_pdfjs_require__(128).PDFNodeStream;\r\n    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {\r\n      return new PDFNodeStream(params);\r\n    });\r\n  } else if (typeof Response !== 'undefined' && 'body' in Response.prototype && typeof ReadableStream !== 'undefined') {\r\n    var PDFFetchStream = __w_pdfjs_require__(130).PDFFetchStream;\r\n    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {\r\n      return new PDFFetchStream(params);\r\n    });\r\n  } else {\r\n    var PDFNetworkStream = __w_pdfjs_require__(131).PDFNetworkStream;\r\n    pdfjsDisplayAPI.setPDFNetworkStreamFactory(function (params) {\r\n      return new PDFNetworkStream(params);\r\n    });\r\n  }\r\n}\r\nexports.build = pdfjsDisplayAPI.build;\r\nexports.version = pdfjsDisplayAPI.version;\r\nexports.getDocument = pdfjsDisplayAPI.getDocument;\r\nexports.LoopbackPort = pdfjsDisplayAPI.LoopbackPort;\r\nexports.PDFDataRangeTransport = pdfjsDisplayAPI.PDFDataRangeTransport;\r\nexports.PDFWorker = pdfjsDisplayAPI.PDFWorker;\r\nexports.renderTextLayer = pdfjsDisplayTextLayer.renderTextLayer;\r\nexports.AnnotationLayer = pdfjsDisplayAnnotationLayer.AnnotationLayer;\r\nexports.createPromiseCapability = pdfjsSharedUtil.createPromiseCapability;\r\nexports.PasswordResponses = pdfjsSharedUtil.PasswordResponses;\r\nexports.InvalidPDFException = pdfjsSharedUtil.InvalidPDFException;\r\nexports.MissingPDFException = pdfjsSharedUtil.MissingPDFException;\r\nexports.SVGGraphics = pdfjsDisplaySVG.SVGGraphics;\r\nexports.NativeImageDecoding = pdfjsSharedUtil.NativeImageDecoding;\r\nexports.UnexpectedResponseException = pdfjsSharedUtil.UnexpectedResponseException;\r\nexports.OPS = pdfjsSharedUtil.OPS;\r\nexports.VerbosityLevel = pdfjsSharedUtil.VerbosityLevel;\r\nexports.UNSUPPORTED_FEATURES = pdfjsSharedUtil.UNSUPPORTED_FEATURES;\r\nexports.createValidAbsoluteUrl = pdfjsSharedUtil.createValidAbsoluteUrl;\r\nexports.createObjectURL = pdfjsSharedUtil.createObjectURL;\r\nexports.removeNullCharacters = pdfjsSharedUtil.removeNullCharacters;\r\nexports.shadow = pdfjsSharedUtil.shadow;\r\nexports.createBlob = pdfjsSharedUtil.createBlob;\r\nexports.Util = pdfjsSharedUtil.Util;\r\nexports.RenderingCancelledException = pdfjsDisplayDOMUtils.RenderingCancelledException;\r\nexports.getFilenameFromUrl = pdfjsDisplayDOMUtils.getFilenameFromUrl;\r\nexports.LinkTarget = pdfjsDisplayDOMUtils.LinkTarget;\r\nexports.addLinkAttributes = pdfjsDisplayDOMUtils.addLinkAttributes;\r\nexports.GlobalWorkerOptions = pdfjsDisplayWorkerOptions.GlobalWorkerOptions;\r\nexports.apiCompatibilityParams = pdfjsDisplayAPICompatibility.apiCompatibilityParams;\r\n\r\n/***/ }),\r\n/* 61 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar globalScope = __w_pdfjs_require__(18);\r\nif (!globalScope._pdfjsCompatibilityChecked) {\r\n  globalScope._pdfjsCompatibilityChecked = true;\r\n  var isNodeJS = __w_pdfjs_require__(25);\r\n  var hasDOM = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && (typeof document === 'undefined' ? 'undefined' : _typeof(document)) === 'object';\r\n  (function checkNodeBtoa() {\r\n    if (globalScope.btoa || !isNodeJS()) {\r\n      return;\r\n    }\r\n    globalScope.btoa = function (chars) {\r\n      return Buffer.from(chars, 'binary').toString('base64');\r\n    };\r\n  })();\r\n  (function checkNodeAtob() {\r\n    if (globalScope.atob || !isNodeJS()) {\r\n      return;\r\n    }\r\n    globalScope.atob = function (input) {\r\n      return Buffer.from(input, 'base64').toString('binary');\r\n    };\r\n  })();\r\n  (function checkCurrentScript() {\r\n    if (!hasDOM) {\r\n      return;\r\n    }\r\n    if ('currentScript' in document) {\r\n      return;\r\n    }\r\n    Object.defineProperty(document, 'currentScript', {\r\n      get: function get() {\r\n        var scripts = document.getElementsByTagName('script');\r\n        return scripts[scripts.length - 1];\r\n      },\r\n\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n  })();\r\n  (function checkChildNodeRemove() {\r\n    if (!hasDOM) {\r\n      return;\r\n    }\r\n    if (typeof Element.prototype.remove !== 'undefined') {\r\n      return;\r\n    }\r\n    Element.prototype.remove = function () {\r\n      if (this.parentNode) {\r\n        this.parentNode.removeChild(this);\r\n      }\r\n    };\r\n  })();\r\n  (function checkStringIncludes() {\r\n    if (String.prototype.includes) {\r\n      return;\r\n    }\r\n    __w_pdfjs_require__(62);\r\n  })();\r\n  (function checkArrayIncludes() {\r\n    if (Array.prototype.includes) {\r\n      return;\r\n    }\r\n    __w_pdfjs_require__(67);\r\n  })();\r\n  (function checkMathLog2() {\r\n    if (Math.log2) {\r\n      return;\r\n    }\r\n    Math.log2 = __w_pdfjs_require__(70);\r\n  })();\r\n  (function checkNumberIsNaN() {\r\n    if (Number.isNaN) {\r\n      return;\r\n    }\r\n    Number.isNaN = __w_pdfjs_require__(72);\r\n  })();\r\n  (function checkNumberIsInteger() {\r\n    if (Number.isInteger) {\r\n      return;\r\n    }\r\n    Number.isInteger = __w_pdfjs_require__(74);\r\n  })();\r\n  (function checkPromise() {\r\n    if (globalScope.Promise) {\r\n      return;\r\n    }\r\n    globalScope.Promise = __w_pdfjs_require__(77);\r\n  })();\r\n  (function checkWeakMap() {\r\n    if (globalScope.WeakMap) {\r\n      return;\r\n    }\r\n    globalScope.WeakMap = __w_pdfjs_require__(96);\r\n  })();\r\n  (function checkURLConstructor() {\r\n    var hasWorkingUrl = false;\r\n    try {\r\n      if (typeof URL === 'function' && _typeof(URL.prototype) === 'object' && 'origin' in URL.prototype) {\r\n        var u = new URL('b', 'http://a');\r\n        u.pathname = 'c%20d';\r\n        hasWorkingUrl = u.href === 'http://a/c%20d';\r\n      }\r\n    } catch (e) {}\r\n    if (hasWorkingUrl) {\r\n      return;\r\n    }\r\n    var relative = Object.create(null);\r\n    relative['ftp'] = 21;\r\n    relative['file'] = 0;\r\n    relative['gopher'] = 70;\r\n    relative['http'] = 80;\r\n    relative['https'] = 443;\r\n    relative['ws'] = 80;\r\n    relative['wss'] = 443;\r\n    var relativePathDotMapping = Object.create(null);\r\n    relativePathDotMapping['%2e'] = '.';\r\n    relativePathDotMapping['.%2e'] = '..';\r\n    relativePathDotMapping['%2e.'] = '..';\r\n    relativePathDotMapping['%2e%2e'] = '..';\r\n    function isRelativeScheme(scheme) {\r\n      return relative[scheme] !== undefined;\r\n    }\r\n    function invalid() {\r\n      clear.call(this);\r\n      this._isInvalid = true;\r\n    }\r\n    function IDNAToASCII(h) {\r\n      if (h === '') {\r\n        invalid.call(this);\r\n      }\r\n      return h.toLowerCase();\r\n    }\r\n    function percentEscape(c) {\r\n      var unicode = c.charCodeAt(0);\r\n      if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x3F, 0x60].indexOf(unicode) === -1) {\r\n        return c;\r\n      }\r\n      return encodeURIComponent(c);\r\n    }\r\n    function percentEscapeQuery(c) {\r\n      var unicode = c.charCodeAt(0);\r\n      if (unicode > 0x20 && unicode < 0x7F && [0x22, 0x23, 0x3C, 0x3E, 0x60].indexOf(unicode) === -1) {\r\n        return c;\r\n      }\r\n      return encodeURIComponent(c);\r\n    }\r\n    var EOF,\r\n        ALPHA = /[a-zA-Z]/,\r\n        ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\r\n    function parse(input, stateOverride, base) {\r\n      function err(message) {\r\n        errors.push(message);\r\n      }\r\n      var state = stateOverride || 'scheme start',\r\n          cursor = 0,\r\n          buffer = '',\r\n          seenAt = false,\r\n          seenBracket = false,\r\n          errors = [];\r\n      loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {\r\n        var c = input[cursor];\r\n        switch (state) {\r\n          case 'scheme start':\r\n            if (c && ALPHA.test(c)) {\r\n              buffer += c.toLowerCase();\r\n              state = 'scheme';\r\n            } else if (!stateOverride) {\r\n              buffer = '';\r\n              state = 'no scheme';\r\n              continue;\r\n            } else {\r\n              err('Invalid scheme.');\r\n              break loop;\r\n            }\r\n            break;\r\n          case 'scheme':\r\n            if (c && ALPHANUMERIC.test(c)) {\r\n              buffer += c.toLowerCase();\r\n            } else if (c === ':') {\r\n              this._scheme = buffer;\r\n              buffer = '';\r\n              if (stateOverride) {\r\n                break loop;\r\n              }\r\n              if (isRelativeScheme(this._scheme)) {\r\n                this._isRelative = true;\r\n              }\r\n              if (this._scheme === 'file') {\r\n                state = 'relative';\r\n              } else if (this._isRelative && base && base._scheme === this._scheme) {\r\n                state = 'relative or authority';\r\n              } else if (this._isRelative) {\r\n                state = 'authority first slash';\r\n              } else {\r\n                state = 'scheme data';\r\n              }\r\n            } else if (!stateOverride) {\r\n              buffer = '';\r\n              cursor = 0;\r\n              state = 'no scheme';\r\n              continue;\r\n            } else if (c === EOF) {\r\n              break loop;\r\n            } else {\r\n              err('Code point not allowed in scheme: ' + c);\r\n              break loop;\r\n            }\r\n            break;\r\n          case 'scheme data':\r\n            if (c === '?') {\r\n              this._query = '?';\r\n              state = 'query';\r\n            } else if (c === '#') {\r\n              this._fragment = '#';\r\n              state = 'fragment';\r\n            } else {\r\n              if (c !== EOF && c !== '\\t' && c !== '\\n' && c !== '\\r') {\r\n                this._schemeData += percentEscape(c);\r\n              }\r\n            }\r\n            break;\r\n          case 'no scheme':\r\n            if (!base || !isRelativeScheme(base._scheme)) {\r\n              err('Missing scheme.');\r\n              invalid.call(this);\r\n            } else {\r\n              state = 'relative';\r\n              continue;\r\n            }\r\n            break;\r\n          case 'relative or authority':\r\n            if (c === '/' && input[cursor + 1] === '/') {\r\n              state = 'authority ignore slashes';\r\n            } else {\r\n              err('Expected /, got: ' + c);\r\n              state = 'relative';\r\n              continue;\r\n            }\r\n            break;\r\n          case 'relative':\r\n            this._isRelative = true;\r\n            if (this._scheme !== 'file') {\r\n              this._scheme = base._scheme;\r\n            }\r\n            if (c === EOF) {\r\n              this._host = base._host;\r\n              this._port = base._port;\r\n              this._path = base._path.slice();\r\n              this._query = base._query;\r\n              this._username = base._username;\r\n              this._password = base._password;\r\n              break loop;\r\n            } else if (c === '/' || c === '\\\\') {\r\n              if (c === '\\\\') {\r\n                err('\\\\ is an invalid code point.');\r\n              }\r\n              state = 'relative slash';\r\n            } else if (c === '?') {\r\n              this._host = base._host;\r\n              this._port = base._port;\r\n              this._path = base._path.slice();\r\n              this._query = '?';\r\n              this._username = base._username;\r\n              this._password = base._password;\r\n              state = 'query';\r\n            } else if (c === '#') {\r\n              this._host = base._host;\r\n              this._port = base._port;\r\n              this._path = base._path.slice();\r\n              this._query = base._query;\r\n              this._fragment = '#';\r\n              this._username = base._username;\r\n              this._password = base._password;\r\n              state = 'fragment';\r\n            } else {\r\n              var nextC = input[cursor + 1];\r\n              var nextNextC = input[cursor + 2];\r\n              if (this._scheme !== 'file' || !ALPHA.test(c) || nextC !== ':' && nextC !== '|' || nextNextC !== EOF && nextNextC !== '/' && nextNextC !== '\\\\' && nextNextC !== '?' && nextNextC !== '#') {\r\n                this._host = base._host;\r\n                this._port = base._port;\r\n                this._username = base._username;\r\n                this._password = base._password;\r\n                this._path = base._path.slice();\r\n                this._path.pop();\r\n              }\r\n              state = 'relative path';\r\n              continue;\r\n            }\r\n            break;\r\n          case 'relative slash':\r\n            if (c === '/' || c === '\\\\') {\r\n              if (c === '\\\\') {\r\n                err('\\\\ is an invalid code point.');\r\n              }\r\n              if (this._scheme === 'file') {\r\n                state = 'file host';\r\n              } else {\r\n                state = 'authority ignore slashes';\r\n              }\r\n            } else {\r\n              if (this._scheme !== 'file') {\r\n                this._host = base._host;\r\n                this._port = base._port;\r\n                this._username = base._username;\r\n                this._password = base._password;\r\n              }\r\n              state = 'relative path';\r\n              continue;\r\n            }\r\n            break;\r\n          case 'authority first slash':\r\n            if (c === '/') {\r\n              state = 'authority second slash';\r\n            } else {\r\n              err('Expected \\'/\\', got: ' + c);\r\n              state = 'authority ignore slashes';\r\n              continue;\r\n            }\r\n            break;\r\n          case 'authority second slash':\r\n            state = 'authority ignore slashes';\r\n            if (c !== '/') {\r\n              err('Expected \\'/\\', got: ' + c);\r\n              continue;\r\n            }\r\n            break;\r\n          case 'authority ignore slashes':\r\n            if (c !== '/' && c !== '\\\\') {\r\n              state = 'authority';\r\n              continue;\r\n            } else {\r\n              err('Expected authority, got: ' + c);\r\n            }\r\n            break;\r\n          case 'authority':\r\n            if (c === '@') {\r\n              if (seenAt) {\r\n                err('@ already seen.');\r\n                buffer += '%40';\r\n              }\r\n              seenAt = true;\r\n              for (var i = 0; i < buffer.length; i++) {\r\n                var cp = buffer[i];\r\n                if (cp === '\\t' || cp === '\\n' || cp === '\\r') {\r\n                  err('Invalid whitespace in authority.');\r\n                  continue;\r\n                }\r\n                if (cp === ':' && this._password === null) {\r\n                  this._password = '';\r\n                  continue;\r\n                }\r\n                var tempC = percentEscape(cp);\r\n                if (this._password !== null) {\r\n                  this._password += tempC;\r\n                } else {\r\n                  this._username += tempC;\r\n                }\r\n              }\r\n              buffer = '';\r\n            } else if (c === EOF || c === '/' || c === '\\\\' || c === '?' || c === '#') {\r\n              cursor -= buffer.length;\r\n              buffer = '';\r\n              state = 'host';\r\n              continue;\r\n            } else {\r\n              buffer += c;\r\n            }\r\n            break;\r\n          case 'file host':\r\n            if (c === EOF || c === '/' || c === '\\\\' || c === '?' || c === '#') {\r\n              if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ':' || buffer[1] === '|')) {\r\n                state = 'relative path';\r\n              } else if (buffer.length === 0) {\r\n                state = 'relative path start';\r\n              } else {\r\n                this._host = IDNAToASCII.call(this, buffer);\r\n                buffer = '';\r\n                state = 'relative path start';\r\n              }\r\n              continue;\r\n            } else if (c === '\\t' || c === '\\n' || c === '\\r') {\r\n              err('Invalid whitespace in file host.');\r\n            } else {\r\n              buffer += c;\r\n            }\r\n            break;\r\n          case 'host':\r\n          case 'hostname':\r\n            if (c === ':' && !seenBracket) {\r\n              this._host = IDNAToASCII.call(this, buffer);\r\n              buffer = '';\r\n              state = 'port';\r\n              if (stateOverride === 'hostname') {\r\n                break loop;\r\n              }\r\n            } else if (c === EOF || c === '/' || c === '\\\\' || c === '?' || c === '#') {\r\n              this._host = IDNAToASCII.call(this, buffer);\r\n              buffer = '';\r\n              state = 'relative path start';\r\n              if (stateOverride) {\r\n                break loop;\r\n              }\r\n              continue;\r\n            } else if (c !== '\\t' && c !== '\\n' && c !== '\\r') {\r\n              if (c === '[') {\r\n                seenBracket = true;\r\n              } else if (c === ']') {\r\n                seenBracket = false;\r\n              }\r\n              buffer += c;\r\n            } else {\r\n              err('Invalid code point in host/hostname: ' + c);\r\n            }\r\n            break;\r\n          case 'port':\r\n            if (/[0-9]/.test(c)) {\r\n              buffer += c;\r\n            } else if (c === EOF || c === '/' || c === '\\\\' || c === '?' || c === '#' || stateOverride) {\r\n              if (buffer !== '') {\r\n                var temp = parseInt(buffer, 10);\r\n                if (temp !== relative[this._scheme]) {\r\n                  this._port = temp + '';\r\n                }\r\n                buffer = '';\r\n              }\r\n              if (stateOverride) {\r\n                break loop;\r\n              }\r\n              state = 'relative path start';\r\n              continue;\r\n            } else if (c === '\\t' || c === '\\n' || c === '\\r') {\r\n              err('Invalid code point in port: ' + c);\r\n            } else {\r\n              invalid.call(this);\r\n            }\r\n            break;\r\n          case 'relative path start':\r\n            if (c === '\\\\') {\r\n              err('\\'\\\\\\' not allowed in path.');\r\n            }\r\n            state = 'relative path';\r\n            if (c !== '/' && c !== '\\\\') {\r\n              continue;\r\n            }\r\n            break;\r\n          case 'relative path':\r\n            if (c === EOF || c === '/' || c === '\\\\' || !stateOverride && (c === '?' || c === '#')) {\r\n              if (c === '\\\\') {\r\n                err('\\\\ not allowed in relative path.');\r\n              }\r\n              var tmp;\r\n              if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\r\n                buffer = tmp;\r\n              }\r\n              if (buffer === '..') {\r\n                this._path.pop();\r\n                if (c !== '/' && c !== '\\\\') {\r\n                  this._path.push('');\r\n                }\r\n              } else if (buffer === '.' && c !== '/' && c !== '\\\\') {\r\n                this._path.push('');\r\n              } else if (buffer !== '.') {\r\n                if (this._scheme === 'file' && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === '|') {\r\n                  buffer = buffer[0] + ':';\r\n                }\r\n                this._path.push(buffer);\r\n              }\r\n              buffer = '';\r\n              if (c === '?') {\r\n                this._query = '?';\r\n                state = 'query';\r\n              } else if (c === '#') {\r\n                this._fragment = '#';\r\n                state = 'fragment';\r\n              }\r\n            } else if (c !== '\\t' && c !== '\\n' && c !== '\\r') {\r\n              buffer += percentEscape(c);\r\n            }\r\n            break;\r\n          case 'query':\r\n            if (!stateOverride && c === '#') {\r\n              this._fragment = '#';\r\n              state = 'fragment';\r\n            } else if (c !== EOF && c !== '\\t' && c !== '\\n' && c !== '\\r') {\r\n              this._query += percentEscapeQuery(c);\r\n            }\r\n            break;\r\n          case 'fragment':\r\n            if (c !== EOF && c !== '\\t' && c !== '\\n' && c !== '\\r') {\r\n              this._fragment += c;\r\n            }\r\n            break;\r\n        }\r\n        cursor++;\r\n      }\r\n    }\r\n    function clear() {\r\n      this._scheme = '';\r\n      this._schemeData = '';\r\n      this._username = '';\r\n      this._password = null;\r\n      this._host = '';\r\n      this._port = '';\r\n      this._path = [];\r\n      this._query = '';\r\n      this._fragment = '';\r\n      this._isInvalid = false;\r\n      this._isRelative = false;\r\n    }\r\n    function JURL(url, base) {\r\n      if (base !== undefined && !(base instanceof JURL)) {\r\n        base = new JURL(String(base));\r\n      }\r\n      this._url = url;\r\n      clear.call(this);\r\n      var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, '');\r\n      parse.call(this, input, null, base);\r\n    }\r\n    JURL.prototype = {\r\n      toString: function toString() {\r\n        return this.href;\r\n      },\r\n\r\n      get href() {\r\n        if (this._isInvalid) {\r\n          return this._url;\r\n        }\r\n        var authority = '';\r\n        if (this._username !== '' || this._password !== null) {\r\n          authority = this._username + (this._password !== null ? ':' + this._password : '') + '@';\r\n        }\r\n        return this.protocol + (this._isRelative ? '//' + authority + this.host : '') + this.pathname + this._query + this._fragment;\r\n      },\r\n      set href(value) {\r\n        clear.call(this);\r\n        parse.call(this, value);\r\n      },\r\n      get protocol() {\r\n        return this._scheme + ':';\r\n      },\r\n      set protocol(value) {\r\n        if (this._isInvalid) {\r\n          return;\r\n        }\r\n        parse.call(this, value + ':', 'scheme start');\r\n      },\r\n      get host() {\r\n        return this._isInvalid ? '' : this._port ? this._host + ':' + this._port : this._host;\r\n      },\r\n      set host(value) {\r\n        if (this._isInvalid || !this._isRelative) {\r\n          return;\r\n        }\r\n        parse.call(this, value, 'host');\r\n      },\r\n      get hostname() {\r\n        return this._host;\r\n      },\r\n      set hostname(value) {\r\n        if (this._isInvalid || !this._isRelative) {\r\n          return;\r\n        }\r\n        parse.call(this, value, 'hostname');\r\n      },\r\n      get port() {\r\n        return this._port;\r\n      },\r\n      set port(value) {\r\n        if (this._isInvalid || !this._isRelative) {\r\n          return;\r\n        }\r\n        parse.call(this, value, 'port');\r\n      },\r\n      get pathname() {\r\n        return this._isInvalid ? '' : this._isRelative ? '/' + this._path.join('/') : this._schemeData;\r\n      },\r\n      set pathname(value) {\r\n        if (this._isInvalid || !this._isRelative) {\r\n          return;\r\n        }\r\n        this._path = [];\r\n        parse.call(this, value, 'relative path start');\r\n      },\r\n      get search() {\r\n        return this._isInvalid || !this._query || this._query === '?' ? '' : this._query;\r\n      },\r\n      set search(value) {\r\n        if (this._isInvalid || !this._isRelative) {\r\n          return;\r\n        }\r\n        this._query = '?';\r\n        if (value[0] === '?') {\r\n          value = value.slice(1);\r\n        }\r\n        parse.call(this, value, 'query');\r\n      },\r\n      get hash() {\r\n        return this._isInvalid || !this._fragment || this._fragment === '#' ? '' : this._fragment;\r\n      },\r\n      set hash(value) {\r\n        if (this._isInvalid) {\r\n          return;\r\n        }\r\n        this._fragment = '#';\r\n        if (value[0] === '#') {\r\n          value = value.slice(1);\r\n        }\r\n        parse.call(this, value, 'fragment');\r\n      },\r\n      get origin() {\r\n        var host;\r\n        if (this._isInvalid || !this._scheme) {\r\n          return '';\r\n        }\r\n        switch (this._scheme) {\r\n          case 'data':\r\n          case 'file':\r\n          case 'javascript':\r\n          case 'mailto':\r\n            return 'null';\r\n          case 'blob':\r\n            try {\r\n              return new JURL(this._schemeData).origin || 'null';\r\n            } catch (_) {}\r\n            return 'null';\r\n        }\r\n        host = this.host;\r\n        if (!host) {\r\n          return '';\r\n        }\r\n        return this._scheme + '://' + host;\r\n      }\r\n    };\r\n    var OriginalURL = globalScope.URL;\r\n    if (OriginalURL) {\r\n      JURL.createObjectURL = function (blob) {\r\n        return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\r\n      };\r\n      JURL.revokeObjectURL = function (url) {\r\n        OriginalURL.revokeObjectURL(url);\r\n      };\r\n    }\r\n    globalScope.URL = JURL;\r\n  })();\r\n  (function checkObjectValues() {\r\n    if (Object.values) {\r\n      return;\r\n    }\r\n    Object.values = __w_pdfjs_require__(112);\r\n  })();\r\n}\r\n\r\n/***/ }),\r\n/* 62 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(63);\r\nmodule.exports = __w_pdfjs_require__(5).String.includes;\r\n\r\n/***/ }),\r\n/* 63 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\nvar context = __w_pdfjs_require__(64);\r\nvar INCLUDES = 'includes';\r\n$export($export.P + $export.F * __w_pdfjs_require__(66)(INCLUDES), 'String', {\r\n  includes: function includes(searchString) {\r\n    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 64 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isRegExp = __w_pdfjs_require__(65);\r\nvar defined = __w_pdfjs_require__(20);\r\nmodule.exports = function (that, searchString, NAME) {\r\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\r\n  return String(defined(that));\r\n};\r\n\r\n/***/ }),\r\n/* 65 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar cof = __w_pdfjs_require__(13);\r\nvar MATCH = __w_pdfjs_require__(1)('match');\r\nmodule.exports = function (it) {\r\n  var isRegExp;\r\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\r\n};\r\n\r\n/***/ }),\r\n/* 66 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar MATCH = __w_pdfjs_require__(1)('match');\r\nmodule.exports = function (KEY) {\r\n  var re = /./;\r\n  try {\r\n    '/./'[KEY](re);\r\n  } catch (e) {\r\n    try {\r\n      re[MATCH] = false;\r\n      return !'/./'[KEY](re);\r\n    } catch (f) {}\r\n  }\r\n  return true;\r\n};\r\n\r\n/***/ }),\r\n/* 67 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(68);\r\nmodule.exports = __w_pdfjs_require__(5).Array.includes;\r\n\r\n/***/ }),\r\n/* 68 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\nvar $includes = __w_pdfjs_require__(43)(true);\r\n$export($export.P, 'Array', {\r\n  includes: function includes(el) {\r\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\r\n  }\r\n});\r\n__w_pdfjs_require__(44)('includes');\r\n\r\n/***/ }),\r\n/* 69 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar toInteger = __w_pdfjs_require__(30);\r\nvar max = Math.max;\r\nvar min = Math.min;\r\nmodule.exports = function (index, length) {\r\n  index = toInteger(index);\r\n  return index < 0 ? max(index + length, 0) : min(index, length);\r\n};\r\n\r\n/***/ }),\r\n/* 70 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(71);\r\nmodule.exports = __w_pdfjs_require__(5).Math.log2;\r\n\r\n/***/ }),\r\n/* 71 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\n$export($export.S, 'Math', {\r\n  log2: function log2(x) {\r\n    return Math.log(x) / Math.LN2;\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 72 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(73);\r\nmodule.exports = __w_pdfjs_require__(5).Number.isNaN;\r\n\r\n/***/ }),\r\n/* 73 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\n$export($export.S, 'Number', {\r\n  isNaN: function isNaN(number) {\r\n    return number != number;\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 74 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(75);\r\nmodule.exports = __w_pdfjs_require__(5).Number.isInteger;\r\n\r\n/***/ }),\r\n/* 75 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\n$export($export.S, 'Number', { isInteger: __w_pdfjs_require__(76) });\r\n\r\n/***/ }),\r\n/* 76 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar floor = Math.floor;\r\nmodule.exports = function isInteger(it) {\r\n  return !isObject(it) && isFinite(it) && floor(it) === it;\r\n};\r\n\r\n/***/ }),\r\n/* 77 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(45);\r\n__w_pdfjs_require__(78);\r\n__w_pdfjs_require__(50);\r\n__w_pdfjs_require__(87);\r\n__w_pdfjs_require__(94);\r\n__w_pdfjs_require__(95);\r\nmodule.exports = __w_pdfjs_require__(5).Promise;\r\n\r\n/***/ }),\r\n/* 78 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $at = __w_pdfjs_require__(79)(true);\r\n__w_pdfjs_require__(46)(String, 'String', function (iterated) {\r\n  this._t = String(iterated);\r\n  this._i = 0;\r\n}, function () {\r\n  var O = this._t;\r\n  var index = this._i;\r\n  var point;\r\n  if (index >= O.length) return {\r\n    value: undefined,\r\n    done: true\r\n  };\r\n  point = $at(O, index);\r\n  this._i += point.length;\r\n  return {\r\n    value: point,\r\n    done: false\r\n  };\r\n});\r\n\r\n/***/ }),\r\n/* 79 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar toInteger = __w_pdfjs_require__(30);\r\nvar defined = __w_pdfjs_require__(20);\r\nmodule.exports = function (TO_STRING) {\r\n  return function (that, pos) {\r\n    var s = String(defined(that));\r\n    var i = toInteger(pos);\r\n    var l = s.length;\r\n    var a, b;\r\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\r\n    a = s.charCodeAt(i);\r\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 80 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar create = __w_pdfjs_require__(81);\r\nvar descriptor = __w_pdfjs_require__(27);\r\nvar setToStringTag = __w_pdfjs_require__(22);\r\nvar IteratorPrototype = {};\r\n__w_pdfjs_require__(10)(IteratorPrototype, __w_pdfjs_require__(1)('iterator'), function () {\r\n  return this;\r\n});\r\nmodule.exports = function (Constructor, NAME, next) {\r\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\r\n  setToStringTag(Constructor, NAME + ' Iterator');\r\n};\r\n\r\n/***/ }),\r\n/* 81 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar dPs = __w_pdfjs_require__(82);\r\nvar enumBugKeys = __w_pdfjs_require__(48);\r\nvar IE_PROTO = __w_pdfjs_require__(32)('IE_PROTO');\r\nvar Empty = function Empty() {};\r\nvar PROTOTYPE = 'prototype';\r\nvar _createDict = function createDict() {\r\n  var iframe = __w_pdfjs_require__(26)('iframe');\r\n  var i = enumBugKeys.length;\r\n  var lt = '<';\r\n  var gt = '>';\r\n  var iframeDocument;\r\n  iframe.style.display = 'none';\r\n  __w_pdfjs_require__(49).appendChild(iframe);\r\n  iframe.src = 'javascript:';\r\n  iframeDocument = iframe.contentWindow.document;\r\n  iframeDocument.open();\r\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\r\n  iframeDocument.close();\r\n  _createDict = iframeDocument.F;\r\n  while (i--) {\r\n    delete _createDict[PROTOTYPE][enumBugKeys[i]];\r\n  }return _createDict();\r\n};\r\nmodule.exports = Object.create || function create(O, Properties) {\r\n  var result;\r\n  if (O !== null) {\r\n    Empty[PROTOTYPE] = anObject(O);\r\n    result = new Empty();\r\n    Empty[PROTOTYPE] = null;\r\n    result[IE_PROTO] = O;\r\n  } else result = _createDict();\r\n  return Properties === undefined ? result : dPs(result, Properties);\r\n};\r\n\r\n/***/ }),\r\n/* 82 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar dP = __w_pdfjs_require__(14);\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar getKeys = __w_pdfjs_require__(21);\r\nmodule.exports = __w_pdfjs_require__(11) ? Object.defineProperties : function defineProperties(O, Properties) {\r\n  anObject(O);\r\n  var keys = getKeys(Properties);\r\n  var length = keys.length;\r\n  var i = 0;\r\n  var P;\r\n  while (length > i) {\r\n    dP.f(O, P = keys[i++], Properties[P]);\r\n  }return O;\r\n};\r\n\r\n/***/ }),\r\n/* 83 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar has = __w_pdfjs_require__(8);\r\nvar toIObject = __w_pdfjs_require__(16);\r\nvar arrayIndexOf = __w_pdfjs_require__(43)(false);\r\nvar IE_PROTO = __w_pdfjs_require__(32)('IE_PROTO');\r\nmodule.exports = function (object, names) {\r\n  var O = toIObject(object);\r\n  var i = 0;\r\n  var result = [];\r\n  var key;\r\n  for (key in O) {\r\n    if (key != IE_PROTO) has(O, key) && result.push(key);\r\n  }while (names.length > i) {\r\n    if (has(O, key = names[i++])) {\r\n      ~arrayIndexOf(result, key) || result.push(key);\r\n    }\r\n  }return result;\r\n};\r\n\r\n/***/ }),\r\n/* 84 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar has = __w_pdfjs_require__(8);\r\nvar toObject = __w_pdfjs_require__(33);\r\nvar IE_PROTO = __w_pdfjs_require__(32)('IE_PROTO');\r\nvar ObjectProto = Object.prototype;\r\nmodule.exports = Object.getPrototypeOf || function (O) {\r\n  O = toObject(O);\r\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\r\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\r\n    return O.constructor.prototype;\r\n  }\r\n  return O instanceof Object ? ObjectProto : null;\r\n};\r\n\r\n/***/ }),\r\n/* 85 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar addToUnscopables = __w_pdfjs_require__(44);\r\nvar step = __w_pdfjs_require__(86);\r\nvar Iterators = __w_pdfjs_require__(17);\r\nvar toIObject = __w_pdfjs_require__(16);\r\nmodule.exports = __w_pdfjs_require__(46)(Array, 'Array', function (iterated, kind) {\r\n  this._t = toIObject(iterated);\r\n  this._i = 0;\r\n  this._k = kind;\r\n}, function () {\r\n  var O = this._t;\r\n  var kind = this._k;\r\n  var index = this._i++;\r\n  if (!O || index >= O.length) {\r\n    this._t = undefined;\r\n    return step(1);\r\n  }\r\n  if (kind == 'keys') return step(0, index);\r\n  if (kind == 'values') return step(0, O[index]);\r\n  return step(0, [index, O[index]]);\r\n}, 'values');\r\nIterators.Arguments = Iterators.Array;\r\naddToUnscopables('keys');\r\naddToUnscopables('values');\r\naddToUnscopables('entries');\r\n\r\n/***/ }),\r\n/* 86 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (done, value) {\r\n  return {\r\n    value: value,\r\n    done: !!done\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 87 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar LIBRARY = __w_pdfjs_require__(47);\r\nvar global = __w_pdfjs_require__(4);\r\nvar ctx = __w_pdfjs_require__(9);\r\nvar classof = __w_pdfjs_require__(31);\r\nvar $export = __w_pdfjs_require__(3);\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar aFunction = __w_pdfjs_require__(15);\r\nvar anInstance = __w_pdfjs_require__(34);\r\nvar forOf = __w_pdfjs_require__(23);\r\nvar speciesConstructor = __w_pdfjs_require__(51);\r\nvar task = __w_pdfjs_require__(52).set;\r\nvar microtask = __w_pdfjs_require__(92)();\r\nvar newPromiseCapabilityModule = __w_pdfjs_require__(35);\r\nvar perform = __w_pdfjs_require__(53);\r\nvar promiseResolve = __w_pdfjs_require__(54);\r\nvar PROMISE = 'Promise';\r\nvar TypeError = global.TypeError;\r\nvar process = global.process;\r\nvar $Promise = global[PROMISE];\r\nvar isNode = classof(process) == 'process';\r\nvar empty = function empty() {};\r\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\r\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\r\nvar USE_NATIVE = !!function () {\r\n  try {\r\n    var promise = $Promise.resolve(1);\r\n    var FakePromise = (promise.constructor = {})[__w_pdfjs_require__(1)('species')] = function (exec) {\r\n      exec(empty, empty);\r\n    };\r\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\r\n  } catch (e) {}\r\n}();\r\nvar isThenable = function isThenable(it) {\r\n  var then;\r\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\r\n};\r\nvar notify = function notify(promise, isReject) {\r\n  if (promise._n) return;\r\n  promise._n = true;\r\n  var chain = promise._c;\r\n  microtask(function () {\r\n    var value = promise._v;\r\n    var ok = promise._s == 1;\r\n    var i = 0;\r\n    var run = function run(reaction) {\r\n      var handler = ok ? reaction.ok : reaction.fail;\r\n      var resolve = reaction.resolve;\r\n      var reject = reaction.reject;\r\n      var domain = reaction.domain;\r\n      var result, then, exited;\r\n      try {\r\n        if (handler) {\r\n          if (!ok) {\r\n            if (promise._h == 2) onHandleUnhandled(promise);\r\n            promise._h = 1;\r\n          }\r\n          if (handler === true) result = value;else {\r\n            if (domain) domain.enter();\r\n            result = handler(value);\r\n            if (domain) {\r\n              domain.exit();\r\n              exited = true;\r\n            }\r\n          }\r\n          if (result === reaction.promise) {\r\n            reject(TypeError('Promise-chain cycle'));\r\n          } else if (then = isThenable(result)) {\r\n            then.call(result, resolve, reject);\r\n          } else resolve(result);\r\n        } else reject(value);\r\n      } catch (e) {\r\n        if (domain && !exited) domain.exit();\r\n        reject(e);\r\n      }\r\n    };\r\n    while (chain.length > i) {\r\n      run(chain[i++]);\r\n    }promise._c = [];\r\n    promise._n = false;\r\n    if (isReject && !promise._h) onUnhandled(promise);\r\n  });\r\n};\r\nvar onUnhandled = function onUnhandled(promise) {\r\n  task.call(global, function () {\r\n    var value = promise._v;\r\n    var unhandled = isUnhandled(promise);\r\n    var result, handler, console;\r\n    if (unhandled) {\r\n      result = perform(function () {\r\n        if (isNode) {\r\n          process.emit('unhandledRejection', value, promise);\r\n        } else if (handler = global.onunhandledrejection) {\r\n          handler({\r\n            promise: promise,\r\n            reason: value\r\n          });\r\n        } else if ((console = global.console) && console.error) {\r\n          console.error('Unhandled promise rejection', value);\r\n        }\r\n      });\r\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\r\n    }\r\n    promise._a = undefined;\r\n    if (unhandled && result.e) throw result.v;\r\n  });\r\n};\r\nvar isUnhandled = function isUnhandled(promise) {\r\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\r\n};\r\nvar onHandleUnhandled = function onHandleUnhandled(promise) {\r\n  task.call(global, function () {\r\n    var handler;\r\n    if (isNode) {\r\n      process.emit('rejectionHandled', promise);\r\n    } else if (handler = global.onrejectionhandled) {\r\n      handler({\r\n        promise: promise,\r\n        reason: promise._v\r\n      });\r\n    }\r\n  });\r\n};\r\nvar $reject = function $reject(value) {\r\n  var promise = this;\r\n  if (promise._d) return;\r\n  promise._d = true;\r\n  promise = promise._w || promise;\r\n  promise._v = value;\r\n  promise._s = 2;\r\n  if (!promise._a) promise._a = promise._c.slice();\r\n  notify(promise, true);\r\n};\r\nvar $resolve = function $resolve(value) {\r\n  var promise = this;\r\n  var then;\r\n  if (promise._d) return;\r\n  promise._d = true;\r\n  promise = promise._w || promise;\r\n  try {\r\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\r\n    if (then = isThenable(value)) {\r\n      microtask(function () {\r\n        var wrapper = {\r\n          _w: promise,\r\n          _d: false\r\n        };\r\n        try {\r\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\r\n        } catch (e) {\r\n          $reject.call(wrapper, e);\r\n        }\r\n      });\r\n    } else {\r\n      promise._v = value;\r\n      promise._s = 1;\r\n      notify(promise, false);\r\n    }\r\n  } catch (e) {\r\n    $reject.call({\r\n      _w: promise,\r\n      _d: false\r\n    }, e);\r\n  }\r\n};\r\nif (!USE_NATIVE) {\r\n  $Promise = function Promise(executor) {\r\n    anInstance(this, $Promise, PROMISE, '_h');\r\n    aFunction(executor);\r\n    Internal.call(this);\r\n    try {\r\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\r\n    } catch (err) {\r\n      $reject.call(this, err);\r\n    }\r\n  };\r\n  Internal = function Promise(executor) {\r\n    this._c = [];\r\n    this._a = undefined;\r\n    this._s = 0;\r\n    this._d = false;\r\n    this._v = undefined;\r\n    this._h = 0;\r\n    this._n = false;\r\n  };\r\n  Internal.prototype = __w_pdfjs_require__(36)($Promise.prototype, {\r\n    then: function then(onFulfilled, onRejected) {\r\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\r\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\r\n      reaction.fail = typeof onRejected == 'function' && onRejected;\r\n      reaction.domain = isNode ? process.domain : undefined;\r\n      this._c.push(reaction);\r\n      if (this._a) this._a.push(reaction);\r\n      if (this._s) notify(this, false);\r\n      return reaction.promise;\r\n    },\r\n    'catch': function _catch(onRejected) {\r\n      return this.then(undefined, onRejected);\r\n    }\r\n  });\r\n  OwnPromiseCapability = function OwnPromiseCapability() {\r\n    var promise = new Internal();\r\n    this.promise = promise;\r\n    this.resolve = ctx($resolve, promise, 1);\r\n    this.reject = ctx($reject, promise, 1);\r\n  };\r\n  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {\r\n    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\r\n  };\r\n}\r\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\r\n__w_pdfjs_require__(22)($Promise, PROMISE);\r\n__w_pdfjs_require__(93)(PROMISE);\r\nWrapper = __w_pdfjs_require__(5)[PROMISE];\r\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\r\n  reject: function reject(r) {\r\n    var capability = newPromiseCapability(this);\r\n    var $$reject = capability.reject;\r\n    $$reject(r);\r\n    return capability.promise;\r\n  }\r\n});\r\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\r\n  resolve: function resolve(x) {\r\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\r\n  }\r\n});\r\n$export($export.S + $export.F * !(USE_NATIVE && __w_pdfjs_require__(55)(function (iter) {\r\n  $Promise.all(iter)['catch'](empty);\r\n})), PROMISE, {\r\n  all: function all(iterable) {\r\n    var C = this;\r\n    var capability = newPromiseCapability(C);\r\n    var resolve = capability.resolve;\r\n    var reject = capability.reject;\r\n    var result = perform(function () {\r\n      var values = [];\r\n      var index = 0;\r\n      var remaining = 1;\r\n      forOf(iterable, false, function (promise) {\r\n        var $index = index++;\r\n        var alreadyCalled = false;\r\n        values.push(undefined);\r\n        remaining++;\r\n        C.resolve(promise).then(function (value) {\r\n          if (alreadyCalled) return;\r\n          alreadyCalled = true;\r\n          values[$index] = value;\r\n          --remaining || resolve(values);\r\n        }, reject);\r\n      });\r\n      --remaining || resolve(values);\r\n    });\r\n    if (result.e) reject(result.v);\r\n    return capability.promise;\r\n  },\r\n  race: function race(iterable) {\r\n    var C = this;\r\n    var capability = newPromiseCapability(C);\r\n    var reject = capability.reject;\r\n    var result = perform(function () {\r\n      forOf(iterable, false, function (promise) {\r\n        C.resolve(promise).then(capability.resolve, reject);\r\n      });\r\n    });\r\n    if (result.e) reject(result.v);\r\n    return capability.promise;\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 88 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar anObject = __w_pdfjs_require__(6);\r\nmodule.exports = function (iterator, fn, value, entries) {\r\n  try {\r\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\r\n  } catch (e) {\r\n    var ret = iterator['return'];\r\n    if (ret !== undefined) anObject(ret.call(iterator));\r\n    throw e;\r\n  }\r\n};\r\n\r\n/***/ }),\r\n/* 89 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar Iterators = __w_pdfjs_require__(17);\r\nvar ITERATOR = __w_pdfjs_require__(1)('iterator');\r\nvar ArrayProto = Array.prototype;\r\nmodule.exports = function (it) {\r\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\r\n};\r\n\r\n/***/ }),\r\n/* 90 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar classof = __w_pdfjs_require__(31);\r\nvar ITERATOR = __w_pdfjs_require__(1)('iterator');\r\nvar Iterators = __w_pdfjs_require__(17);\r\nmodule.exports = __w_pdfjs_require__(5).getIteratorMethod = function (it) {\r\n  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];\r\n};\r\n\r\n/***/ }),\r\n/* 91 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nmodule.exports = function (fn, args, that) {\r\n  var un = that === undefined;\r\n  switch (args.length) {\r\n    case 0:\r\n      return un ? fn() : fn.call(that);\r\n    case 1:\r\n      return un ? fn(args[0]) : fn.call(that, args[0]);\r\n    case 2:\r\n      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);\r\n    case 3:\r\n      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);\r\n    case 4:\r\n      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);\r\n  }\r\n  return fn.apply(that, args);\r\n};\r\n\r\n/***/ }),\r\n/* 92 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar global = __w_pdfjs_require__(4);\r\nvar macrotask = __w_pdfjs_require__(52).set;\r\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\r\nvar process = global.process;\r\nvar Promise = global.Promise;\r\nvar isNode = __w_pdfjs_require__(13)(process) == 'process';\r\nmodule.exports = function () {\r\n  var head, last, notify;\r\n  var flush = function flush() {\r\n    var parent, fn;\r\n    if (isNode && (parent = process.domain)) parent.exit();\r\n    while (head) {\r\n      fn = head.fn;\r\n      head = head.next;\r\n      try {\r\n        fn();\r\n      } catch (e) {\r\n        if (head) notify();else last = undefined;\r\n        throw e;\r\n      }\r\n    }\r\n    last = undefined;\r\n    if (parent) parent.enter();\r\n  };\r\n  if (isNode) {\r\n    notify = function notify() {\r\n      process.nextTick(flush);\r\n    };\r\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\r\n    var toggle = true;\r\n    var node = document.createTextNode('');\r\n    new Observer(flush).observe(node, { characterData: true });\r\n    notify = function notify() {\r\n      node.data = toggle = !toggle;\r\n    };\r\n  } else if (Promise && Promise.resolve) {\r\n    var promise = Promise.resolve();\r\n    notify = function notify() {\r\n      promise.then(flush);\r\n    };\r\n  } else {\r\n    notify = function notify() {\r\n      macrotask.call(global, flush);\r\n    };\r\n  }\r\n  return function (fn) {\r\n    var task = {\r\n      fn: fn,\r\n      next: undefined\r\n    };\r\n    if (last) last.next = task;\r\n    if (!head) {\r\n      head = task;\r\n      notify();\r\n    }\r\n    last = task;\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 93 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar global = __w_pdfjs_require__(4);\r\nvar dP = __w_pdfjs_require__(14);\r\nvar DESCRIPTORS = __w_pdfjs_require__(11);\r\nvar SPECIES = __w_pdfjs_require__(1)('species');\r\nmodule.exports = function (KEY) {\r\n  var C = global[KEY];\r\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\r\n    configurable: true,\r\n    get: function get() {\r\n      return this;\r\n    }\r\n  });\r\n};\r\n\r\n/***/ }),\r\n/* 94 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\nvar core = __w_pdfjs_require__(5);\r\nvar global = __w_pdfjs_require__(4);\r\nvar speciesConstructor = __w_pdfjs_require__(51);\r\nvar promiseResolve = __w_pdfjs_require__(54);\r\n$export($export.P + $export.R, 'Promise', {\r\n  'finally': function _finally(onFinally) {\r\n    var C = speciesConstructor(this, core.Promise || global.Promise);\r\n    var isFunction = typeof onFinally == 'function';\r\n    return this.then(isFunction ? function (x) {\r\n      return promiseResolve(C, onFinally()).then(function () {\r\n        return x;\r\n      });\r\n    } : onFinally, isFunction ? function (e) {\r\n      return promiseResolve(C, onFinally()).then(function () {\r\n        throw e;\r\n      });\r\n    } : onFinally);\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 95 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\nvar newPromiseCapability = __w_pdfjs_require__(35);\r\nvar perform = __w_pdfjs_require__(53);\r\n$export($export.S, 'Promise', {\r\n  'try': function _try(callbackfn) {\r\n    var promiseCapability = newPromiseCapability.f(this);\r\n    var result = perform(callbackfn);\r\n    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\r\n    return promiseCapability.promise;\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 96 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(45);\r\n__w_pdfjs_require__(50);\r\n__w_pdfjs_require__(97);\r\n__w_pdfjs_require__(108);\r\n__w_pdfjs_require__(110);\r\nmodule.exports = __w_pdfjs_require__(5).WeakMap;\r\n\r\n/***/ }),\r\n/* 97 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar each = __w_pdfjs_require__(56)(0);\r\nvar redefine = __w_pdfjs_require__(7);\r\nvar meta = __w_pdfjs_require__(37);\r\nvar assign = __w_pdfjs_require__(101);\r\nvar weak = __w_pdfjs_require__(103);\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar fails = __w_pdfjs_require__(12);\r\nvar validate = __w_pdfjs_require__(57);\r\nvar WEAK_MAP = 'WeakMap';\r\nvar getWeak = meta.getWeak;\r\nvar isExtensible = Object.isExtensible;\r\nvar uncaughtFrozenStore = weak.ufstore;\r\nvar tmp = {};\r\nvar InternalMap;\r\nvar wrapper = function wrapper(get) {\r\n  return function WeakMap() {\r\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\r\n  };\r\n};\r\nvar methods = {\r\n  get: function get(key) {\r\n    if (isObject(key)) {\r\n      var data = getWeak(key);\r\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\r\n      return data ? data[this._i] : undefined;\r\n    }\r\n  },\r\n  set: function set(key, value) {\r\n    return weak.def(validate(this, WEAK_MAP), key, value);\r\n  }\r\n};\r\nvar $WeakMap = module.exports = __w_pdfjs_require__(104)(WEAK_MAP, wrapper, methods, weak, true, true);\r\nif (fails(function () {\r\n  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;\r\n})) {\r\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\r\n  assign(InternalMap.prototype, methods);\r\n  meta.NEED = true;\r\n  each(['delete', 'has', 'get', 'set'], function (key) {\r\n    var proto = $WeakMap.prototype;\r\n    var method = proto[key];\r\n    redefine(proto, key, function (a, b) {\r\n      if (isObject(a) && !isExtensible(a)) {\r\n        if (!this._f) this._f = new InternalMap();\r\n        var result = this._f[key](a, b);\r\n        return key == 'set' ? this : result;\r\n      }\r\n      return method.call(this, a, b);\r\n    });\r\n  });\r\n}\r\n\r\n/***/ }),\r\n/* 98 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar speciesConstructor = __w_pdfjs_require__(99);\r\nmodule.exports = function (original, length) {\r\n  return new (speciesConstructor(original))(length);\r\n};\r\n\r\n/***/ }),\r\n/* 99 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar isArray = __w_pdfjs_require__(100);\r\nvar SPECIES = __w_pdfjs_require__(1)('species');\r\nmodule.exports = function (original) {\r\n  var C;\r\n  if (isArray(original)) {\r\n    C = original.constructor;\r\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\r\n    if (isObject(C)) {\r\n      C = C[SPECIES];\r\n      if (C === null) C = undefined;\r\n    }\r\n  }\r\n  return C === undefined ? Array : C;\r\n};\r\n\r\n/***/ }),\r\n/* 100 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar cof = __w_pdfjs_require__(13);\r\nmodule.exports = Array.isArray || function isArray(arg) {\r\n  return cof(arg) == 'Array';\r\n};\r\n\r\n/***/ }),\r\n/* 101 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar getKeys = __w_pdfjs_require__(21);\r\nvar gOPS = __w_pdfjs_require__(102);\r\nvar pIE = __w_pdfjs_require__(38);\r\nvar toObject = __w_pdfjs_require__(33);\r\nvar IObject = __w_pdfjs_require__(28);\r\nvar $assign = Object.assign;\r\nmodule.exports = !$assign || __w_pdfjs_require__(12)(function () {\r\n  var A = {};\r\n  var B = {};\r\n  var S = Symbol();\r\n  var K = 'abcdefghijklmnopqrst';\r\n  A[S] = 7;\r\n  K.split('').forEach(function (k) {\r\n    B[k] = k;\r\n  });\r\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\r\n}) ? function assign(target, source) {\r\n  var T = toObject(target);\r\n  var aLen = arguments.length;\r\n  var index = 1;\r\n  var getSymbols = gOPS.f;\r\n  var isEnum = pIE.f;\r\n  while (aLen > index) {\r\n    var S = IObject(arguments[index++]);\r\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\r\n    var length = keys.length;\r\n    var j = 0;\r\n    var key;\r\n    while (length > j) {\r\n      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\r\n    }\r\n  }\r\n  return T;\r\n} : $assign;\r\n\r\n/***/ }),\r\n/* 102 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nexports.f = Object.getOwnPropertySymbols;\r\n\r\n/***/ }),\r\n/* 103 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar redefineAll = __w_pdfjs_require__(36);\r\nvar getWeak = __w_pdfjs_require__(37).getWeak;\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar anInstance = __w_pdfjs_require__(34);\r\nvar forOf = __w_pdfjs_require__(23);\r\nvar createArrayMethod = __w_pdfjs_require__(56);\r\nvar $has = __w_pdfjs_require__(8);\r\nvar validate = __w_pdfjs_require__(57);\r\nvar arrayFind = createArrayMethod(5);\r\nvar arrayFindIndex = createArrayMethod(6);\r\nvar id = 0;\r\nvar uncaughtFrozenStore = function uncaughtFrozenStore(that) {\r\n  return that._l || (that._l = new UncaughtFrozenStore());\r\n};\r\nvar UncaughtFrozenStore = function UncaughtFrozenStore() {\r\n  this.a = [];\r\n};\r\nvar findUncaughtFrozen = function findUncaughtFrozen(store, key) {\r\n  return arrayFind(store.a, function (it) {\r\n    return it[0] === key;\r\n  });\r\n};\r\nUncaughtFrozenStore.prototype = {\r\n  get: function get(key) {\r\n    var entry = findUncaughtFrozen(this, key);\r\n    if (entry) return entry[1];\r\n  },\r\n  has: function has(key) {\r\n    return !!findUncaughtFrozen(this, key);\r\n  },\r\n  set: function set(key, value) {\r\n    var entry = findUncaughtFrozen(this, key);\r\n    if (entry) entry[1] = value;else this.a.push([key, value]);\r\n  },\r\n  'delete': function _delete(key) {\r\n    var index = arrayFindIndex(this.a, function (it) {\r\n      return it[0] === key;\r\n    });\r\n    if (~index) this.a.splice(index, 1);\r\n    return !!~index;\r\n  }\r\n};\r\nmodule.exports = {\r\n  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {\r\n    var C = wrapper(function (that, iterable) {\r\n      anInstance(that, C, NAME, '_i');\r\n      that._t = NAME;\r\n      that._i = id++;\r\n      that._l = undefined;\r\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\r\n    });\r\n    redefineAll(C.prototype, {\r\n      'delete': function _delete(key) {\r\n        if (!isObject(key)) return false;\r\n        var data = getWeak(key);\r\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\r\n        return data && $has(data, this._i) && delete data[this._i];\r\n      },\r\n      has: function has(key) {\r\n        if (!isObject(key)) return false;\r\n        var data = getWeak(key);\r\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\r\n        return data && $has(data, this._i);\r\n      }\r\n    });\r\n    return C;\r\n  },\r\n  def: function def(that, key, value) {\r\n    var data = getWeak(anObject(key), true);\r\n    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;\r\n    return that;\r\n  },\r\n  ufstore: uncaughtFrozenStore\r\n};\r\n\r\n/***/ }),\r\n/* 104 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar global = __w_pdfjs_require__(4);\r\nvar $export = __w_pdfjs_require__(3);\r\nvar redefine = __w_pdfjs_require__(7);\r\nvar redefineAll = __w_pdfjs_require__(36);\r\nvar meta = __w_pdfjs_require__(37);\r\nvar forOf = __w_pdfjs_require__(23);\r\nvar anInstance = __w_pdfjs_require__(34);\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar fails = __w_pdfjs_require__(12);\r\nvar $iterDetect = __w_pdfjs_require__(55);\r\nvar setToStringTag = __w_pdfjs_require__(22);\r\nvar inheritIfRequired = __w_pdfjs_require__(105);\r\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\r\n  var Base = global[NAME];\r\n  var C = Base;\r\n  var ADDER = IS_MAP ? 'set' : 'add';\r\n  var proto = C && C.prototype;\r\n  var O = {};\r\n  var fixMethod = function fixMethod(KEY) {\r\n    var fn = proto[KEY];\r\n    redefine(proto, KEY, KEY == 'delete' ? function (a) {\r\n      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\r\n    } : KEY == 'has' ? function has(a) {\r\n      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\r\n    } : KEY == 'get' ? function get(a) {\r\n      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\r\n    } : KEY == 'add' ? function add(a) {\r\n      fn.call(this, a === 0 ? 0 : a);\r\n      return this;\r\n    } : function set(a, b) {\r\n      fn.call(this, a === 0 ? 0 : a, b);\r\n      return this;\r\n    });\r\n  };\r\n  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\r\n    new C().entries().next();\r\n  }))) {\r\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\r\n    redefineAll(C.prototype, methods);\r\n    meta.NEED = true;\r\n  } else {\r\n    var instance = new C();\r\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\r\n    var THROWS_ON_PRIMITIVES = fails(function () {\r\n      instance.has(1);\r\n    });\r\n    var ACCEPT_ITERABLES = $iterDetect(function (iter) {\r\n      new C(iter);\r\n    });\r\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\r\n      var $instance = new C();\r\n      var index = 5;\r\n      while (index--) {\r\n        $instance[ADDER](index, index);\r\n      }return !$instance.has(-0);\r\n    });\r\n    if (!ACCEPT_ITERABLES) {\r\n      C = wrapper(function (target, iterable) {\r\n        anInstance(target, C, NAME);\r\n        var that = inheritIfRequired(new Base(), target, C);\r\n        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\r\n        return that;\r\n      });\r\n      C.prototype = proto;\r\n      proto.constructor = C;\r\n    }\r\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\r\n      fixMethod('delete');\r\n      fixMethod('has');\r\n      IS_MAP && fixMethod('get');\r\n    }\r\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\r\n    if (IS_WEAK && proto.clear) delete proto.clear;\r\n  }\r\n  setToStringTag(C, NAME);\r\n  O[NAME] = C;\r\n  $export($export.G + $export.W + $export.F * (C != Base), O);\r\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\r\n  return C;\r\n};\r\n\r\n/***/ }),\r\n/* 105 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar setPrototypeOf = __w_pdfjs_require__(106).set;\r\nmodule.exports = function (that, target, C) {\r\n  var S = target.constructor;\r\n  var P;\r\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\r\n    setPrototypeOf(that, P);\r\n  }\r\n  return that;\r\n};\r\n\r\n/***/ }),\r\n/* 106 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isObject = __w_pdfjs_require__(2);\r\nvar anObject = __w_pdfjs_require__(6);\r\nvar check = function check(O, proto) {\r\n  anObject(O);\r\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\r\n};\r\nmodule.exports = {\r\n  set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {\r\n    try {\r\n      set = __w_pdfjs_require__(9)(Function.call, __w_pdfjs_require__(107).f(Object.prototype, '__proto__').set, 2);\r\n      set(test, []);\r\n      buggy = !(test instanceof Array);\r\n    } catch (e) {\r\n      buggy = true;\r\n    }\r\n    return function setPrototypeOf(O, proto) {\r\n      check(O, proto);\r\n      if (buggy) O.__proto__ = proto;else set(O, proto);\r\n      return O;\r\n    };\r\n  }({}, false) : undefined),\r\n  check: check\r\n};\r\n\r\n/***/ }),\r\n/* 107 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar pIE = __w_pdfjs_require__(38);\r\nvar createDesc = __w_pdfjs_require__(27);\r\nvar toIObject = __w_pdfjs_require__(16);\r\nvar toPrimitive = __w_pdfjs_require__(41);\r\nvar has = __w_pdfjs_require__(8);\r\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(40);\r\nvar gOPD = Object.getOwnPropertyDescriptor;\r\nexports.f = __w_pdfjs_require__(11) ? gOPD : function getOwnPropertyDescriptor(O, P) {\r\n  O = toIObject(O);\r\n  P = toPrimitive(P, true);\r\n  if (IE8_DOM_DEFINE) try {\r\n    return gOPD(O, P);\r\n  } catch (e) {}\r\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\r\n};\r\n\r\n/***/ }),\r\n/* 108 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(109)('WeakMap');\r\n\r\n/***/ }),\r\n/* 109 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\nmodule.exports = function (COLLECTION) {\r\n  $export($export.S, COLLECTION, {\r\n    of: function of() {\r\n      var length = arguments.length;\r\n      var A = new Array(length);\r\n      while (length--) {\r\n        A[length] = arguments[length];\r\n      }return new this(A);\r\n    }\r\n  });\r\n};\r\n\r\n/***/ }),\r\n/* 110 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(111)('WeakMap');\r\n\r\n/***/ }),\r\n/* 111 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\nvar aFunction = __w_pdfjs_require__(15);\r\nvar ctx = __w_pdfjs_require__(9);\r\nvar forOf = __w_pdfjs_require__(23);\r\nmodule.exports = function (COLLECTION) {\r\n  $export($export.S, COLLECTION, {\r\n    from: function from(source) {\r\n      var mapFn = arguments[1];\r\n      var mapping, A, n, cb;\r\n      aFunction(this);\r\n      mapping = mapFn !== undefined;\r\n      if (mapping) aFunction(mapFn);\r\n      if (source == undefined) return new this();\r\n      A = [];\r\n      if (mapping) {\r\n        n = 0;\r\n        cb = ctx(mapFn, arguments[2], 2);\r\n        forOf(source, false, function (nextItem) {\r\n          A.push(cb(nextItem, n++));\r\n        });\r\n      } else {\r\n        forOf(source, false, A.push, A);\r\n      }\r\n      return new this(A);\r\n    }\r\n  });\r\n};\r\n\r\n/***/ }),\r\n/* 112 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\n__w_pdfjs_require__(113);\r\nmodule.exports = __w_pdfjs_require__(5).Object.values;\r\n\r\n/***/ }),\r\n/* 113 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar $export = __w_pdfjs_require__(3);\r\nvar $values = __w_pdfjs_require__(114)(false);\r\n$export($export.S, 'Object', {\r\n  values: function values(it) {\r\n    return $values(it);\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 114 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar getKeys = __w_pdfjs_require__(21);\r\nvar toIObject = __w_pdfjs_require__(16);\r\nvar isEnum = __w_pdfjs_require__(38).f;\r\nmodule.exports = function (isEntries) {\r\n  return function (it) {\r\n    var O = toIObject(it);\r\n    var keys = getKeys(O);\r\n    var length = keys.length;\r\n    var i = 0;\r\n    var result = [];\r\n    var key;\r\n    while (length > i) {\r\n      if (isEnum.call(O, key = keys[i++])) {\r\n        result.push(isEntries ? [key, O[key]] : O[key]);\r\n      }\r\n    }return result;\r\n  };\r\n};\r\n\r\n/***/ }),\r\n/* 115 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar isReadableStreamSupported = false;\r\nif (typeof ReadableStream !== 'undefined') {\r\n  try {\r\n    new ReadableStream({\r\n      start: function start(controller) {\r\n        controller.close();\r\n      }\r\n    });\r\n    isReadableStreamSupported = true;\r\n  } catch (e) {}\r\n}\r\nif (isReadableStreamSupported) {\r\n  exports.ReadableStream = ReadableStream;\r\n} else {\r\n  exports.ReadableStream = __w_pdfjs_require__(116).ReadableStream;\r\n}\r\n\r\n/***/ }),\r\n/* 116 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\n(function (e, a) {\r\n  for (var i in a) {\r\n    e[i] = a[i];\r\n  }\r\n})(exports, function (modules) {\r\n  var installedModules = {};\r\n  function __w_pdfjs_require__(moduleId) {\r\n    if (installedModules[moduleId]) return installedModules[moduleId].exports;\r\n    var module = installedModules[moduleId] = {\r\n      i: moduleId,\r\n      l: false,\r\n      exports: {}\r\n    };\r\n    modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);\r\n    module.l = true;\r\n    return module.exports;\r\n  }\r\n  __w_pdfjs_require__.m = modules;\r\n  __w_pdfjs_require__.c = installedModules;\r\n  __w_pdfjs_require__.i = function (value) {\r\n    return value;\r\n  };\r\n  __w_pdfjs_require__.d = function (exports, name, getter) {\r\n    if (!__w_pdfjs_require__.o(exports, name)) {\r\n      Object.defineProperty(exports, name, {\r\n        configurable: false,\r\n        enumerable: true,\r\n        get: getter\r\n      });\r\n    }\r\n  };\r\n  __w_pdfjs_require__.n = function (module) {\r\n    var getter = module && module.__esModule ? function getDefault() {\r\n      return module['default'];\r\n    } : function getModuleExports() {\r\n      return module;\r\n    };\r\n    __w_pdfjs_require__.d(getter, 'a', getter);\r\n    return getter;\r\n  };\r\n  __w_pdfjs_require__.o = function (object, property) {\r\n    return Object.prototype.hasOwnProperty.call(object, property);\r\n  };\r\n  __w_pdfjs_require__.p = \"\";\r\n  return __w_pdfjs_require__(__w_pdfjs_require__.s = 7);\r\n}([function (module, exports, __w_pdfjs_require__) {\r\n  \"use strict\";\r\n\r\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\r\n    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\r\n  } : function (obj) {\r\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\r\n  };\r\n  var _require = __w_pdfjs_require__(1),\r\n      assert = _require.assert;\r\n  function IsPropertyKey(argument) {\r\n    return typeof argument === 'string' || (typeof argument === 'undefined' ? 'undefined' : _typeof(argument)) === 'symbol';\r\n  }\r\n  exports.typeIsObject = function (x) {\r\n    return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null || typeof x === 'function';\r\n  };\r\n  exports.createDataProperty = function (o, p, v) {\r\n    assert(exports.typeIsObject(o));\r\n    Object.defineProperty(o, p, {\r\n      value: v,\r\n      writable: true,\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n  };\r\n  exports.createArrayFromList = function (elements) {\r\n    return elements.slice();\r\n  };\r\n  exports.ArrayBufferCopy = function (dest, destOffset, src, srcOffset, n) {\r\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\r\n  };\r\n  exports.CreateIterResultObject = function (value, done) {\r\n    assert(typeof done === 'boolean');\r\n    var obj = {};\r\n    Object.defineProperty(obj, 'value', {\r\n      value: value,\r\n      enumerable: true,\r\n      writable: true,\r\n      configurable: true\r\n    });\r\n    Object.defineProperty(obj, 'done', {\r\n      value: done,\r\n      enumerable: true,\r\n      writable: true,\r\n      configurable: true\r\n    });\r\n    return obj;\r\n  };\r\n  exports.IsFiniteNonNegativeNumber = function (v) {\r\n    if (Number.isNaN(v)) {\r\n      return false;\r\n    }\r\n    if (v === Infinity) {\r\n      return false;\r\n    }\r\n    if (v < 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n  function Call(F, V, args) {\r\n    if (typeof F !== 'function') {\r\n      throw new TypeError('Argument is not a function');\r\n    }\r\n    return Function.prototype.apply.call(F, V, args);\r\n  }\r\n  exports.InvokeOrNoop = function (O, P, args) {\r\n    assert(O !== undefined);\r\n    assert(IsPropertyKey(P));\r\n    assert(Array.isArray(args));\r\n    var method = O[P];\r\n    if (method === undefined) {\r\n      return undefined;\r\n    }\r\n    return Call(method, O, args);\r\n  };\r\n  exports.PromiseInvokeOrNoop = function (O, P, args) {\r\n    assert(O !== undefined);\r\n    assert(IsPropertyKey(P));\r\n    assert(Array.isArray(args));\r\n    try {\r\n      return Promise.resolve(exports.InvokeOrNoop(O, P, args));\r\n    } catch (returnValueE) {\r\n      return Promise.reject(returnValueE);\r\n    }\r\n  };\r\n  exports.PromiseInvokeOrPerformFallback = function (O, P, args, F, argsF) {\r\n    assert(O !== undefined);\r\n    assert(IsPropertyKey(P));\r\n    assert(Array.isArray(args));\r\n    assert(Array.isArray(argsF));\r\n    var method = void 0;\r\n    try {\r\n      method = O[P];\r\n    } catch (methodE) {\r\n      return Promise.reject(methodE);\r\n    }\r\n    if (method === undefined) {\r\n      return F.apply(null, argsF);\r\n    }\r\n    try {\r\n      return Promise.resolve(Call(method, O, args));\r\n    } catch (e) {\r\n      return Promise.reject(e);\r\n    }\r\n  };\r\n  exports.TransferArrayBuffer = function (O) {\r\n    return O.slice();\r\n  };\r\n  exports.ValidateAndNormalizeHighWaterMark = function (highWaterMark) {\r\n    highWaterMark = Number(highWaterMark);\r\n    if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\r\n      throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\r\n    }\r\n    return highWaterMark;\r\n  };\r\n  exports.ValidateAndNormalizeQueuingStrategy = function (size, highWaterMark) {\r\n    if (size !== undefined && typeof size !== 'function') {\r\n      throw new TypeError('size property of a queuing strategy must be a function');\r\n    }\r\n    highWaterMark = exports.ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n    return {\r\n      size: size,\r\n      highWaterMark: highWaterMark\r\n    };\r\n  };\r\n}, function (module, exports, __w_pdfjs_require__) {\r\n  \"use strict\";\r\n\r\n  function rethrowAssertionErrorRejection(e) {\r\n    if (e && e.constructor === AssertionError) {\r\n      setTimeout(function () {\r\n        throw e;\r\n      }, 0);\r\n    }\r\n  }\r\n  function AssertionError(message) {\r\n    this.name = 'AssertionError';\r\n    this.message = message || '';\r\n    this.stack = new Error().stack;\r\n  }\r\n  AssertionError.prototype = Object.create(Error.prototype);\r\n  AssertionError.prototype.constructor = AssertionError;\r\n  function assert(value, message) {\r\n    if (!value) {\r\n      throw new AssertionError(message);\r\n    }\r\n  }\r\n  module.exports = {\r\n    rethrowAssertionErrorRejection: rethrowAssertionErrorRejection,\r\n    AssertionError: AssertionError,\r\n    assert: assert\r\n  };\r\n}, function (module, exports, __w_pdfjs_require__) {\r\n  \"use strict\";\r\n\r\n  var _createClass = function () {\r\n    function defineProperties(target, props) {\r\n      for (var i = 0; i < props.length; i++) {\r\n        var descriptor = props[i];\r\n        descriptor.enumerable = descriptor.enumerable || false;\r\n        descriptor.configurable = true;\r\n        if (\"value\" in descriptor) descriptor.writable = true;\r\n        Object.defineProperty(target, descriptor.key, descriptor);\r\n      }\r\n    }\r\n    return function (Constructor, protoProps, staticProps) {\r\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\r\n      if (staticProps) defineProperties(Constructor, staticProps);\r\n      return Constructor;\r\n    };\r\n  }();\r\n  function _classCallCheck(instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError(\"Cannot call a class as a function\");\r\n    }\r\n  }\r\n  var _require = __w_pdfjs_require__(0),\r\n      InvokeOrNoop = _require.InvokeOrNoop,\r\n      PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,\r\n      ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,\r\n      typeIsObject = _require.typeIsObject;\r\n  var _require2 = __w_pdfjs_require__(1),\r\n      assert = _require2.assert,\r\n      rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection;\r\n  var _require3 = __w_pdfjs_require__(3),\r\n      DequeueValue = _require3.DequeueValue,\r\n      EnqueueValueWithSize = _require3.EnqueueValueWithSize,\r\n      PeekQueueValue = _require3.PeekQueueValue,\r\n      ResetQueue = _require3.ResetQueue;\r\n  var WritableStream = function () {\r\n    function WritableStream() {\r\n      var underlyingSink = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n          size = _ref.size,\r\n          _ref$highWaterMark = _ref.highWaterMark,\r\n          highWaterMark = _ref$highWaterMark === undefined ? 1 : _ref$highWaterMark;\r\n      _classCallCheck(this, WritableStream);\r\n      this._state = 'writable';\r\n      this._storedError = undefined;\r\n      this._writer = undefined;\r\n      this._writableStreamController = undefined;\r\n      this._writeRequests = [];\r\n      this._inFlightWriteRequest = undefined;\r\n      this._closeRequest = undefined;\r\n      this._inFlightCloseRequest = undefined;\r\n      this._pendingAbortRequest = undefined;\r\n      this._backpressure = false;\r\n      var type = underlyingSink.type;\r\n      if (type !== undefined) {\r\n        throw new RangeError('Invalid type is specified');\r\n      }\r\n      this._writableStreamController = new WritableStreamDefaultController(this, underlyingSink, size, highWaterMark);\r\n      this._writableStreamController.__startSteps();\r\n    }\r\n    _createClass(WritableStream, [{\r\n      key: 'abort',\r\n      value: function abort(reason) {\r\n        if (IsWritableStream(this) === false) {\r\n          return Promise.reject(streamBrandCheckException('abort'));\r\n        }\r\n        if (IsWritableStreamLocked(this) === true) {\r\n          return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\r\n        }\r\n        return WritableStreamAbort(this, reason);\r\n      }\r\n    }, {\r\n      key: 'getWriter',\r\n      value: function getWriter() {\r\n        if (IsWritableStream(this) === false) {\r\n          throw streamBrandCheckException('getWriter');\r\n        }\r\n        return AcquireWritableStreamDefaultWriter(this);\r\n      }\r\n    }, {\r\n      key: 'locked',\r\n      get: function get() {\r\n        if (IsWritableStream(this) === false) {\r\n          throw streamBrandCheckException('locked');\r\n        }\r\n        return IsWritableStreamLocked(this);\r\n      }\r\n    }]);\r\n    return WritableStream;\r\n  }();\r\n  module.exports = {\r\n    AcquireWritableStreamDefaultWriter: AcquireWritableStreamDefaultWriter,\r\n    IsWritableStream: IsWritableStream,\r\n    IsWritableStreamLocked: IsWritableStreamLocked,\r\n    WritableStream: WritableStream,\r\n    WritableStreamAbort: WritableStreamAbort,\r\n    WritableStreamDefaultControllerError: WritableStreamDefaultControllerError,\r\n    WritableStreamDefaultWriterCloseWithErrorPropagation: WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n    WritableStreamDefaultWriterRelease: WritableStreamDefaultWriterRelease,\r\n    WritableStreamDefaultWriterWrite: WritableStreamDefaultWriterWrite,\r\n    WritableStreamCloseQueuedOrInFlight: WritableStreamCloseQueuedOrInFlight\r\n  };\r\n  function AcquireWritableStreamDefaultWriter(stream) {\r\n    return new WritableStreamDefaultWriter(stream);\r\n  }\r\n  function IsWritableStream(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function IsWritableStreamLocked(stream) {\r\n    assert(IsWritableStream(stream) === true, 'IsWritableStreamLocked should only be used on known writable streams');\r\n    if (stream._writer === undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function WritableStreamAbort(stream, reason) {\r\n    var state = stream._state;\r\n    if (state === 'closed') {\r\n      return Promise.resolve(undefined);\r\n    }\r\n    if (state === 'errored') {\r\n      return Promise.reject(stream._storedError);\r\n    }\r\n    var error = new TypeError('Requested to abort');\r\n    if (stream._pendingAbortRequest !== undefined) {\r\n      return Promise.reject(error);\r\n    }\r\n    assert(state === 'writable' || state === 'erroring', 'state must be writable or erroring');\r\n    var wasAlreadyErroring = false;\r\n    if (state === 'erroring') {\r\n      wasAlreadyErroring = true;\r\n      reason = undefined;\r\n    }\r\n    var promise = new Promise(function (resolve, reject) {\r\n      stream._pendingAbortRequest = {\r\n        _resolve: resolve,\r\n        _reject: reject,\r\n        _reason: reason,\r\n        _wasAlreadyErroring: wasAlreadyErroring\r\n      };\r\n    });\r\n    if (wasAlreadyErroring === false) {\r\n      WritableStreamStartErroring(stream, error);\r\n    }\r\n    return promise;\r\n  }\r\n  function WritableStreamAddWriteRequest(stream) {\r\n    assert(IsWritableStreamLocked(stream) === true);\r\n    assert(stream._state === 'writable');\r\n    var promise = new Promise(function (resolve, reject) {\r\n      var writeRequest = {\r\n        _resolve: resolve,\r\n        _reject: reject\r\n      };\r\n      stream._writeRequests.push(writeRequest);\r\n    });\r\n    return promise;\r\n  }\r\n  function WritableStreamDealWithRejection(stream, error) {\r\n    var state = stream._state;\r\n    if (state === 'writable') {\r\n      WritableStreamStartErroring(stream, error);\r\n      return;\r\n    }\r\n    assert(state === 'erroring');\r\n    WritableStreamFinishErroring(stream);\r\n  }\r\n  function WritableStreamStartErroring(stream, reason) {\r\n    assert(stream._storedError === undefined, 'stream._storedError === undefined');\r\n    assert(stream._state === 'writable', 'state must be writable');\r\n    var controller = stream._writableStreamController;\r\n    assert(controller !== undefined, 'controller must not be undefined');\r\n    stream._state = 'erroring';\r\n    stream._storedError = reason;\r\n    var writer = stream._writer;\r\n    if (writer !== undefined) {\r\n      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\r\n    }\r\n    if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\r\n      WritableStreamFinishErroring(stream);\r\n    }\r\n  }\r\n  function WritableStreamFinishErroring(stream) {\r\n    assert(stream._state === 'erroring', 'stream._state === erroring');\r\n    assert(WritableStreamHasOperationMarkedInFlight(stream) === false, 'WritableStreamHasOperationMarkedInFlight(stream) === false');\r\n    stream._state = 'errored';\r\n    stream._writableStreamController.__errorSteps();\r\n    var storedError = stream._storedError;\r\n    for (var i = 0; i < stream._writeRequests.length; i++) {\r\n      var writeRequest = stream._writeRequests[i];\r\n      writeRequest._reject(storedError);\r\n    }\r\n    stream._writeRequests = [];\r\n    if (stream._pendingAbortRequest === undefined) {\r\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      return;\r\n    }\r\n    var abortRequest = stream._pendingAbortRequest;\r\n    stream._pendingAbortRequest = undefined;\r\n    if (abortRequest._wasAlreadyErroring === true) {\r\n      abortRequest._reject(storedError);\r\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n      return;\r\n    }\r\n    var promise = stream._writableStreamController.__abortSteps(abortRequest._reason);\r\n    promise.then(function () {\r\n      abortRequest._resolve();\r\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    }, function (reason) {\r\n      abortRequest._reject(reason);\r\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\r\n    });\r\n  }\r\n  function WritableStreamFinishInFlightWrite(stream) {\r\n    assert(stream._inFlightWriteRequest !== undefined);\r\n    stream._inFlightWriteRequest._resolve(undefined);\r\n    stream._inFlightWriteRequest = undefined;\r\n  }\r\n  function WritableStreamFinishInFlightWriteWithError(stream, error) {\r\n    assert(stream._inFlightWriteRequest !== undefined);\r\n    stream._inFlightWriteRequest._reject(error);\r\n    stream._inFlightWriteRequest = undefined;\r\n    assert(stream._state === 'writable' || stream._state === 'erroring');\r\n    WritableStreamDealWithRejection(stream, error);\r\n  }\r\n  function WritableStreamFinishInFlightClose(stream) {\r\n    assert(stream._inFlightCloseRequest !== undefined);\r\n    stream._inFlightCloseRequest._resolve(undefined);\r\n    stream._inFlightCloseRequest = undefined;\r\n    var state = stream._state;\r\n    assert(state === 'writable' || state === 'erroring');\r\n    if (state === 'erroring') {\r\n      stream._storedError = undefined;\r\n      if (stream._pendingAbortRequest !== undefined) {\r\n        stream._pendingAbortRequest._resolve();\r\n        stream._pendingAbortRequest = undefined;\r\n      }\r\n    }\r\n    stream._state = 'closed';\r\n    var writer = stream._writer;\r\n    if (writer !== undefined) {\r\n      defaultWriterClosedPromiseResolve(writer);\r\n    }\r\n    assert(stream._pendingAbortRequest === undefined, 'stream._pendingAbortRequest === undefined');\r\n    assert(stream._storedError === undefined, 'stream._storedError === undefined');\r\n  }\r\n  function WritableStreamFinishInFlightCloseWithError(stream, error) {\r\n    assert(stream._inFlightCloseRequest !== undefined);\r\n    stream._inFlightCloseRequest._reject(error);\r\n    stream._inFlightCloseRequest = undefined;\r\n    assert(stream._state === 'writable' || stream._state === 'erroring');\r\n    if (stream._pendingAbortRequest !== undefined) {\r\n      stream._pendingAbortRequest._reject(error);\r\n      stream._pendingAbortRequest = undefined;\r\n    }\r\n    WritableStreamDealWithRejection(stream, error);\r\n  }\r\n  function WritableStreamCloseQueuedOrInFlight(stream) {\r\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function WritableStreamHasOperationMarkedInFlight(stream) {\r\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function WritableStreamMarkCloseRequestInFlight(stream) {\r\n    assert(stream._inFlightCloseRequest === undefined);\r\n    assert(stream._closeRequest !== undefined);\r\n    stream._inFlightCloseRequest = stream._closeRequest;\r\n    stream._closeRequest = undefined;\r\n  }\r\n  function WritableStreamMarkFirstWriteRequestInFlight(stream) {\r\n    assert(stream._inFlightWriteRequest === undefined, 'there must be no pending write request');\r\n    assert(stream._writeRequests.length !== 0, 'writeRequests must not be empty');\r\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\r\n  }\r\n  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\r\n    assert(stream._state === 'errored', '_stream_.[[state]] is `\"errored\"`');\r\n    if (stream._closeRequest !== undefined) {\r\n      assert(stream._inFlightCloseRequest === undefined);\r\n      stream._closeRequest._reject(stream._storedError);\r\n      stream._closeRequest = undefined;\r\n    }\r\n    var writer = stream._writer;\r\n    if (writer !== undefined) {\r\n      defaultWriterClosedPromiseReject(writer, stream._storedError);\r\n      writer._closedPromise.catch(function () {});\r\n    }\r\n  }\r\n  function WritableStreamUpdateBackpressure(stream, backpressure) {\r\n    assert(stream._state === 'writable');\r\n    assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n    var writer = stream._writer;\r\n    if (writer !== undefined && backpressure !== stream._backpressure) {\r\n      if (backpressure === true) {\r\n        defaultWriterReadyPromiseReset(writer);\r\n      } else {\r\n        assert(backpressure === false);\r\n        defaultWriterReadyPromiseResolve(writer);\r\n      }\r\n    }\r\n    stream._backpressure = backpressure;\r\n  }\r\n  var WritableStreamDefaultWriter = function () {\r\n    function WritableStreamDefaultWriter(stream) {\r\n      _classCallCheck(this, WritableStreamDefaultWriter);\r\n      if (IsWritableStream(stream) === false) {\r\n        throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\r\n      }\r\n      if (IsWritableStreamLocked(stream) === true) {\r\n        throw new TypeError('This stream has already been locked for exclusive writing by another writer');\r\n      }\r\n      this._ownerWritableStream = stream;\r\n      stream._writer = this;\r\n      var state = stream._state;\r\n      if (state === 'writable') {\r\n        if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\r\n          defaultWriterReadyPromiseInitialize(this);\r\n        } else {\r\n          defaultWriterReadyPromiseInitializeAsResolved(this);\r\n        }\r\n        defaultWriterClosedPromiseInitialize(this);\r\n      } else if (state === 'erroring') {\r\n        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\r\n        this._readyPromise.catch(function () {});\r\n        defaultWriterClosedPromiseInitialize(this);\r\n      } else if (state === 'closed') {\r\n        defaultWriterReadyPromiseInitializeAsResolved(this);\r\n        defaultWriterClosedPromiseInitializeAsResolved(this);\r\n      } else {\r\n        assert(state === 'errored', 'state must be errored');\r\n        var storedError = stream._storedError;\r\n        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\r\n        this._readyPromise.catch(function () {});\r\n        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\r\n        this._closedPromise.catch(function () {});\r\n      }\r\n    }\r\n    _createClass(WritableStreamDefaultWriter, [{\r\n      key: 'abort',\r\n      value: function abort(reason) {\r\n        if (IsWritableStreamDefaultWriter(this) === false) {\r\n          return Promise.reject(defaultWriterBrandCheckException('abort'));\r\n        }\r\n        if (this._ownerWritableStream === undefined) {\r\n          return Promise.reject(defaultWriterLockException('abort'));\r\n        }\r\n        return WritableStreamDefaultWriterAbort(this, reason);\r\n      }\r\n    }, {\r\n      key: 'close',\r\n      value: function close() {\r\n        if (IsWritableStreamDefaultWriter(this) === false) {\r\n          return Promise.reject(defaultWriterBrandCheckException('close'));\r\n        }\r\n        var stream = this._ownerWritableStream;\r\n        if (stream === undefined) {\r\n          return Promise.reject(defaultWriterLockException('close'));\r\n        }\r\n        if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\r\n          return Promise.reject(new TypeError('cannot close an already-closing stream'));\r\n        }\r\n        return WritableStreamDefaultWriterClose(this);\r\n      }\r\n    }, {\r\n      key: 'releaseLock',\r\n      value: function releaseLock() {\r\n        if (IsWritableStreamDefaultWriter(this) === false) {\r\n          throw defaultWriterBrandCheckException('releaseLock');\r\n        }\r\n        var stream = this._ownerWritableStream;\r\n        if (stream === undefined) {\r\n          return;\r\n        }\r\n        assert(stream._writer !== undefined);\r\n        WritableStreamDefaultWriterRelease(this);\r\n      }\r\n    }, {\r\n      key: 'write',\r\n      value: function write(chunk) {\r\n        if (IsWritableStreamDefaultWriter(this) === false) {\r\n          return Promise.reject(defaultWriterBrandCheckException('write'));\r\n        }\r\n        if (this._ownerWritableStream === undefined) {\r\n          return Promise.reject(defaultWriterLockException('write to'));\r\n        }\r\n        return WritableStreamDefaultWriterWrite(this, chunk);\r\n      }\r\n    }, {\r\n      key: 'closed',\r\n      get: function get() {\r\n        if (IsWritableStreamDefaultWriter(this) === false) {\r\n          return Promise.reject(defaultWriterBrandCheckException('closed'));\r\n        }\r\n        return this._closedPromise;\r\n      }\r\n    }, {\r\n      key: 'desiredSize',\r\n      get: function get() {\r\n        if (IsWritableStreamDefaultWriter(this) === false) {\r\n          throw defaultWriterBrandCheckException('desiredSize');\r\n        }\r\n        if (this._ownerWritableStream === undefined) {\r\n          throw defaultWriterLockException('desiredSize');\r\n        }\r\n        return WritableStreamDefaultWriterGetDesiredSize(this);\r\n      }\r\n    }, {\r\n      key: 'ready',\r\n      get: function get() {\r\n        if (IsWritableStreamDefaultWriter(this) === false) {\r\n          return Promise.reject(defaultWriterBrandCheckException('ready'));\r\n        }\r\n        return this._readyPromise;\r\n      }\r\n    }]);\r\n    return WritableStreamDefaultWriter;\r\n  }();\r\n  function IsWritableStreamDefaultWriter(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function WritableStreamDefaultWriterAbort(writer, reason) {\r\n    var stream = writer._ownerWritableStream;\r\n    assert(stream !== undefined);\r\n    return WritableStreamAbort(stream, reason);\r\n  }\r\n  function WritableStreamDefaultWriterClose(writer) {\r\n    var stream = writer._ownerWritableStream;\r\n    assert(stream !== undefined);\r\n    var state = stream._state;\r\n    if (state === 'closed' || state === 'errored') {\r\n      return Promise.reject(new TypeError('The stream (in ' + state + ' state) is not in the writable state and cannot be closed'));\r\n    }\r\n    assert(state === 'writable' || state === 'erroring');\r\n    assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\r\n    var promise = new Promise(function (resolve, reject) {\r\n      var closeRequest = {\r\n        _resolve: resolve,\r\n        _reject: reject\r\n      };\r\n      stream._closeRequest = closeRequest;\r\n    });\r\n    if (stream._backpressure === true && state === 'writable') {\r\n      defaultWriterReadyPromiseResolve(writer);\r\n    }\r\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\r\n    return promise;\r\n  }\r\n  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\r\n    var stream = writer._ownerWritableStream;\r\n    assert(stream !== undefined);\r\n    var state = stream._state;\r\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n      return Promise.resolve();\r\n    }\r\n    if (state === 'errored') {\r\n      return Promise.reject(stream._storedError);\r\n    }\r\n    assert(state === 'writable' || state === 'erroring');\r\n    return WritableStreamDefaultWriterClose(writer);\r\n  }\r\n  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\r\n    if (writer._closedPromiseState === 'pending') {\r\n      defaultWriterClosedPromiseReject(writer, error);\r\n    } else {\r\n      defaultWriterClosedPromiseResetToRejected(writer, error);\r\n    }\r\n    writer._closedPromise.catch(function () {});\r\n  }\r\n  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\r\n    if (writer._readyPromiseState === 'pending') {\r\n      defaultWriterReadyPromiseReject(writer, error);\r\n    } else {\r\n      defaultWriterReadyPromiseResetToRejected(writer, error);\r\n    }\r\n    writer._readyPromise.catch(function () {});\r\n  }\r\n  function WritableStreamDefaultWriterGetDesiredSize(writer) {\r\n    var stream = writer._ownerWritableStream;\r\n    var state = stream._state;\r\n    if (state === 'errored' || state === 'erroring') {\r\n      return null;\r\n    }\r\n    if (state === 'closed') {\r\n      return 0;\r\n    }\r\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\r\n  }\r\n  function WritableStreamDefaultWriterRelease(writer) {\r\n    var stream = writer._ownerWritableStream;\r\n    assert(stream !== undefined);\r\n    assert(stream._writer === writer);\r\n    var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\\'s closedness');\r\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\r\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\r\n    stream._writer = undefined;\r\n    writer._ownerWritableStream = undefined;\r\n  }\r\n  function WritableStreamDefaultWriterWrite(writer, chunk) {\r\n    var stream = writer._ownerWritableStream;\r\n    assert(stream !== undefined);\r\n    var controller = stream._writableStreamController;\r\n    var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\r\n    if (stream !== writer._ownerWritableStream) {\r\n      return Promise.reject(defaultWriterLockException('write to'));\r\n    }\r\n    var state = stream._state;\r\n    if (state === 'errored') {\r\n      return Promise.reject(stream._storedError);\r\n    }\r\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\r\n      return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\r\n    }\r\n    if (state === 'erroring') {\r\n      return Promise.reject(stream._storedError);\r\n    }\r\n    assert(state === 'writable');\r\n    var promise = WritableStreamAddWriteRequest(stream);\r\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\r\n    return promise;\r\n  }\r\n  var WritableStreamDefaultController = function () {\r\n    function WritableStreamDefaultController(stream, underlyingSink, size, highWaterMark) {\r\n      _classCallCheck(this, WritableStreamDefaultController);\r\n      if (IsWritableStream(stream) === false) {\r\n        throw new TypeError('WritableStreamDefaultController can only be constructed with a WritableStream instance');\r\n      }\r\n      if (stream._writableStreamController !== undefined) {\r\n        throw new TypeError('WritableStreamDefaultController instances can only be created by the WritableStream constructor');\r\n      }\r\n      this._controlledWritableStream = stream;\r\n      this._underlyingSink = underlyingSink;\r\n      this._queue = undefined;\r\n      this._queueTotalSize = undefined;\r\n      ResetQueue(this);\r\n      this._started = false;\r\n      var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\r\n      this._strategySize = normalizedStrategy.size;\r\n      this._strategyHWM = normalizedStrategy.highWaterMark;\r\n      var backpressure = WritableStreamDefaultControllerGetBackpressure(this);\r\n      WritableStreamUpdateBackpressure(stream, backpressure);\r\n    }\r\n    _createClass(WritableStreamDefaultController, [{\r\n      key: 'error',\r\n      value: function error(e) {\r\n        if (IsWritableStreamDefaultController(this) === false) {\r\n          throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\r\n        }\r\n        var state = this._controlledWritableStream._state;\r\n        if (state !== 'writable') {\r\n          return;\r\n        }\r\n        WritableStreamDefaultControllerError(this, e);\r\n      }\r\n    }, {\r\n      key: '__abortSteps',\r\n      value: function __abortSteps(reason) {\r\n        return PromiseInvokeOrNoop(this._underlyingSink, 'abort', [reason]);\r\n      }\r\n    }, {\r\n      key: '__errorSteps',\r\n      value: function __errorSteps() {\r\n        ResetQueue(this);\r\n      }\r\n    }, {\r\n      key: '__startSteps',\r\n      value: function __startSteps() {\r\n        var _this = this;\r\n        var startResult = InvokeOrNoop(this._underlyingSink, 'start', [this]);\r\n        var stream = this._controlledWritableStream;\r\n        Promise.resolve(startResult).then(function () {\r\n          assert(stream._state === 'writable' || stream._state === 'erroring');\r\n          _this._started = true;\r\n          WritableStreamDefaultControllerAdvanceQueueIfNeeded(_this);\r\n        }, function (r) {\r\n          assert(stream._state === 'writable' || stream._state === 'erroring');\r\n          _this._started = true;\r\n          WritableStreamDealWithRejection(stream, r);\r\n        }).catch(rethrowAssertionErrorRejection);\r\n      }\r\n    }]);\r\n    return WritableStreamDefaultController;\r\n  }();\r\n  function WritableStreamDefaultControllerClose(controller) {\r\n    EnqueueValueWithSize(controller, 'close', 0);\r\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n  }\r\n  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\r\n    var strategySize = controller._strategySize;\r\n    if (strategySize === undefined) {\r\n      return 1;\r\n    }\r\n    try {\r\n      return strategySize(chunk);\r\n    } catch (chunkSizeE) {\r\n      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\r\n      return 1;\r\n    }\r\n  }\r\n  function WritableStreamDefaultControllerGetDesiredSize(controller) {\r\n    return controller._strategyHWM - controller._queueTotalSize;\r\n  }\r\n  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\r\n    var writeRecord = { chunk: chunk };\r\n    try {\r\n      EnqueueValueWithSize(controller, writeRecord, chunkSize);\r\n    } catch (enqueueE) {\r\n      WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\r\n      return;\r\n    }\r\n    var stream = controller._controlledWritableStream;\r\n    if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\r\n      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n      WritableStreamUpdateBackpressure(stream, backpressure);\r\n    }\r\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n  }\r\n  function IsWritableStreamDefaultController(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSink')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\r\n    var stream = controller._controlledWritableStream;\r\n    if (controller._started === false) {\r\n      return;\r\n    }\r\n    if (stream._inFlightWriteRequest !== undefined) {\r\n      return;\r\n    }\r\n    var state = stream._state;\r\n    if (state === 'closed' || state === 'errored') {\r\n      return;\r\n    }\r\n    if (state === 'erroring') {\r\n      WritableStreamFinishErroring(stream);\r\n      return;\r\n    }\r\n    if (controller._queue.length === 0) {\r\n      return;\r\n    }\r\n    var writeRecord = PeekQueueValue(controller);\r\n    if (writeRecord === 'close') {\r\n      WritableStreamDefaultControllerProcessClose(controller);\r\n    } else {\r\n      WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\r\n    }\r\n  }\r\n  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\r\n    if (controller._controlledWritableStream._state === 'writable') {\r\n      WritableStreamDefaultControllerError(controller, error);\r\n    }\r\n  }\r\n  function WritableStreamDefaultControllerProcessClose(controller) {\r\n    var stream = controller._controlledWritableStream;\r\n    WritableStreamMarkCloseRequestInFlight(stream);\r\n    DequeueValue(controller);\r\n    assert(controller._queue.length === 0, 'queue must be empty once the final write record is dequeued');\r\n    var sinkClosePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'close', []);\r\n    sinkClosePromise.then(function () {\r\n      WritableStreamFinishInFlightClose(stream);\r\n    }, function (reason) {\r\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\r\n    }).catch(rethrowAssertionErrorRejection);\r\n  }\r\n  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\r\n    var stream = controller._controlledWritableStream;\r\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\r\n    var sinkWritePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'write', [chunk, controller]);\r\n    sinkWritePromise.then(function () {\r\n      WritableStreamFinishInFlightWrite(stream);\r\n      var state = stream._state;\r\n      assert(state === 'writable' || state === 'erroring');\r\n      DequeueValue(controller);\r\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\r\n        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\r\n        WritableStreamUpdateBackpressure(stream, backpressure);\r\n      }\r\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\r\n    }, function (reason) {\r\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\r\n    }).catch(rethrowAssertionErrorRejection);\r\n  }\r\n  function WritableStreamDefaultControllerGetBackpressure(controller) {\r\n    var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\r\n    return desiredSize <= 0;\r\n  }\r\n  function WritableStreamDefaultControllerError(controller, error) {\r\n    var stream = controller._controlledWritableStream;\r\n    assert(stream._state === 'writable');\r\n    WritableStreamStartErroring(stream, error);\r\n  }\r\n  function streamBrandCheckException(name) {\r\n    return new TypeError('WritableStream.prototype.' + name + ' can only be used on a WritableStream');\r\n  }\r\n  function defaultWriterBrandCheckException(name) {\r\n    return new TypeError('WritableStreamDefaultWriter.prototype.' + name + ' can only be used on a WritableStreamDefaultWriter');\r\n  }\r\n  function defaultWriterLockException(name) {\r\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\r\n  }\r\n  function defaultWriterClosedPromiseInitialize(writer) {\r\n    writer._closedPromise = new Promise(function (resolve, reject) {\r\n      writer._closedPromise_resolve = resolve;\r\n      writer._closedPromise_reject = reject;\r\n      writer._closedPromiseState = 'pending';\r\n    });\r\n  }\r\n  function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\r\n    writer._closedPromise = Promise.reject(reason);\r\n    writer._closedPromise_resolve = undefined;\r\n    writer._closedPromise_reject = undefined;\r\n    writer._closedPromiseState = 'rejected';\r\n  }\r\n  function defaultWriterClosedPromiseInitializeAsResolved(writer) {\r\n    writer._closedPromise = Promise.resolve(undefined);\r\n    writer._closedPromise_resolve = undefined;\r\n    writer._closedPromise_reject = undefined;\r\n    writer._closedPromiseState = 'resolved';\r\n  }\r\n  function defaultWriterClosedPromiseReject(writer, reason) {\r\n    assert(writer._closedPromise_resolve !== undefined, 'writer._closedPromise_resolve !== undefined');\r\n    assert(writer._closedPromise_reject !== undefined, 'writer._closedPromise_reject !== undefined');\r\n    assert(writer._closedPromiseState === 'pending', 'writer._closedPromiseState is pending');\r\n    writer._closedPromise_reject(reason);\r\n    writer._closedPromise_resolve = undefined;\r\n    writer._closedPromise_reject = undefined;\r\n    writer._closedPromiseState = 'rejected';\r\n  }\r\n  function defaultWriterClosedPromiseResetToRejected(writer, reason) {\r\n    assert(writer._closedPromise_resolve === undefined, 'writer._closedPromise_resolve === undefined');\r\n    assert(writer._closedPromise_reject === undefined, 'writer._closedPromise_reject === undefined');\r\n    assert(writer._closedPromiseState !== 'pending', 'writer._closedPromiseState is not pending');\r\n    writer._closedPromise = Promise.reject(reason);\r\n    writer._closedPromiseState = 'rejected';\r\n  }\r\n  function defaultWriterClosedPromiseResolve(writer) {\r\n    assert(writer._closedPromise_resolve !== undefined, 'writer._closedPromise_resolve !== undefined');\r\n    assert(writer._closedPromise_reject !== undefined, 'writer._closedPromise_reject !== undefined');\r\n    assert(writer._closedPromiseState === 'pending', 'writer._closedPromiseState is pending');\r\n    writer._closedPromise_resolve(undefined);\r\n    writer._closedPromise_resolve = undefined;\r\n    writer._closedPromise_reject = undefined;\r\n    writer._closedPromiseState = 'resolved';\r\n  }\r\n  function defaultWriterReadyPromiseInitialize(writer) {\r\n    writer._readyPromise = new Promise(function (resolve, reject) {\r\n      writer._readyPromise_resolve = resolve;\r\n      writer._readyPromise_reject = reject;\r\n    });\r\n    writer._readyPromiseState = 'pending';\r\n  }\r\n  function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\r\n    writer._readyPromise = Promise.reject(reason);\r\n    writer._readyPromise_resolve = undefined;\r\n    writer._readyPromise_reject = undefined;\r\n    writer._readyPromiseState = 'rejected';\r\n  }\r\n  function defaultWriterReadyPromiseInitializeAsResolved(writer) {\r\n    writer._readyPromise = Promise.resolve(undefined);\r\n    writer._readyPromise_resolve = undefined;\r\n    writer._readyPromise_reject = undefined;\r\n    writer._readyPromiseState = 'fulfilled';\r\n  }\r\n  function defaultWriterReadyPromiseReject(writer, reason) {\r\n    assert(writer._readyPromise_resolve !== undefined, 'writer._readyPromise_resolve !== undefined');\r\n    assert(writer._readyPromise_reject !== undefined, 'writer._readyPromise_reject !== undefined');\r\n    writer._readyPromise_reject(reason);\r\n    writer._readyPromise_resolve = undefined;\r\n    writer._readyPromise_reject = undefined;\r\n    writer._readyPromiseState = 'rejected';\r\n  }\r\n  function defaultWriterReadyPromiseReset(writer) {\r\n    assert(writer._readyPromise_resolve === undefined, 'writer._readyPromise_resolve === undefined');\r\n    assert(writer._readyPromise_reject === undefined, 'writer._readyPromise_reject === undefined');\r\n    writer._readyPromise = new Promise(function (resolve, reject) {\r\n      writer._readyPromise_resolve = resolve;\r\n      writer._readyPromise_reject = reject;\r\n    });\r\n    writer._readyPromiseState = 'pending';\r\n  }\r\n  function defaultWriterReadyPromiseResetToRejected(writer, reason) {\r\n    assert(writer._readyPromise_resolve === undefined, 'writer._readyPromise_resolve === undefined');\r\n    assert(writer._readyPromise_reject === undefined, 'writer._readyPromise_reject === undefined');\r\n    writer._readyPromise = Promise.reject(reason);\r\n    writer._readyPromiseState = 'rejected';\r\n  }\r\n  function defaultWriterReadyPromiseResolve(writer) {\r\n    assert(writer._readyPromise_resolve !== undefined, 'writer._readyPromise_resolve !== undefined');\r\n    assert(writer._readyPromise_reject !== undefined, 'writer._readyPromise_reject !== undefined');\r\n    writer._readyPromise_resolve(undefined);\r\n    writer._readyPromise_resolve = undefined;\r\n    writer._readyPromise_reject = undefined;\r\n    writer._readyPromiseState = 'fulfilled';\r\n  }\r\n}, function (module, exports, __w_pdfjs_require__) {\r\n  \"use strict\";\r\n\r\n  var _require = __w_pdfjs_require__(0),\r\n      IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;\r\n  var _require2 = __w_pdfjs_require__(1),\r\n      assert = _require2.assert;\r\n  exports.DequeueValue = function (container) {\r\n    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: DequeueValue should only be used on containers with [[queue]] and [[queueTotalSize]].');\r\n    assert(container._queue.length > 0, 'Spec-level failure: should never dequeue from an empty queue.');\r\n    var pair = container._queue.shift();\r\n    container._queueTotalSize -= pair.size;\r\n    if (container._queueTotalSize < 0) {\r\n      container._queueTotalSize = 0;\r\n    }\r\n    return pair.value;\r\n  };\r\n  exports.EnqueueValueWithSize = function (container, value, size) {\r\n    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: EnqueueValueWithSize should only be used on containers with [[queue]] and ' + '[[queueTotalSize]].');\r\n    size = Number(size);\r\n    if (!IsFiniteNonNegativeNumber(size)) {\r\n      throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\r\n    }\r\n    container._queue.push({\r\n      value: value,\r\n      size: size\r\n    });\r\n    container._queueTotalSize += size;\r\n  };\r\n  exports.PeekQueueValue = function (container) {\r\n    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: PeekQueueValue should only be used on containers with [[queue]] and [[queueTotalSize]].');\r\n    assert(container._queue.length > 0, 'Spec-level failure: should never peek at an empty queue.');\r\n    var pair = container._queue[0];\r\n    return pair.value;\r\n  };\r\n  exports.ResetQueue = function (container) {\r\n    assert('_queue' in container && '_queueTotalSize' in container, 'Spec-level failure: ResetQueue should only be used on containers with [[queue]] and [[queueTotalSize]].');\r\n    container._queue = [];\r\n    container._queueTotalSize = 0;\r\n  };\r\n}, function (module, exports, __w_pdfjs_require__) {\r\n  \"use strict\";\r\n\r\n  var _createClass = function () {\r\n    function defineProperties(target, props) {\r\n      for (var i = 0; i < props.length; i++) {\r\n        var descriptor = props[i];\r\n        descriptor.enumerable = descriptor.enumerable || false;\r\n        descriptor.configurable = true;\r\n        if (\"value\" in descriptor) descriptor.writable = true;\r\n        Object.defineProperty(target, descriptor.key, descriptor);\r\n      }\r\n    }\r\n    return function (Constructor, protoProps, staticProps) {\r\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\r\n      if (staticProps) defineProperties(Constructor, staticProps);\r\n      return Constructor;\r\n    };\r\n  }();\r\n  function _classCallCheck(instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError(\"Cannot call a class as a function\");\r\n    }\r\n  }\r\n  var _require = __w_pdfjs_require__(0),\r\n      ArrayBufferCopy = _require.ArrayBufferCopy,\r\n      CreateIterResultObject = _require.CreateIterResultObject,\r\n      IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber,\r\n      InvokeOrNoop = _require.InvokeOrNoop,\r\n      PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop,\r\n      TransferArrayBuffer = _require.TransferArrayBuffer,\r\n      ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy,\r\n      ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark;\r\n  var _require2 = __w_pdfjs_require__(0),\r\n      createArrayFromList = _require2.createArrayFromList,\r\n      createDataProperty = _require2.createDataProperty,\r\n      typeIsObject = _require2.typeIsObject;\r\n  var _require3 = __w_pdfjs_require__(1),\r\n      assert = _require3.assert,\r\n      rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection;\r\n  var _require4 = __w_pdfjs_require__(3),\r\n      DequeueValue = _require4.DequeueValue,\r\n      EnqueueValueWithSize = _require4.EnqueueValueWithSize,\r\n      ResetQueue = _require4.ResetQueue;\r\n  var _require5 = __w_pdfjs_require__(2),\r\n      AcquireWritableStreamDefaultWriter = _require5.AcquireWritableStreamDefaultWriter,\r\n      IsWritableStream = _require5.IsWritableStream,\r\n      IsWritableStreamLocked = _require5.IsWritableStreamLocked,\r\n      WritableStreamAbort = _require5.WritableStreamAbort,\r\n      WritableStreamDefaultWriterCloseWithErrorPropagation = _require5.WritableStreamDefaultWriterCloseWithErrorPropagation,\r\n      WritableStreamDefaultWriterRelease = _require5.WritableStreamDefaultWriterRelease,\r\n      WritableStreamDefaultWriterWrite = _require5.WritableStreamDefaultWriterWrite,\r\n      WritableStreamCloseQueuedOrInFlight = _require5.WritableStreamCloseQueuedOrInFlight;\r\n  var ReadableStream = function () {\r\n    function ReadableStream() {\r\n      var underlyingSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n          size = _ref.size,\r\n          highWaterMark = _ref.highWaterMark;\r\n      _classCallCheck(this, ReadableStream);\r\n      this._state = 'readable';\r\n      this._reader = undefined;\r\n      this._storedError = undefined;\r\n      this._disturbed = false;\r\n      this._readableStreamController = undefined;\r\n      var type = underlyingSource.type;\r\n      var typeString = String(type);\r\n      if (typeString === 'bytes') {\r\n        if (highWaterMark === undefined) {\r\n          highWaterMark = 0;\r\n        }\r\n        this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);\r\n      } else if (type === undefined) {\r\n        if (highWaterMark === undefined) {\r\n          highWaterMark = 1;\r\n        }\r\n        this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);\r\n      } else {\r\n        throw new RangeError('Invalid type is specified');\r\n      }\r\n    }\r\n    _createClass(ReadableStream, [{\r\n      key: 'cancel',\r\n      value: function cancel(reason) {\r\n        if (IsReadableStream(this) === false) {\r\n          return Promise.reject(streamBrandCheckException('cancel'));\r\n        }\r\n        if (IsReadableStreamLocked(this) === true) {\r\n          return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\r\n        }\r\n        return ReadableStreamCancel(this, reason);\r\n      }\r\n    }, {\r\n      key: 'getReader',\r\n      value: function getReader() {\r\n        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n            mode = _ref2.mode;\r\n        if (IsReadableStream(this) === false) {\r\n          throw streamBrandCheckException('getReader');\r\n        }\r\n        if (mode === undefined) {\r\n          return AcquireReadableStreamDefaultReader(this);\r\n        }\r\n        mode = String(mode);\r\n        if (mode === 'byob') {\r\n          return AcquireReadableStreamBYOBReader(this);\r\n        }\r\n        throw new RangeError('Invalid mode is specified');\r\n      }\r\n    }, {\r\n      key: 'pipeThrough',\r\n      value: function pipeThrough(_ref3, options) {\r\n        var writable = _ref3.writable,\r\n            readable = _ref3.readable;\r\n        var promise = this.pipeTo(writable, options);\r\n        ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\r\n        return readable;\r\n      }\r\n    }, {\r\n      key: 'pipeTo',\r\n      value: function pipeTo(dest) {\r\n        var _this = this;\r\n        var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n            preventClose = _ref4.preventClose,\r\n            preventAbort = _ref4.preventAbort,\r\n            preventCancel = _ref4.preventCancel;\r\n        if (IsReadableStream(this) === false) {\r\n          return Promise.reject(streamBrandCheckException('pipeTo'));\r\n        }\r\n        if (IsWritableStream(dest) === false) {\r\n          return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\r\n        }\r\n        preventClose = Boolean(preventClose);\r\n        preventAbort = Boolean(preventAbort);\r\n        preventCancel = Boolean(preventCancel);\r\n        if (IsReadableStreamLocked(this) === true) {\r\n          return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\r\n        }\r\n        if (IsWritableStreamLocked(dest) === true) {\r\n          return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\r\n        }\r\n        var reader = AcquireReadableStreamDefaultReader(this);\r\n        var writer = AcquireWritableStreamDefaultWriter(dest);\r\n        var shuttingDown = false;\r\n        var currentWrite = Promise.resolve();\r\n        return new Promise(function (resolve, reject) {\r\n          function pipeLoop() {\r\n            currentWrite = Promise.resolve();\r\n            if (shuttingDown === true) {\r\n              return Promise.resolve();\r\n            }\r\n            return writer._readyPromise.then(function () {\r\n              return ReadableStreamDefaultReaderRead(reader).then(function (_ref5) {\r\n                var value = _ref5.value,\r\n                    done = _ref5.done;\r\n                if (done === true) {\r\n                  return;\r\n                }\r\n                currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(function () {});\r\n              });\r\n            }).then(pipeLoop);\r\n          }\r\n          isOrBecomesErrored(_this, reader._closedPromise, function (storedError) {\r\n            if (preventAbort === false) {\r\n              shutdownWithAction(function () {\r\n                return WritableStreamAbort(dest, storedError);\r\n              }, true, storedError);\r\n            } else {\r\n              shutdown(true, storedError);\r\n            }\r\n          });\r\n          isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {\r\n            if (preventCancel === false) {\r\n              shutdownWithAction(function () {\r\n                return ReadableStreamCancel(_this, storedError);\r\n              }, true, storedError);\r\n            } else {\r\n              shutdown(true, storedError);\r\n            }\r\n          });\r\n          isOrBecomesClosed(_this, reader._closedPromise, function () {\r\n            if (preventClose === false) {\r\n              shutdownWithAction(function () {\r\n                return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);\r\n              });\r\n            } else {\r\n              shutdown();\r\n            }\r\n          });\r\n          if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\r\n            var destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\r\n            if (preventCancel === false) {\r\n              shutdownWithAction(function () {\r\n                return ReadableStreamCancel(_this, destClosed);\r\n              }, true, destClosed);\r\n            } else {\r\n              shutdown(true, destClosed);\r\n            }\r\n          }\r\n          pipeLoop().catch(function (err) {\r\n            currentWrite = Promise.resolve();\r\n            rethrowAssertionErrorRejection(err);\r\n          });\r\n          function waitForWritesToFinish() {\r\n            var oldCurrentWrite = currentWrite;\r\n            return currentWrite.then(function () {\r\n              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;\r\n            });\r\n          }\r\n          function isOrBecomesErrored(stream, promise, action) {\r\n            if (stream._state === 'errored') {\r\n              action(stream._storedError);\r\n            } else {\r\n              promise.catch(action).catch(rethrowAssertionErrorRejection);\r\n            }\r\n          }\r\n          function isOrBecomesClosed(stream, promise, action) {\r\n            if (stream._state === 'closed') {\r\n              action();\r\n            } else {\r\n              promise.then(action).catch(rethrowAssertionErrorRejection);\r\n            }\r\n          }\r\n          function shutdownWithAction(action, originalIsError, originalError) {\r\n            if (shuttingDown === true) {\r\n              return;\r\n            }\r\n            shuttingDown = true;\r\n            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n              waitForWritesToFinish().then(doTheRest);\r\n            } else {\r\n              doTheRest();\r\n            }\r\n            function doTheRest() {\r\n              action().then(function () {\r\n                return finalize(originalIsError, originalError);\r\n              }, function (newError) {\r\n                return finalize(true, newError);\r\n              }).catch(rethrowAssertionErrorRejection);\r\n            }\r\n          }\r\n          function shutdown(isError, error) {\r\n            if (shuttingDown === true) {\r\n              return;\r\n            }\r\n            shuttingDown = true;\r\n            if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\r\n              waitForWritesToFinish().then(function () {\r\n                return finalize(isError, error);\r\n              }).catch(rethrowAssertionErrorRejection);\r\n            } else {\r\n              finalize(isError, error);\r\n            }\r\n          }\r\n          function finalize(isError, error) {\r\n            WritableStreamDefaultWriterRelease(writer);\r\n            ReadableStreamReaderGenericRelease(reader);\r\n            if (isError) {\r\n              reject(error);\r\n            } else {\r\n              resolve(undefined);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }, {\r\n      key: 'tee',\r\n      value: function tee() {\r\n        if (IsReadableStream(this) === false) {\r\n          throw streamBrandCheckException('tee');\r\n        }\r\n        var branches = ReadableStreamTee(this, false);\r\n        return createArrayFromList(branches);\r\n      }\r\n    }, {\r\n      key: 'locked',\r\n      get: function get() {\r\n        if (IsReadableStream(this) === false) {\r\n          throw streamBrandCheckException('locked');\r\n        }\r\n        return IsReadableStreamLocked(this);\r\n      }\r\n    }]);\r\n    return ReadableStream;\r\n  }();\r\n  module.exports = {\r\n    ReadableStream: ReadableStream,\r\n    IsReadableStreamDisturbed: IsReadableStreamDisturbed,\r\n    ReadableStreamDefaultControllerClose: ReadableStreamDefaultControllerClose,\r\n    ReadableStreamDefaultControllerEnqueue: ReadableStreamDefaultControllerEnqueue,\r\n    ReadableStreamDefaultControllerError: ReadableStreamDefaultControllerError,\r\n    ReadableStreamDefaultControllerGetDesiredSize: ReadableStreamDefaultControllerGetDesiredSize\r\n  };\r\n  function AcquireReadableStreamBYOBReader(stream) {\r\n    return new ReadableStreamBYOBReader(stream);\r\n  }\r\n  function AcquireReadableStreamDefaultReader(stream) {\r\n    return new ReadableStreamDefaultReader(stream);\r\n  }\r\n  function IsReadableStream(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function IsReadableStreamDisturbed(stream) {\r\n    assert(IsReadableStream(stream) === true, 'IsReadableStreamDisturbed should only be used on known readable streams');\r\n    return stream._disturbed;\r\n  }\r\n  function IsReadableStreamLocked(stream) {\r\n    assert(IsReadableStream(stream) === true, 'IsReadableStreamLocked should only be used on known readable streams');\r\n    if (stream._reader === undefined) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function ReadableStreamTee(stream, cloneForBranch2) {\r\n    assert(IsReadableStream(stream) === true);\r\n    assert(typeof cloneForBranch2 === 'boolean');\r\n    var reader = AcquireReadableStreamDefaultReader(stream);\r\n    var teeState = {\r\n      closedOrErrored: false,\r\n      canceled1: false,\r\n      canceled2: false,\r\n      reason1: undefined,\r\n      reason2: undefined\r\n    };\r\n    teeState.promise = new Promise(function (resolve) {\r\n      teeState._resolve = resolve;\r\n    });\r\n    var pull = create_ReadableStreamTeePullFunction();\r\n    pull._reader = reader;\r\n    pull._teeState = teeState;\r\n    pull._cloneForBranch2 = cloneForBranch2;\r\n    var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();\r\n    cancel1._stream = stream;\r\n    cancel1._teeState = teeState;\r\n    var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();\r\n    cancel2._stream = stream;\r\n    cancel2._teeState = teeState;\r\n    var underlyingSource1 = Object.create(Object.prototype);\r\n    createDataProperty(underlyingSource1, 'pull', pull);\r\n    createDataProperty(underlyingSource1, 'cancel', cancel1);\r\n    var branch1Stream = new ReadableStream(underlyingSource1);\r\n    var underlyingSource2 = Object.create(Object.prototype);\r\n    createDataProperty(underlyingSource2, 'pull', pull);\r\n    createDataProperty(underlyingSource2, 'cancel', cancel2);\r\n    var branch2Stream = new ReadableStream(underlyingSource2);\r\n    pull._branch1 = branch1Stream._readableStreamController;\r\n    pull._branch2 = branch2Stream._readableStreamController;\r\n    reader._closedPromise.catch(function (r) {\r\n      if (teeState.closedOrErrored === true) {\r\n        return;\r\n      }\r\n      ReadableStreamDefaultControllerError(pull._branch1, r);\r\n      ReadableStreamDefaultControllerError(pull._branch2, r);\r\n      teeState.closedOrErrored = true;\r\n    });\r\n    return [branch1Stream, branch2Stream];\r\n  }\r\n  function create_ReadableStreamTeePullFunction() {\r\n    function f() {\r\n      var reader = f._reader,\r\n          branch1 = f._branch1,\r\n          branch2 = f._branch2,\r\n          teeState = f._teeState;\r\n      return ReadableStreamDefaultReaderRead(reader).then(function (result) {\r\n        assert(typeIsObject(result));\r\n        var value = result.value;\r\n        var done = result.done;\r\n        assert(typeof done === 'boolean');\r\n        if (done === true && teeState.closedOrErrored === false) {\r\n          if (teeState.canceled1 === false) {\r\n            ReadableStreamDefaultControllerClose(branch1);\r\n          }\r\n          if (teeState.canceled2 === false) {\r\n            ReadableStreamDefaultControllerClose(branch2);\r\n          }\r\n          teeState.closedOrErrored = true;\r\n        }\r\n        if (teeState.closedOrErrored === true) {\r\n          return;\r\n        }\r\n        var value1 = value;\r\n        var value2 = value;\r\n        if (teeState.canceled1 === false) {\r\n          ReadableStreamDefaultControllerEnqueue(branch1, value1);\r\n        }\r\n        if (teeState.canceled2 === false) {\r\n          ReadableStreamDefaultControllerEnqueue(branch2, value2);\r\n        }\r\n      });\r\n    }\r\n    return f;\r\n  }\r\n  function create_ReadableStreamTeeBranch1CancelFunction() {\r\n    function f(reason) {\r\n      var stream = f._stream,\r\n          teeState = f._teeState;\r\n      teeState.canceled1 = true;\r\n      teeState.reason1 = reason;\r\n      if (teeState.canceled2 === true) {\r\n        var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);\r\n        var cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n        teeState._resolve(cancelResult);\r\n      }\r\n      return teeState.promise;\r\n    }\r\n    return f;\r\n  }\r\n  function create_ReadableStreamTeeBranch2CancelFunction() {\r\n    function f(reason) {\r\n      var stream = f._stream,\r\n          teeState = f._teeState;\r\n      teeState.canceled2 = true;\r\n      teeState.reason2 = reason;\r\n      if (teeState.canceled1 === true) {\r\n        var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);\r\n        var cancelResult = ReadableStreamCancel(stream, compositeReason);\r\n        teeState._resolve(cancelResult);\r\n      }\r\n      return teeState.promise;\r\n    }\r\n    return f;\r\n  }\r\n  function ReadableStreamAddReadIntoRequest(stream) {\r\n    assert(IsReadableStreamBYOBReader(stream._reader) === true);\r\n    assert(stream._state === 'readable' || stream._state === 'closed');\r\n    var promise = new Promise(function (resolve, reject) {\r\n      var readIntoRequest = {\r\n        _resolve: resolve,\r\n        _reject: reject\r\n      };\r\n      stream._reader._readIntoRequests.push(readIntoRequest);\r\n    });\r\n    return promise;\r\n  }\r\n  function ReadableStreamAddReadRequest(stream) {\r\n    assert(IsReadableStreamDefaultReader(stream._reader) === true);\r\n    assert(stream._state === 'readable');\r\n    var promise = new Promise(function (resolve, reject) {\r\n      var readRequest = {\r\n        _resolve: resolve,\r\n        _reject: reject\r\n      };\r\n      stream._reader._readRequests.push(readRequest);\r\n    });\r\n    return promise;\r\n  }\r\n  function ReadableStreamCancel(stream, reason) {\r\n    stream._disturbed = true;\r\n    if (stream._state === 'closed') {\r\n      return Promise.resolve(undefined);\r\n    }\r\n    if (stream._state === 'errored') {\r\n      return Promise.reject(stream._storedError);\r\n    }\r\n    ReadableStreamClose(stream);\r\n    var sourceCancelPromise = stream._readableStreamController.__cancelSteps(reason);\r\n    return sourceCancelPromise.then(function () {\r\n      return undefined;\r\n    });\r\n  }\r\n  function ReadableStreamClose(stream) {\r\n    assert(stream._state === 'readable');\r\n    stream._state = 'closed';\r\n    var reader = stream._reader;\r\n    if (reader === undefined) {\r\n      return undefined;\r\n    }\r\n    if (IsReadableStreamDefaultReader(reader) === true) {\r\n      for (var i = 0; i < reader._readRequests.length; i++) {\r\n        var _resolve = reader._readRequests[i]._resolve;\r\n        _resolve(CreateIterResultObject(undefined, true));\r\n      }\r\n      reader._readRequests = [];\r\n    }\r\n    defaultReaderClosedPromiseResolve(reader);\r\n    return undefined;\r\n  }\r\n  function ReadableStreamError(stream, e) {\r\n    assert(IsReadableStream(stream) === true, 'stream must be ReadableStream');\r\n    assert(stream._state === 'readable', 'state must be readable');\r\n    stream._state = 'errored';\r\n    stream._storedError = e;\r\n    var reader = stream._reader;\r\n    if (reader === undefined) {\r\n      return undefined;\r\n    }\r\n    if (IsReadableStreamDefaultReader(reader) === true) {\r\n      for (var i = 0; i < reader._readRequests.length; i++) {\r\n        var readRequest = reader._readRequests[i];\r\n        readRequest._reject(e);\r\n      }\r\n      reader._readRequests = [];\r\n    } else {\r\n      assert(IsReadableStreamBYOBReader(reader), 'reader must be ReadableStreamBYOBReader');\r\n      for (var _i = 0; _i < reader._readIntoRequests.length; _i++) {\r\n        var readIntoRequest = reader._readIntoRequests[_i];\r\n        readIntoRequest._reject(e);\r\n      }\r\n      reader._readIntoRequests = [];\r\n    }\r\n    defaultReaderClosedPromiseReject(reader, e);\r\n    reader._closedPromise.catch(function () {});\r\n  }\r\n  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\r\n    var reader = stream._reader;\r\n    assert(reader._readIntoRequests.length > 0);\r\n    var readIntoRequest = reader._readIntoRequests.shift();\r\n    readIntoRequest._resolve(CreateIterResultObject(chunk, done));\r\n  }\r\n  function ReadableStreamFulfillReadRequest(stream, chunk, done) {\r\n    var reader = stream._reader;\r\n    assert(reader._readRequests.length > 0);\r\n    var readRequest = reader._readRequests.shift();\r\n    readRequest._resolve(CreateIterResultObject(chunk, done));\r\n  }\r\n  function ReadableStreamGetNumReadIntoRequests(stream) {\r\n    return stream._reader._readIntoRequests.length;\r\n  }\r\n  function ReadableStreamGetNumReadRequests(stream) {\r\n    return stream._reader._readRequests.length;\r\n  }\r\n  function ReadableStreamHasBYOBReader(stream) {\r\n    var reader = stream._reader;\r\n    if (reader === undefined) {\r\n      return false;\r\n    }\r\n    if (IsReadableStreamBYOBReader(reader) === false) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function ReadableStreamHasDefaultReader(stream) {\r\n    var reader = stream._reader;\r\n    if (reader === undefined) {\r\n      return false;\r\n    }\r\n    if (IsReadableStreamDefaultReader(reader) === false) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  var ReadableStreamDefaultReader = function () {\r\n    function ReadableStreamDefaultReader(stream) {\r\n      _classCallCheck(this, ReadableStreamDefaultReader);\r\n      if (IsReadableStream(stream) === false) {\r\n        throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\r\n      }\r\n      if (IsReadableStreamLocked(stream) === true) {\r\n        throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n      }\r\n      ReadableStreamReaderGenericInitialize(this, stream);\r\n      this._readRequests = [];\r\n    }\r\n    _createClass(ReadableStreamDefaultReader, [{\r\n      key: 'cancel',\r\n      value: function cancel(reason) {\r\n        if (IsReadableStreamDefaultReader(this) === false) {\r\n          return Promise.reject(defaultReaderBrandCheckException('cancel'));\r\n        }\r\n        if (this._ownerReadableStream === undefined) {\r\n          return Promise.reject(readerLockException('cancel'));\r\n        }\r\n        return ReadableStreamReaderGenericCancel(this, reason);\r\n      }\r\n    }, {\r\n      key: 'read',\r\n      value: function read() {\r\n        if (IsReadableStreamDefaultReader(this) === false) {\r\n          return Promise.reject(defaultReaderBrandCheckException('read'));\r\n        }\r\n        if (this._ownerReadableStream === undefined) {\r\n          return Promise.reject(readerLockException('read from'));\r\n        }\r\n        return ReadableStreamDefaultReaderRead(this);\r\n      }\r\n    }, {\r\n      key: 'releaseLock',\r\n      value: function releaseLock() {\r\n        if (IsReadableStreamDefaultReader(this) === false) {\r\n          throw defaultReaderBrandCheckException('releaseLock');\r\n        }\r\n        if (this._ownerReadableStream === undefined) {\r\n          return;\r\n        }\r\n        if (this._readRequests.length > 0) {\r\n          throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n        }\r\n        ReadableStreamReaderGenericRelease(this);\r\n      }\r\n    }, {\r\n      key: 'closed',\r\n      get: function get() {\r\n        if (IsReadableStreamDefaultReader(this) === false) {\r\n          return Promise.reject(defaultReaderBrandCheckException('closed'));\r\n        }\r\n        return this._closedPromise;\r\n      }\r\n    }]);\r\n    return ReadableStreamDefaultReader;\r\n  }();\r\n  var ReadableStreamBYOBReader = function () {\r\n    function ReadableStreamBYOBReader(stream) {\r\n      _classCallCheck(this, ReadableStreamBYOBReader);\r\n      if (!IsReadableStream(stream)) {\r\n        throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source');\r\n      }\r\n      if (IsReadableByteStreamController(stream._readableStreamController) === false) {\r\n        throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');\r\n      }\r\n      if (IsReadableStreamLocked(stream)) {\r\n        throw new TypeError('This stream has already been locked for exclusive reading by another reader');\r\n      }\r\n      ReadableStreamReaderGenericInitialize(this, stream);\r\n      this._readIntoRequests = [];\r\n    }\r\n    _createClass(ReadableStreamBYOBReader, [{\r\n      key: 'cancel',\r\n      value: function cancel(reason) {\r\n        if (!IsReadableStreamBYOBReader(this)) {\r\n          return Promise.reject(byobReaderBrandCheckException('cancel'));\r\n        }\r\n        if (this._ownerReadableStream === undefined) {\r\n          return Promise.reject(readerLockException('cancel'));\r\n        }\r\n        return ReadableStreamReaderGenericCancel(this, reason);\r\n      }\r\n    }, {\r\n      key: 'read',\r\n      value: function read(view) {\r\n        if (!IsReadableStreamBYOBReader(this)) {\r\n          return Promise.reject(byobReaderBrandCheckException('read'));\r\n        }\r\n        if (this._ownerReadableStream === undefined) {\r\n          return Promise.reject(readerLockException('read from'));\r\n        }\r\n        if (!ArrayBuffer.isView(view)) {\r\n          return Promise.reject(new TypeError('view must be an array buffer view'));\r\n        }\r\n        if (view.byteLength === 0) {\r\n          return Promise.reject(new TypeError('view must have non-zero byteLength'));\r\n        }\r\n        return ReadableStreamBYOBReaderRead(this, view);\r\n      }\r\n    }, {\r\n      key: 'releaseLock',\r\n      value: function releaseLock() {\r\n        if (!IsReadableStreamBYOBReader(this)) {\r\n          throw byobReaderBrandCheckException('releaseLock');\r\n        }\r\n        if (this._ownerReadableStream === undefined) {\r\n          return;\r\n        }\r\n        if (this._readIntoRequests.length > 0) {\r\n          throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\r\n        }\r\n        ReadableStreamReaderGenericRelease(this);\r\n      }\r\n    }, {\r\n      key: 'closed',\r\n      get: function get() {\r\n        if (!IsReadableStreamBYOBReader(this)) {\r\n          return Promise.reject(byobReaderBrandCheckException('closed'));\r\n        }\r\n        return this._closedPromise;\r\n      }\r\n    }]);\r\n    return ReadableStreamBYOBReader;\r\n  }();\r\n  function IsReadableStreamBYOBReader(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function IsReadableStreamDefaultReader(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function ReadableStreamReaderGenericInitialize(reader, stream) {\r\n    reader._ownerReadableStream = stream;\r\n    stream._reader = reader;\r\n    if (stream._state === 'readable') {\r\n      defaultReaderClosedPromiseInitialize(reader);\r\n    } else if (stream._state === 'closed') {\r\n      defaultReaderClosedPromiseInitializeAsResolved(reader);\r\n    } else {\r\n      assert(stream._state === 'errored', 'state must be errored');\r\n      defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\r\n      reader._closedPromise.catch(function () {});\r\n    }\r\n  }\r\n  function ReadableStreamReaderGenericCancel(reader, reason) {\r\n    var stream = reader._ownerReadableStream;\r\n    assert(stream !== undefined);\r\n    return ReadableStreamCancel(stream, reason);\r\n  }\r\n  function ReadableStreamReaderGenericRelease(reader) {\r\n    assert(reader._ownerReadableStream !== undefined);\r\n    assert(reader._ownerReadableStream._reader === reader);\r\n    if (reader._ownerReadableStream._state === 'readable') {\r\n      defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n    } else {\r\n      defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\r\n    }\r\n    reader._closedPromise.catch(function () {});\r\n    reader._ownerReadableStream._reader = undefined;\r\n    reader._ownerReadableStream = undefined;\r\n  }\r\n  function ReadableStreamBYOBReaderRead(reader, view) {\r\n    var stream = reader._ownerReadableStream;\r\n    assert(stream !== undefined);\r\n    stream._disturbed = true;\r\n    if (stream._state === 'errored') {\r\n      return Promise.reject(stream._storedError);\r\n    }\r\n    return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\r\n  }\r\n  function ReadableStreamDefaultReaderRead(reader) {\r\n    var stream = reader._ownerReadableStream;\r\n    assert(stream !== undefined);\r\n    stream._disturbed = true;\r\n    if (stream._state === 'closed') {\r\n      return Promise.resolve(CreateIterResultObject(undefined, true));\r\n    }\r\n    if (stream._state === 'errored') {\r\n      return Promise.reject(stream._storedError);\r\n    }\r\n    assert(stream._state === 'readable');\r\n    return stream._readableStreamController.__pullSteps();\r\n  }\r\n  var ReadableStreamDefaultController = function () {\r\n    function ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark) {\r\n      _classCallCheck(this, ReadableStreamDefaultController);\r\n      if (IsReadableStream(stream) === false) {\r\n        throw new TypeError('ReadableStreamDefaultController can only be constructed with a ReadableStream instance');\r\n      }\r\n      if (stream._readableStreamController !== undefined) {\r\n        throw new TypeError('ReadableStreamDefaultController instances can only be created by the ReadableStream constructor');\r\n      }\r\n      this._controlledReadableStream = stream;\r\n      this._underlyingSource = underlyingSource;\r\n      this._queue = undefined;\r\n      this._queueTotalSize = undefined;\r\n      ResetQueue(this);\r\n      this._started = false;\r\n      this._closeRequested = false;\r\n      this._pullAgain = false;\r\n      this._pulling = false;\r\n      var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\r\n      this._strategySize = normalizedStrategy.size;\r\n      this._strategyHWM = normalizedStrategy.highWaterMark;\r\n      var controller = this;\r\n      var startResult = InvokeOrNoop(underlyingSource, 'start', [this]);\r\n      Promise.resolve(startResult).then(function () {\r\n        controller._started = true;\r\n        assert(controller._pulling === false);\r\n        assert(controller._pullAgain === false);\r\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n      }, function (r) {\r\n        ReadableStreamDefaultControllerErrorIfNeeded(controller, r);\r\n      }).catch(rethrowAssertionErrorRejection);\r\n    }\r\n    _createClass(ReadableStreamDefaultController, [{\r\n      key: 'close',\r\n      value: function close() {\r\n        if (IsReadableStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('close');\r\n        }\r\n        if (this._closeRequested === true) {\r\n          throw new TypeError('The stream has already been closed; do not close it again!');\r\n        }\r\n        var state = this._controlledReadableStream._state;\r\n        if (state !== 'readable') {\r\n          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be closed');\r\n        }\r\n        ReadableStreamDefaultControllerClose(this);\r\n      }\r\n    }, {\r\n      key: 'enqueue',\r\n      value: function enqueue(chunk) {\r\n        if (IsReadableStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('enqueue');\r\n        }\r\n        if (this._closeRequested === true) {\r\n          throw new TypeError('stream is closed or draining');\r\n        }\r\n        var state = this._controlledReadableStream._state;\r\n        if (state !== 'readable') {\r\n          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be enqueued to');\r\n        }\r\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\r\n      }\r\n    }, {\r\n      key: 'error',\r\n      value: function error(e) {\r\n        if (IsReadableStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('error');\r\n        }\r\n        var stream = this._controlledReadableStream;\r\n        if (stream._state !== 'readable') {\r\n          throw new TypeError('The stream is ' + stream._state + ' and so cannot be errored');\r\n        }\r\n        ReadableStreamDefaultControllerError(this, e);\r\n      }\r\n    }, {\r\n      key: '__cancelSteps',\r\n      value: function __cancelSteps(reason) {\r\n        ResetQueue(this);\r\n        return PromiseInvokeOrNoop(this._underlyingSource, 'cancel', [reason]);\r\n      }\r\n    }, {\r\n      key: '__pullSteps',\r\n      value: function __pullSteps() {\r\n        var stream = this._controlledReadableStream;\r\n        if (this._queue.length > 0) {\r\n          var chunk = DequeueValue(this);\r\n          if (this._closeRequested === true && this._queue.length === 0) {\r\n            ReadableStreamClose(stream);\r\n          } else {\r\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n          }\r\n          return Promise.resolve(CreateIterResultObject(chunk, false));\r\n        }\r\n        var pendingPromise = ReadableStreamAddReadRequest(stream);\r\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\r\n        return pendingPromise;\r\n      }\r\n    }, {\r\n      key: 'desiredSize',\r\n      get: function get() {\r\n        if (IsReadableStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('desiredSize');\r\n        }\r\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\r\n      }\r\n    }]);\r\n    return ReadableStreamDefaultController;\r\n  }();\r\n  function IsReadableStreamDefaultController(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSource')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\r\n    var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\r\n    if (shouldPull === false) {\r\n      return undefined;\r\n    }\r\n    if (controller._pulling === true) {\r\n      controller._pullAgain = true;\r\n      return undefined;\r\n    }\r\n    assert(controller._pullAgain === false);\r\n    controller._pulling = true;\r\n    var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, 'pull', [controller]);\r\n    pullPromise.then(function () {\r\n      controller._pulling = false;\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n      }\r\n      return undefined;\r\n    }, function (e) {\r\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, e);\r\n    }).catch(rethrowAssertionErrorRejection);\r\n    return undefined;\r\n  }\r\n  function ReadableStreamDefaultControllerShouldCallPull(controller) {\r\n    var stream = controller._controlledReadableStream;\r\n    if (stream._state === 'closed' || stream._state === 'errored') {\r\n      return false;\r\n    }\r\n    if (controller._closeRequested === true) {\r\n      return false;\r\n    }\r\n    if (controller._started === false) {\r\n      return false;\r\n    }\r\n    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n      return true;\r\n    }\r\n    var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\r\n    if (desiredSize > 0) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  function ReadableStreamDefaultControllerClose(controller) {\r\n    var stream = controller._controlledReadableStream;\r\n    assert(controller._closeRequested === false);\r\n    assert(stream._state === 'readable');\r\n    controller._closeRequested = true;\r\n    if (controller._queue.length === 0) {\r\n      ReadableStreamClose(stream);\r\n    }\r\n  }\r\n  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\r\n    var stream = controller._controlledReadableStream;\r\n    assert(controller._closeRequested === false);\r\n    assert(stream._state === 'readable');\r\n    if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n      ReadableStreamFulfillReadRequest(stream, chunk, false);\r\n    } else {\r\n      var chunkSize = 1;\r\n      if (controller._strategySize !== undefined) {\r\n        var strategySize = controller._strategySize;\r\n        try {\r\n          chunkSize = strategySize(chunk);\r\n        } catch (chunkSizeE) {\r\n          ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\r\n          throw chunkSizeE;\r\n        }\r\n      }\r\n      try {\r\n        EnqueueValueWithSize(controller, chunk, chunkSize);\r\n      } catch (enqueueE) {\r\n        ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\r\n        throw enqueueE;\r\n      }\r\n    }\r\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\r\n    return undefined;\r\n  }\r\n  function ReadableStreamDefaultControllerError(controller, e) {\r\n    var stream = controller._controlledReadableStream;\r\n    assert(stream._state === 'readable');\r\n    ResetQueue(controller);\r\n    ReadableStreamError(stream, e);\r\n  }\r\n  function ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {\r\n    if (controller._controlledReadableStream._state === 'readable') {\r\n      ReadableStreamDefaultControllerError(controller, e);\r\n    }\r\n  }\r\n  function ReadableStreamDefaultControllerGetDesiredSize(controller) {\r\n    var stream = controller._controlledReadableStream;\r\n    var state = stream._state;\r\n    if (state === 'errored') {\r\n      return null;\r\n    }\r\n    if (state === 'closed') {\r\n      return 0;\r\n    }\r\n    return controller._strategyHWM - controller._queueTotalSize;\r\n  }\r\n  var ReadableStreamBYOBRequest = function () {\r\n    function ReadableStreamBYOBRequest(controller, view) {\r\n      _classCallCheck(this, ReadableStreamBYOBRequest);\r\n      this._associatedReadableByteStreamController = controller;\r\n      this._view = view;\r\n    }\r\n    _createClass(ReadableStreamBYOBRequest, [{\r\n      key: 'respond',\r\n      value: function respond(bytesWritten) {\r\n        if (IsReadableStreamBYOBRequest(this) === false) {\r\n          throw byobRequestBrandCheckException('respond');\r\n        }\r\n        if (this._associatedReadableByteStreamController === undefined) {\r\n          throw new TypeError('This BYOB request has been invalidated');\r\n        }\r\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\r\n      }\r\n    }, {\r\n      key: 'respondWithNewView',\r\n      value: function respondWithNewView(view) {\r\n        if (IsReadableStreamBYOBRequest(this) === false) {\r\n          throw byobRequestBrandCheckException('respond');\r\n        }\r\n        if (this._associatedReadableByteStreamController === undefined) {\r\n          throw new TypeError('This BYOB request has been invalidated');\r\n        }\r\n        if (!ArrayBuffer.isView(view)) {\r\n          throw new TypeError('You can only respond with array buffer views');\r\n        }\r\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\r\n      }\r\n    }, {\r\n      key: 'view',\r\n      get: function get() {\r\n        return this._view;\r\n      }\r\n    }]);\r\n    return ReadableStreamBYOBRequest;\r\n  }();\r\n  var ReadableByteStreamController = function () {\r\n    function ReadableByteStreamController(stream, underlyingByteSource, highWaterMark) {\r\n      _classCallCheck(this, ReadableByteStreamController);\r\n      if (IsReadableStream(stream) === false) {\r\n        throw new TypeError('ReadableByteStreamController can only be constructed with a ReadableStream instance given ' + 'a byte source');\r\n      }\r\n      if (stream._readableStreamController !== undefined) {\r\n        throw new TypeError('ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte ' + 'source');\r\n      }\r\n      this._controlledReadableStream = stream;\r\n      this._underlyingByteSource = underlyingByteSource;\r\n      this._pullAgain = false;\r\n      this._pulling = false;\r\n      ReadableByteStreamControllerClearPendingPullIntos(this);\r\n      this._queue = this._queueTotalSize = undefined;\r\n      ResetQueue(this);\r\n      this._closeRequested = false;\r\n      this._started = false;\r\n      this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\r\n      var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\r\n      if (autoAllocateChunkSize !== undefined) {\r\n        if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\r\n          throw new RangeError('autoAllocateChunkSize must be a positive integer');\r\n        }\r\n      }\r\n      this._autoAllocateChunkSize = autoAllocateChunkSize;\r\n      this._pendingPullIntos = [];\r\n      var controller = this;\r\n      var startResult = InvokeOrNoop(underlyingByteSource, 'start', [this]);\r\n      Promise.resolve(startResult).then(function () {\r\n        controller._started = true;\r\n        assert(controller._pulling === false);\r\n        assert(controller._pullAgain === false);\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      }, function (r) {\r\n        if (stream._state === 'readable') {\r\n          ReadableByteStreamControllerError(controller, r);\r\n        }\r\n      }).catch(rethrowAssertionErrorRejection);\r\n    }\r\n    _createClass(ReadableByteStreamController, [{\r\n      key: 'close',\r\n      value: function close() {\r\n        if (IsReadableByteStreamController(this) === false) {\r\n          throw byteStreamControllerBrandCheckException('close');\r\n        }\r\n        if (this._closeRequested === true) {\r\n          throw new TypeError('The stream has already been closed; do not close it again!');\r\n        }\r\n        var state = this._controlledReadableStream._state;\r\n        if (state !== 'readable') {\r\n          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be closed');\r\n        }\r\n        ReadableByteStreamControllerClose(this);\r\n      }\r\n    }, {\r\n      key: 'enqueue',\r\n      value: function enqueue(chunk) {\r\n        if (IsReadableByteStreamController(this) === false) {\r\n          throw byteStreamControllerBrandCheckException('enqueue');\r\n        }\r\n        if (this._closeRequested === true) {\r\n          throw new TypeError('stream is closed or draining');\r\n        }\r\n        var state = this._controlledReadableStream._state;\r\n        if (state !== 'readable') {\r\n          throw new TypeError('The stream (in ' + state + ' state) is not in the readable state and cannot be enqueued to');\r\n        }\r\n        if (!ArrayBuffer.isView(chunk)) {\r\n          throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\r\n        }\r\n        ReadableByteStreamControllerEnqueue(this, chunk);\r\n      }\r\n    }, {\r\n      key: 'error',\r\n      value: function error(e) {\r\n        if (IsReadableByteStreamController(this) === false) {\r\n          throw byteStreamControllerBrandCheckException('error');\r\n        }\r\n        var stream = this._controlledReadableStream;\r\n        if (stream._state !== 'readable') {\r\n          throw new TypeError('The stream is ' + stream._state + ' and so cannot be errored');\r\n        }\r\n        ReadableByteStreamControllerError(this, e);\r\n      }\r\n    }, {\r\n      key: '__cancelSteps',\r\n      value: function __cancelSteps(reason) {\r\n        if (this._pendingPullIntos.length > 0) {\r\n          var firstDescriptor = this._pendingPullIntos[0];\r\n          firstDescriptor.bytesFilled = 0;\r\n        }\r\n        ResetQueue(this);\r\n        return PromiseInvokeOrNoop(this._underlyingByteSource, 'cancel', [reason]);\r\n      }\r\n    }, {\r\n      key: '__pullSteps',\r\n      value: function __pullSteps() {\r\n        var stream = this._controlledReadableStream;\r\n        assert(ReadableStreamHasDefaultReader(stream) === true);\r\n        if (this._queueTotalSize > 0) {\r\n          assert(ReadableStreamGetNumReadRequests(stream) === 0);\r\n          var entry = this._queue.shift();\r\n          this._queueTotalSize -= entry.byteLength;\r\n          ReadableByteStreamControllerHandleQueueDrain(this);\r\n          var view = void 0;\r\n          try {\r\n            view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\r\n          } catch (viewE) {\r\n            return Promise.reject(viewE);\r\n          }\r\n          return Promise.resolve(CreateIterResultObject(view, false));\r\n        }\r\n        var autoAllocateChunkSize = this._autoAllocateChunkSize;\r\n        if (autoAllocateChunkSize !== undefined) {\r\n          var buffer = void 0;\r\n          try {\r\n            buffer = new ArrayBuffer(autoAllocateChunkSize);\r\n          } catch (bufferE) {\r\n            return Promise.reject(bufferE);\r\n          }\r\n          var pullIntoDescriptor = {\r\n            buffer: buffer,\r\n            byteOffset: 0,\r\n            byteLength: autoAllocateChunkSize,\r\n            bytesFilled: 0,\r\n            elementSize: 1,\r\n            ctor: Uint8Array,\r\n            readerType: 'default'\r\n          };\r\n          this._pendingPullIntos.push(pullIntoDescriptor);\r\n        }\r\n        var promise = ReadableStreamAddReadRequest(stream);\r\n        ReadableByteStreamControllerCallPullIfNeeded(this);\r\n        return promise;\r\n      }\r\n    }, {\r\n      key: 'byobRequest',\r\n      get: function get() {\r\n        if (IsReadableByteStreamController(this) === false) {\r\n          throw byteStreamControllerBrandCheckException('byobRequest');\r\n        }\r\n        if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\r\n          var firstDescriptor = this._pendingPullIntos[0];\r\n          var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\r\n          this._byobRequest = new ReadableStreamBYOBRequest(this, view);\r\n        }\r\n        return this._byobRequest;\r\n      }\r\n    }, {\r\n      key: 'desiredSize',\r\n      get: function get() {\r\n        if (IsReadableByteStreamController(this) === false) {\r\n          throw byteStreamControllerBrandCheckException('desiredSize');\r\n        }\r\n        return ReadableByteStreamControllerGetDesiredSize(this);\r\n      }\r\n    }]);\r\n    return ReadableByteStreamController;\r\n  }();\r\n  function IsReadableByteStreamController(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_underlyingByteSource')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function IsReadableStreamBYOBRequest(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function ReadableByteStreamControllerCallPullIfNeeded(controller) {\r\n    var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\r\n    if (shouldPull === false) {\r\n      return undefined;\r\n    }\r\n    if (controller._pulling === true) {\r\n      controller._pullAgain = true;\r\n      return undefined;\r\n    }\r\n    assert(controller._pullAgain === false);\r\n    controller._pulling = true;\r\n    var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, 'pull', [controller]);\r\n    pullPromise.then(function () {\r\n      controller._pulling = false;\r\n      if (controller._pullAgain === true) {\r\n        controller._pullAgain = false;\r\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n      }\r\n    }, function (e) {\r\n      if (controller._controlledReadableStream._state === 'readable') {\r\n        ReadableByteStreamControllerError(controller, e);\r\n      }\r\n    }).catch(rethrowAssertionErrorRejection);\r\n    return undefined;\r\n  }\r\n  function ReadableByteStreamControllerClearPendingPullIntos(controller) {\r\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n    controller._pendingPullIntos = [];\r\n  }\r\n  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\r\n    assert(stream._state !== 'errored', 'state must not be errored');\r\n    var done = false;\r\n    if (stream._state === 'closed') {\r\n      assert(pullIntoDescriptor.bytesFilled === 0);\r\n      done = true;\r\n    }\r\n    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n    if (pullIntoDescriptor.readerType === 'default') {\r\n      ReadableStreamFulfillReadRequest(stream, filledView, done);\r\n    } else {\r\n      assert(pullIntoDescriptor.readerType === 'byob');\r\n      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\r\n    }\r\n  }\r\n  function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\r\n    var bytesFilled = pullIntoDescriptor.bytesFilled;\r\n    var elementSize = pullIntoDescriptor.elementSize;\r\n    assert(bytesFilled <= pullIntoDescriptor.byteLength);\r\n    assert(bytesFilled % elementSize === 0);\r\n    return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\r\n  }\r\n  function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\r\n    controller._queue.push({\r\n      buffer: buffer,\r\n      byteOffset: byteOffset,\r\n      byteLength: byteLength\r\n    });\r\n    controller._queueTotalSize += byteLength;\r\n  }\r\n  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\r\n    var elementSize = pullIntoDescriptor.elementSize;\r\n    var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\r\n    var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\r\n    var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\r\n    var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\r\n    var totalBytesToCopyRemaining = maxBytesToCopy;\r\n    var ready = false;\r\n    if (maxAlignedBytes > currentAlignedBytes) {\r\n      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\r\n      ready = true;\r\n    }\r\n    var queue = controller._queue;\r\n    while (totalBytesToCopyRemaining > 0) {\r\n      var headOfQueue = queue[0];\r\n      var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\r\n      var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n      ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\r\n      if (headOfQueue.byteLength === bytesToCopy) {\r\n        queue.shift();\r\n      } else {\r\n        headOfQueue.byteOffset += bytesToCopy;\r\n        headOfQueue.byteLength -= bytesToCopy;\r\n      }\r\n      controller._queueTotalSize -= bytesToCopy;\r\n      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\r\n      totalBytesToCopyRemaining -= bytesToCopy;\r\n    }\r\n    if (ready === false) {\r\n      assert(controller._queueTotalSize === 0, 'queue must be empty');\r\n      assert(pullIntoDescriptor.bytesFilled > 0);\r\n      assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\r\n    }\r\n    return ready;\r\n  }\r\n  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\r\n    assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\r\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n    pullIntoDescriptor.bytesFilled += size;\r\n  }\r\n  function ReadableByteStreamControllerHandleQueueDrain(controller) {\r\n    assert(controller._controlledReadableStream._state === 'readable');\r\n    if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\r\n      ReadableStreamClose(controller._controlledReadableStream);\r\n    } else {\r\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n    }\r\n  }\r\n  function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\r\n    if (controller._byobRequest === undefined) {\r\n      return;\r\n    }\r\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\r\n    controller._byobRequest._view = undefined;\r\n    controller._byobRequest = undefined;\r\n  }\r\n  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\r\n    assert(controller._closeRequested === false);\r\n    while (controller._pendingPullIntos.length > 0) {\r\n      if (controller._queueTotalSize === 0) {\r\n        return;\r\n      }\r\n      var pullIntoDescriptor = controller._pendingPullIntos[0];\r\n      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);\r\n      }\r\n    }\r\n  }\r\n  function ReadableByteStreamControllerPullInto(controller, view) {\r\n    var stream = controller._controlledReadableStream;\r\n    var elementSize = 1;\r\n    if (view.constructor !== DataView) {\r\n      elementSize = view.constructor.BYTES_PER_ELEMENT;\r\n    }\r\n    var ctor = view.constructor;\r\n    var pullIntoDescriptor = {\r\n      buffer: view.buffer,\r\n      byteOffset: view.byteOffset,\r\n      byteLength: view.byteLength,\r\n      bytesFilled: 0,\r\n      elementSize: elementSize,\r\n      ctor: ctor,\r\n      readerType: 'byob'\r\n    };\r\n    if (controller._pendingPullIntos.length > 0) {\r\n      pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\r\n      controller._pendingPullIntos.push(pullIntoDescriptor);\r\n      return ReadableStreamAddReadIntoRequest(stream);\r\n    }\r\n    if (stream._state === 'closed') {\r\n      var emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\r\n      return Promise.resolve(CreateIterResultObject(emptyView, true));\r\n    }\r\n    if (controller._queueTotalSize > 0) {\r\n      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\r\n        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\r\n        ReadableByteStreamControllerHandleQueueDrain(controller);\r\n        return Promise.resolve(CreateIterResultObject(filledView, false));\r\n      }\r\n      if (controller._closeRequested === true) {\r\n        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n        ReadableByteStreamControllerError(controller, e);\r\n        return Promise.reject(e);\r\n      }\r\n    }\r\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\r\n    controller._pendingPullIntos.push(pullIntoDescriptor);\r\n    var promise = ReadableStreamAddReadIntoRequest(stream);\r\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\r\n    return promise;\r\n  }\r\n  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\r\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\r\n    assert(firstDescriptor.bytesFilled === 0, 'bytesFilled must be 0');\r\n    var stream = controller._controlledReadableStream;\r\n    if (ReadableStreamHasBYOBReader(stream) === true) {\r\n      while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n        var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\r\n      }\r\n    }\r\n  }\r\n  function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\r\n    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\r\n      throw new RangeError('bytesWritten out of range');\r\n    }\r\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\r\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\r\n      return;\r\n    }\r\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\r\n    var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\r\n    if (remainderSize > 0) {\r\n      var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\r\n      var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\r\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\r\n    }\r\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\r\n    pullIntoDescriptor.bytesFilled -= remainderSize;\r\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);\r\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n  }\r\n  function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\r\n    var firstDescriptor = controller._pendingPullIntos[0];\r\n    var stream = controller._controlledReadableStream;\r\n    if (stream._state === 'closed') {\r\n      if (bytesWritten !== 0) {\r\n        throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\r\n      }\r\n      ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\r\n    } else {\r\n      assert(stream._state === 'readable');\r\n      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\r\n    }\r\n  }\r\n  function ReadableByteStreamControllerShiftPendingPullInto(controller) {\r\n    var descriptor = controller._pendingPullIntos.shift();\r\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\r\n    return descriptor;\r\n  }\r\n  function ReadableByteStreamControllerShouldCallPull(controller) {\r\n    var stream = controller._controlledReadableStream;\r\n    if (stream._state !== 'readable') {\r\n      return false;\r\n    }\r\n    if (controller._closeRequested === true) {\r\n      return false;\r\n    }\r\n    if (controller._started === false) {\r\n      return false;\r\n    }\r\n    if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\r\n      return true;\r\n    }\r\n    if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\r\n      return true;\r\n    }\r\n    if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  function ReadableByteStreamControllerClose(controller) {\r\n    var stream = controller._controlledReadableStream;\r\n    assert(controller._closeRequested === false);\r\n    assert(stream._state === 'readable');\r\n    if (controller._queueTotalSize > 0) {\r\n      controller._closeRequested = true;\r\n      return;\r\n    }\r\n    if (controller._pendingPullIntos.length > 0) {\r\n      var firstPendingPullInto = controller._pendingPullIntos[0];\r\n      if (firstPendingPullInto.bytesFilled > 0) {\r\n        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\r\n        ReadableByteStreamControllerError(controller, e);\r\n        throw e;\r\n      }\r\n    }\r\n    ReadableStreamClose(stream);\r\n  }\r\n  function ReadableByteStreamControllerEnqueue(controller, chunk) {\r\n    var stream = controller._controlledReadableStream;\r\n    assert(controller._closeRequested === false);\r\n    assert(stream._state === 'readable');\r\n    var buffer = chunk.buffer;\r\n    var byteOffset = chunk.byteOffset;\r\n    var byteLength = chunk.byteLength;\r\n    var transferredBuffer = TransferArrayBuffer(buffer);\r\n    if (ReadableStreamHasDefaultReader(stream) === true) {\r\n      if (ReadableStreamGetNumReadRequests(stream) === 0) {\r\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n      } else {\r\n        assert(controller._queue.length === 0);\r\n        var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\r\n        ReadableStreamFulfillReadRequest(stream, transferredView, false);\r\n      }\r\n    } else if (ReadableStreamHasBYOBReader(stream) === true) {\r\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\r\n    } else {\r\n      assert(IsReadableStreamLocked(stream) === false, 'stream must not be locked');\r\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\r\n    }\r\n  }\r\n  function ReadableByteStreamControllerError(controller, e) {\r\n    var stream = controller._controlledReadableStream;\r\n    assert(stream._state === 'readable');\r\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\r\n    ResetQueue(controller);\r\n    ReadableStreamError(stream, e);\r\n  }\r\n  function ReadableByteStreamControllerGetDesiredSize(controller) {\r\n    var stream = controller._controlledReadableStream;\r\n    var state = stream._state;\r\n    if (state === 'errored') {\r\n      return null;\r\n    }\r\n    if (state === 'closed') {\r\n      return 0;\r\n    }\r\n    return controller._strategyHWM - controller._queueTotalSize;\r\n  }\r\n  function ReadableByteStreamControllerRespond(controller, bytesWritten) {\r\n    bytesWritten = Number(bytesWritten);\r\n    if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\r\n      throw new RangeError('bytesWritten must be a finite');\r\n    }\r\n    assert(controller._pendingPullIntos.length > 0);\r\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\r\n  }\r\n  function ReadableByteStreamControllerRespondWithNewView(controller, view) {\r\n    assert(controller._pendingPullIntos.length > 0);\r\n    var firstDescriptor = controller._pendingPullIntos[0];\r\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\r\n      throw new RangeError('The region specified by view does not match byobRequest');\r\n    }\r\n    if (firstDescriptor.byteLength !== view.byteLength) {\r\n      throw new RangeError('The buffer of view has different capacity than byobRequest');\r\n    }\r\n    firstDescriptor.buffer = view.buffer;\r\n    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\r\n  }\r\n  function streamBrandCheckException(name) {\r\n    return new TypeError('ReadableStream.prototype.' + name + ' can only be used on a ReadableStream');\r\n  }\r\n  function readerLockException(name) {\r\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\r\n  }\r\n  function defaultReaderBrandCheckException(name) {\r\n    return new TypeError('ReadableStreamDefaultReader.prototype.' + name + ' can only be used on a ReadableStreamDefaultReader');\r\n  }\r\n  function defaultReaderClosedPromiseInitialize(reader) {\r\n    reader._closedPromise = new Promise(function (resolve, reject) {\r\n      reader._closedPromise_resolve = resolve;\r\n      reader._closedPromise_reject = reject;\r\n    });\r\n  }\r\n  function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\r\n    reader._closedPromise = Promise.reject(reason);\r\n    reader._closedPromise_resolve = undefined;\r\n    reader._closedPromise_reject = undefined;\r\n  }\r\n  function defaultReaderClosedPromiseInitializeAsResolved(reader) {\r\n    reader._closedPromise = Promise.resolve(undefined);\r\n    reader._closedPromise_resolve = undefined;\r\n    reader._closedPromise_reject = undefined;\r\n  }\r\n  function defaultReaderClosedPromiseReject(reader, reason) {\r\n    assert(reader._closedPromise_resolve !== undefined);\r\n    assert(reader._closedPromise_reject !== undefined);\r\n    reader._closedPromise_reject(reason);\r\n    reader._closedPromise_resolve = undefined;\r\n    reader._closedPromise_reject = undefined;\r\n  }\r\n  function defaultReaderClosedPromiseResetToRejected(reader, reason) {\r\n    assert(reader._closedPromise_resolve === undefined);\r\n    assert(reader._closedPromise_reject === undefined);\r\n    reader._closedPromise = Promise.reject(reason);\r\n  }\r\n  function defaultReaderClosedPromiseResolve(reader) {\r\n    assert(reader._closedPromise_resolve !== undefined);\r\n    assert(reader._closedPromise_reject !== undefined);\r\n    reader._closedPromise_resolve(undefined);\r\n    reader._closedPromise_resolve = undefined;\r\n    reader._closedPromise_reject = undefined;\r\n  }\r\n  function byobReaderBrandCheckException(name) {\r\n    return new TypeError('ReadableStreamBYOBReader.prototype.' + name + ' can only be used on a ReadableStreamBYOBReader');\r\n  }\r\n  function defaultControllerBrandCheckException(name) {\r\n    return new TypeError('ReadableStreamDefaultController.prototype.' + name + ' can only be used on a ReadableStreamDefaultController');\r\n  }\r\n  function byobRequestBrandCheckException(name) {\r\n    return new TypeError('ReadableStreamBYOBRequest.prototype.' + name + ' can only be used on a ReadableStreamBYOBRequest');\r\n  }\r\n  function byteStreamControllerBrandCheckException(name) {\r\n    return new TypeError('ReadableByteStreamController.prototype.' + name + ' can only be used on a ReadableByteStreamController');\r\n  }\r\n  function ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\r\n    try {\r\n      Promise.prototype.then.call(promise, undefined, function () {});\r\n    } catch (e) {}\r\n  }\r\n}, function (module, exports, __w_pdfjs_require__) {\r\n  \"use strict\";\r\n\r\n  var transformStream = __w_pdfjs_require__(6);\r\n  var readableStream = __w_pdfjs_require__(4);\r\n  var writableStream = __w_pdfjs_require__(2);\r\n  exports.TransformStream = transformStream.TransformStream;\r\n  exports.ReadableStream = readableStream.ReadableStream;\r\n  exports.IsReadableStreamDisturbed = readableStream.IsReadableStreamDisturbed;\r\n  exports.ReadableStreamDefaultControllerClose = readableStream.ReadableStreamDefaultControllerClose;\r\n  exports.ReadableStreamDefaultControllerEnqueue = readableStream.ReadableStreamDefaultControllerEnqueue;\r\n  exports.ReadableStreamDefaultControllerError = readableStream.ReadableStreamDefaultControllerError;\r\n  exports.ReadableStreamDefaultControllerGetDesiredSize = readableStream.ReadableStreamDefaultControllerGetDesiredSize;\r\n  exports.AcquireWritableStreamDefaultWriter = writableStream.AcquireWritableStreamDefaultWriter;\r\n  exports.IsWritableStream = writableStream.IsWritableStream;\r\n  exports.IsWritableStreamLocked = writableStream.IsWritableStreamLocked;\r\n  exports.WritableStream = writableStream.WritableStream;\r\n  exports.WritableStreamAbort = writableStream.WritableStreamAbort;\r\n  exports.WritableStreamDefaultControllerError = writableStream.WritableStreamDefaultControllerError;\r\n  exports.WritableStreamDefaultWriterCloseWithErrorPropagation = writableStream.WritableStreamDefaultWriterCloseWithErrorPropagation;\r\n  exports.WritableStreamDefaultWriterRelease = writableStream.WritableStreamDefaultWriterRelease;\r\n  exports.WritableStreamDefaultWriterWrite = writableStream.WritableStreamDefaultWriterWrite;\r\n}, function (module, exports, __w_pdfjs_require__) {\r\n  \"use strict\";\r\n\r\n  var _createClass = function () {\r\n    function defineProperties(target, props) {\r\n      for (var i = 0; i < props.length; i++) {\r\n        var descriptor = props[i];\r\n        descriptor.enumerable = descriptor.enumerable || false;\r\n        descriptor.configurable = true;\r\n        if (\"value\" in descriptor) descriptor.writable = true;\r\n        Object.defineProperty(target, descriptor.key, descriptor);\r\n      }\r\n    }\r\n    return function (Constructor, protoProps, staticProps) {\r\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\r\n      if (staticProps) defineProperties(Constructor, staticProps);\r\n      return Constructor;\r\n    };\r\n  }();\r\n  function _classCallCheck(instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError(\"Cannot call a class as a function\");\r\n    }\r\n  }\r\n  var _require = __w_pdfjs_require__(1),\r\n      assert = _require.assert;\r\n  var _require2 = __w_pdfjs_require__(0),\r\n      InvokeOrNoop = _require2.InvokeOrNoop,\r\n      PromiseInvokeOrPerformFallback = _require2.PromiseInvokeOrPerformFallback,\r\n      PromiseInvokeOrNoop = _require2.PromiseInvokeOrNoop,\r\n      typeIsObject = _require2.typeIsObject;\r\n  var _require3 = __w_pdfjs_require__(4),\r\n      ReadableStream = _require3.ReadableStream,\r\n      ReadableStreamDefaultControllerClose = _require3.ReadableStreamDefaultControllerClose,\r\n      ReadableStreamDefaultControllerEnqueue = _require3.ReadableStreamDefaultControllerEnqueue,\r\n      ReadableStreamDefaultControllerError = _require3.ReadableStreamDefaultControllerError,\r\n      ReadableStreamDefaultControllerGetDesiredSize = _require3.ReadableStreamDefaultControllerGetDesiredSize;\r\n  var _require4 = __w_pdfjs_require__(2),\r\n      WritableStream = _require4.WritableStream,\r\n      WritableStreamDefaultControllerError = _require4.WritableStreamDefaultControllerError;\r\n  function TransformStreamCloseReadable(transformStream) {\r\n    if (transformStream._errored === true) {\r\n      throw new TypeError('TransformStream is already errored');\r\n    }\r\n    if (transformStream._readableClosed === true) {\r\n      throw new TypeError('Readable side is already closed');\r\n    }\r\n    TransformStreamCloseReadableInternal(transformStream);\r\n  }\r\n  function TransformStreamEnqueueToReadable(transformStream, chunk) {\r\n    if (transformStream._errored === true) {\r\n      throw new TypeError('TransformStream is already errored');\r\n    }\r\n    if (transformStream._readableClosed === true) {\r\n      throw new TypeError('Readable side is already closed');\r\n    }\r\n    var controller = transformStream._readableController;\r\n    try {\r\n      ReadableStreamDefaultControllerEnqueue(controller, chunk);\r\n    } catch (e) {\r\n      transformStream._readableClosed = true;\r\n      TransformStreamErrorIfNeeded(transformStream, e);\r\n      throw transformStream._storedError;\r\n    }\r\n    var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\r\n    var maybeBackpressure = desiredSize <= 0;\r\n    if (maybeBackpressure === true && transformStream._backpressure === false) {\r\n      TransformStreamSetBackpressure(transformStream, true);\r\n    }\r\n  }\r\n  function TransformStreamError(transformStream, e) {\r\n    if (transformStream._errored === true) {\r\n      throw new TypeError('TransformStream is already errored');\r\n    }\r\n    TransformStreamErrorInternal(transformStream, e);\r\n  }\r\n  function TransformStreamCloseReadableInternal(transformStream) {\r\n    assert(transformStream._errored === false);\r\n    assert(transformStream._readableClosed === false);\r\n    try {\r\n      ReadableStreamDefaultControllerClose(transformStream._readableController);\r\n    } catch (e) {\r\n      assert(false);\r\n    }\r\n    transformStream._readableClosed = true;\r\n  }\r\n  function TransformStreamErrorIfNeeded(transformStream, e) {\r\n    if (transformStream._errored === false) {\r\n      TransformStreamErrorInternal(transformStream, e);\r\n    }\r\n  }\r\n  function TransformStreamErrorInternal(transformStream, e) {\r\n    assert(transformStream._errored === false);\r\n    transformStream._errored = true;\r\n    transformStream._storedError = e;\r\n    if (transformStream._writableDone === false) {\r\n      WritableStreamDefaultControllerError(transformStream._writableController, e);\r\n    }\r\n    if (transformStream._readableClosed === false) {\r\n      ReadableStreamDefaultControllerError(transformStream._readableController, e);\r\n    }\r\n  }\r\n  function TransformStreamReadableReadyPromise(transformStream) {\r\n    assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');\r\n    if (transformStream._backpressure === false) {\r\n      return Promise.resolve();\r\n    }\r\n    assert(transformStream._backpressure === true, '_backpressure should have been initialized');\r\n    return transformStream._backpressureChangePromise;\r\n  }\r\n  function TransformStreamSetBackpressure(transformStream, backpressure) {\r\n    assert(transformStream._backpressure !== backpressure, 'TransformStreamSetBackpressure() should be called only when backpressure is changed');\r\n    if (transformStream._backpressureChangePromise !== undefined) {\r\n      transformStream._backpressureChangePromise_resolve(backpressure);\r\n    }\r\n    transformStream._backpressureChangePromise = new Promise(function (resolve) {\r\n      transformStream._backpressureChangePromise_resolve = resolve;\r\n    });\r\n    transformStream._backpressureChangePromise.then(function (resolution) {\r\n      assert(resolution !== backpressure, '_backpressureChangePromise should be fulfilled only when backpressure is changed');\r\n    });\r\n    transformStream._backpressure = backpressure;\r\n  }\r\n  function TransformStreamDefaultTransform(chunk, transformStreamController) {\r\n    var transformStream = transformStreamController._controlledTransformStream;\r\n    TransformStreamEnqueueToReadable(transformStream, chunk);\r\n    return Promise.resolve();\r\n  }\r\n  function TransformStreamTransform(transformStream, chunk) {\r\n    assert(transformStream._errored === false);\r\n    assert(transformStream._transforming === false);\r\n    assert(transformStream._backpressure === false);\r\n    transformStream._transforming = true;\r\n    var transformer = transformStream._transformer;\r\n    var controller = transformStream._transformStreamController;\r\n    var transformPromise = PromiseInvokeOrPerformFallback(transformer, 'transform', [chunk, controller], TransformStreamDefaultTransform, [chunk, controller]);\r\n    return transformPromise.then(function () {\r\n      transformStream._transforming = false;\r\n      return TransformStreamReadableReadyPromise(transformStream);\r\n    }, function (e) {\r\n      TransformStreamErrorIfNeeded(transformStream, e);\r\n      return Promise.reject(e);\r\n    });\r\n  }\r\n  function IsTransformStreamDefaultController(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  function IsTransformStream(x) {\r\n    if (!typeIsObject(x)) {\r\n      return false;\r\n    }\r\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  var TransformStreamSink = function () {\r\n    function TransformStreamSink(transformStream, startPromise) {\r\n      _classCallCheck(this, TransformStreamSink);\r\n      this._transformStream = transformStream;\r\n      this._startPromise = startPromise;\r\n    }\r\n    _createClass(TransformStreamSink, [{\r\n      key: 'start',\r\n      value: function start(c) {\r\n        var transformStream = this._transformStream;\r\n        transformStream._writableController = c;\r\n        return this._startPromise.then(function () {\r\n          return TransformStreamReadableReadyPromise(transformStream);\r\n        });\r\n      }\r\n    }, {\r\n      key: 'write',\r\n      value: function write(chunk) {\r\n        var transformStream = this._transformStream;\r\n        return TransformStreamTransform(transformStream, chunk);\r\n      }\r\n    }, {\r\n      key: 'abort',\r\n      value: function abort() {\r\n        var transformStream = this._transformStream;\r\n        transformStream._writableDone = true;\r\n        TransformStreamErrorInternal(transformStream, new TypeError('Writable side aborted'));\r\n      }\r\n    }, {\r\n      key: 'close',\r\n      value: function close() {\r\n        var transformStream = this._transformStream;\r\n        assert(transformStream._transforming === false);\r\n        transformStream._writableDone = true;\r\n        var flushPromise = PromiseInvokeOrNoop(transformStream._transformer, 'flush', [transformStream._transformStreamController]);\r\n        return flushPromise.then(function () {\r\n          if (transformStream._errored === true) {\r\n            return Promise.reject(transformStream._storedError);\r\n          }\r\n          if (transformStream._readableClosed === false) {\r\n            TransformStreamCloseReadableInternal(transformStream);\r\n          }\r\n          return Promise.resolve();\r\n        }).catch(function (r) {\r\n          TransformStreamErrorIfNeeded(transformStream, r);\r\n          return Promise.reject(transformStream._storedError);\r\n        });\r\n      }\r\n    }]);\r\n    return TransformStreamSink;\r\n  }();\r\n  var TransformStreamSource = function () {\r\n    function TransformStreamSource(transformStream, startPromise) {\r\n      _classCallCheck(this, TransformStreamSource);\r\n      this._transformStream = transformStream;\r\n      this._startPromise = startPromise;\r\n    }\r\n    _createClass(TransformStreamSource, [{\r\n      key: 'start',\r\n      value: function start(c) {\r\n        var transformStream = this._transformStream;\r\n        transformStream._readableController = c;\r\n        return this._startPromise.then(function () {\r\n          assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');\r\n          if (transformStream._backpressure === true) {\r\n            return Promise.resolve();\r\n          }\r\n          assert(transformStream._backpressure === false, '_backpressure should have been initialized');\r\n          return transformStream._backpressureChangePromise;\r\n        });\r\n      }\r\n    }, {\r\n      key: 'pull',\r\n      value: function pull() {\r\n        var transformStream = this._transformStream;\r\n        assert(transformStream._backpressure === true, 'pull() should be never called while _backpressure is false');\r\n        assert(transformStream._backpressureChangePromise !== undefined, '_backpressureChangePromise should have been initialized');\r\n        TransformStreamSetBackpressure(transformStream, false);\r\n        return transformStream._backpressureChangePromise;\r\n      }\r\n    }, {\r\n      key: 'cancel',\r\n      value: function cancel() {\r\n        var transformStream = this._transformStream;\r\n        transformStream._readableClosed = true;\r\n        TransformStreamErrorInternal(transformStream, new TypeError('Readable side canceled'));\r\n      }\r\n    }]);\r\n    return TransformStreamSource;\r\n  }();\r\n  var TransformStreamDefaultController = function () {\r\n    function TransformStreamDefaultController(transformStream) {\r\n      _classCallCheck(this, TransformStreamDefaultController);\r\n      if (IsTransformStream(transformStream) === false) {\r\n        throw new TypeError('TransformStreamDefaultController can only be ' + 'constructed with a TransformStream instance');\r\n      }\r\n      if (transformStream._transformStreamController !== undefined) {\r\n        throw new TypeError('TransformStreamDefaultController instances can ' + 'only be created by the TransformStream constructor');\r\n      }\r\n      this._controlledTransformStream = transformStream;\r\n    }\r\n    _createClass(TransformStreamDefaultController, [{\r\n      key: 'enqueue',\r\n      value: function enqueue(chunk) {\r\n        if (IsTransformStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('enqueue');\r\n        }\r\n        TransformStreamEnqueueToReadable(this._controlledTransformStream, chunk);\r\n      }\r\n    }, {\r\n      key: 'close',\r\n      value: function close() {\r\n        if (IsTransformStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('close');\r\n        }\r\n        TransformStreamCloseReadable(this._controlledTransformStream);\r\n      }\r\n    }, {\r\n      key: 'error',\r\n      value: function error(reason) {\r\n        if (IsTransformStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('error');\r\n        }\r\n        TransformStreamError(this._controlledTransformStream, reason);\r\n      }\r\n    }, {\r\n      key: 'desiredSize',\r\n      get: function get() {\r\n        if (IsTransformStreamDefaultController(this) === false) {\r\n          throw defaultControllerBrandCheckException('desiredSize');\r\n        }\r\n        var transformStream = this._controlledTransformStream;\r\n        var readableController = transformStream._readableController;\r\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\r\n      }\r\n    }]);\r\n    return TransformStreamDefaultController;\r\n  }();\r\n  var TransformStream = function () {\r\n    function TransformStream() {\r\n      var transformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      _classCallCheck(this, TransformStream);\r\n      this._transformer = transformer;\r\n      var readableStrategy = transformer.readableStrategy,\r\n          writableStrategy = transformer.writableStrategy;\r\n      this._transforming = false;\r\n      this._errored = false;\r\n      this._storedError = undefined;\r\n      this._writableController = undefined;\r\n      this._readableController = undefined;\r\n      this._transformStreamController = undefined;\r\n      this._writableDone = false;\r\n      this._readableClosed = false;\r\n      this._backpressure = undefined;\r\n      this._backpressureChangePromise = undefined;\r\n      this._backpressureChangePromise_resolve = undefined;\r\n      this._transformStreamController = new TransformStreamDefaultController(this);\r\n      var startPromise_resolve = void 0;\r\n      var startPromise = new Promise(function (resolve) {\r\n        startPromise_resolve = resolve;\r\n      });\r\n      var source = new TransformStreamSource(this, startPromise);\r\n      this._readable = new ReadableStream(source, readableStrategy);\r\n      var sink = new TransformStreamSink(this, startPromise);\r\n      this._writable = new WritableStream(sink, writableStrategy);\r\n      assert(this._writableController !== undefined);\r\n      assert(this._readableController !== undefined);\r\n      var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(this._readableController);\r\n      TransformStreamSetBackpressure(this, desiredSize <= 0);\r\n      var transformStream = this;\r\n      var startResult = InvokeOrNoop(transformer, 'start', [transformStream._transformStreamController]);\r\n      startPromise_resolve(startResult);\r\n      startPromise.catch(function (e) {\r\n        if (transformStream._errored === false) {\r\n          transformStream._errored = true;\r\n          transformStream._storedError = e;\r\n        }\r\n      });\r\n    }\r\n    _createClass(TransformStream, [{\r\n      key: 'readable',\r\n      get: function get() {\r\n        if (IsTransformStream(this) === false) {\r\n          throw streamBrandCheckException('readable');\r\n        }\r\n        return this._readable;\r\n      }\r\n    }, {\r\n      key: 'writable',\r\n      get: function get() {\r\n        if (IsTransformStream(this) === false) {\r\n          throw streamBrandCheckException('writable');\r\n        }\r\n        return this._writable;\r\n      }\r\n    }]);\r\n    return TransformStream;\r\n  }();\r\n  module.exports = { TransformStream: TransformStream };\r\n  function defaultControllerBrandCheckException(name) {\r\n    return new TypeError('TransformStreamDefaultController.prototype.' + name + ' can only be used on a TransformStreamDefaultController');\r\n  }\r\n  function streamBrandCheckException(name) {\r\n    return new TypeError('TransformStream.prototype.' + name + ' can only be used on a TransformStream');\r\n  }\r\n}, function (module, exports, __w_pdfjs_require__) {\r\n  module.exports = __w_pdfjs_require__(5);\r\n}]));\r\n\r\n/***/ }),\r\n/* 117 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.build = exports.version = exports.setPDFNetworkStreamFactory = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.getDocument = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _dom_utils = __w_pdfjs_require__(24);\r\n\r\nvar _font_loader = __w_pdfjs_require__(118);\r\n\r\nvar _api_compatibility = __w_pdfjs_require__(58);\r\n\r\nvar _canvas = __w_pdfjs_require__(119);\r\n\r\nvar _global_scope = __w_pdfjs_require__(18);\r\n\r\nvar _global_scope2 = _interopRequireDefault(_global_scope);\r\n\r\nvar _worker_options = __w_pdfjs_require__(59);\r\n\r\nvar _metadata = __w_pdfjs_require__(121);\r\n\r\nvar _transport_stream = __w_pdfjs_require__(123);\r\n\r\nvar _webgl = __w_pdfjs_require__(124);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar DEFAULT_RANGE_CHUNK_SIZE = 65536;\r\nvar isWorkerDisabled = false;\r\nvar workerSrc = void 0;\r\nvar pdfjsFilePath = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : null;\r\nvar fakeWorkerFilesLoader = null;\r\nvar useRequireEnsure = false;\r\n{\r\n  if (typeof window === 'undefined') {\r\n    isWorkerDisabled = true;\r\n    if (typeof require.ensure === 'undefined') {\r\n      require.ensure = require('node-ensure');\r\n    }\r\n    useRequireEnsure = true;\r\n  } else if (typeof require !== 'undefined' && typeof require.ensure === 'function') {\r\n    useRequireEnsure = true;\r\n  }\r\n  if (typeof requirejs !== 'undefined' && requirejs.toUrl) {\r\n    workerSrc = requirejs.toUrl('pdfjs-dist/build/pdf.worker.js');\r\n  }\r\n  var dynamicLoaderSupported = typeof requirejs !== 'undefined' && requirejs.load;\r\n  fakeWorkerFilesLoader = useRequireEnsure ? function (callback) {\r\n    require.ensure([], function () {\r\n      var worker;\r\n      worker = require('./pdf.worker.js');\r\n      callback(worker.WorkerMessageHandler);\r\n    });\r\n  } : dynamicLoaderSupported ? function (callback) {\r\n    requirejs(['pdfjs-dist/build/pdf.worker'], function (worker) {\r\n      callback(worker.WorkerMessageHandler);\r\n    });\r\n  } : null;\r\n}\r\nvar createPDFNetworkStream;\r\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\r\n  createPDFNetworkStream = pdfNetworkStreamFactory;\r\n}\r\nfunction getDocument(src) {\r\n  var task = new PDFDocumentLoadingTask();\r\n  var source;\r\n  if (typeof src === 'string') {\r\n    source = { url: src };\r\n  } else if ((0, _util.isArrayBuffer)(src)) {\r\n    source = { data: src };\r\n  } else if (src instanceof PDFDataRangeTransport) {\r\n    source = { range: src };\r\n  } else {\r\n    if ((typeof src === 'undefined' ? 'undefined' : _typeof(src)) !== 'object') {\r\n      throw new Error('Invalid parameter in getDocument, ' + 'need either Uint8Array, string or a parameter object');\r\n    }\r\n    if (!src.url && !src.data && !src.range) {\r\n      throw new Error('Invalid parameter object: need either .data, .range or .url');\r\n    }\r\n    source = src;\r\n  }\r\n  var params = Object.create(null);\r\n  var rangeTransport = null;\r\n  var worker = null;\r\n  var CMapReaderFactory = _dom_utils.DOMCMapReaderFactory;\r\n  for (var key in source) {\r\n    if (key === 'url' && typeof window !== 'undefined') {\r\n      params[key] = new URL(source[key], window.location).href;\r\n      continue;\r\n    } else if (key === 'range') {\r\n      rangeTransport = source[key];\r\n      continue;\r\n    } else if (key === 'worker') {\r\n      worker = source[key];\r\n      continue;\r\n    } else if (key === 'data' && !(source[key] instanceof Uint8Array)) {\r\n      var pdfBytes = source[key];\r\n      if (typeof pdfBytes === 'string') {\r\n        params[key] = (0, _util.stringToBytes)(pdfBytes);\r\n      } else if ((typeof pdfBytes === 'undefined' ? 'undefined' : _typeof(pdfBytes)) === 'object' && pdfBytes !== null && !isNaN(pdfBytes.length)) {\r\n        params[key] = new Uint8Array(pdfBytes);\r\n      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {\r\n        params[key] = new Uint8Array(pdfBytes);\r\n      } else {\r\n        throw new Error('Invalid PDF binary data: either typed array, ' + 'string or array-like object is expected in the ' + 'data property.');\r\n      }\r\n      continue;\r\n    } else if (key === 'CMapReaderFactory') {\r\n      CMapReaderFactory = source[key];\r\n      continue;\r\n    }\r\n    params[key] = source[key];\r\n  }\r\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\r\n  params.ignoreErrors = params.stopAtErrors !== true;\r\n  params.pdfBug = params.pdfBug === true;\r\n  var NativeImageDecoderValues = Object.values(_util.NativeImageDecoding);\r\n  if (params.nativeImageDecoderSupport === undefined || !NativeImageDecoderValues.includes(params.nativeImageDecoderSupport)) {\r\n    params.nativeImageDecoderSupport = _util.NativeImageDecoding.DECODE;\r\n  }\r\n  if (!Number.isInteger(params.maxImageSize)) {\r\n    params.maxImageSize = -1;\r\n  }\r\n  if (typeof params.isEvalSupported !== 'boolean') {\r\n    params.isEvalSupported = true;\r\n  }\r\n  if (typeof params.disableFontFace !== 'boolean') {\r\n    params.disableFontFace = false;\r\n  }\r\n  if (typeof params.disableRange !== 'boolean') {\r\n    params.disableRange = _api_compatibility.apiCompatibilityParams.disableRange || false;\r\n  }\r\n  if (typeof params.disableStream !== 'boolean') {\r\n    params.disableStream = _api_compatibility.apiCompatibilityParams.disableStream || false;\r\n  }\r\n  if (typeof params.disableAutoFetch !== 'boolean') {\r\n    params.disableAutoFetch = false;\r\n  }\r\n  if (typeof params.disableCreateObjectURL !== 'boolean') {\r\n    params.disableCreateObjectURL = _api_compatibility.apiCompatibilityParams.disableCreateObjectURL || false;\r\n  }\r\n  (0, _util.setVerbosityLevel)(params.verbosity);\r\n  if (!worker) {\r\n    var workerParams = {\r\n      postMessageTransfers: params.postMessageTransfers,\r\n      verbosity: params.verbosity\r\n    };\r\n    var workerPort = _worker_options.GlobalWorkerOptions.workerPort;\r\n    if (workerPort) {\r\n      workerParams.port = workerPort;\r\n      worker = PDFWorker.fromPort(workerParams);\r\n    } else {\r\n      worker = new PDFWorker(workerParams);\r\n    }\r\n    task._worker = worker;\r\n  }\r\n  var docId = task.docId;\r\n  worker.promise.then(function () {\r\n    if (task.destroyed) {\r\n      throw new Error('Loading aborted');\r\n    }\r\n    return _fetchDocument(worker, params, rangeTransport, docId).then(function (workerId) {\r\n      if (task.destroyed) {\r\n        throw new Error('Loading aborted');\r\n      }\r\n      var networkStream = void 0;\r\n      if (rangeTransport) {\r\n        networkStream = new _transport_stream.PDFDataTransportStream({\r\n          length: params.length,\r\n          initialData: params.initialData,\r\n          disableRange: params.disableRange,\r\n          disableStream: params.disableStream\r\n        }, rangeTransport);\r\n      } else if (!params.data) {\r\n        networkStream = createPDFNetworkStream({\r\n          url: params.url,\r\n          length: params.length,\r\n          httpHeaders: params.httpHeaders,\r\n          withCredentials: params.withCredentials,\r\n          rangeChunkSize: params.rangeChunkSize,\r\n          disableRange: params.disableRange,\r\n          disableStream: params.disableStream\r\n        });\r\n      }\r\n      var messageHandler = new _util.MessageHandler(docId, workerId, worker.port);\r\n      messageHandler.postMessageTransfers = worker.postMessageTransfers;\r\n      var transport = new WorkerTransport(messageHandler, task, networkStream, params, CMapReaderFactory);\r\n      task._transport = transport;\r\n      messageHandler.send('Ready', null);\r\n    });\r\n  }).catch(task._capability.reject);\r\n  return task;\r\n}\r\nfunction _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\r\n  if (worker.destroyed) {\r\n    return Promise.reject(new Error('Worker was destroyed'));\r\n  }\r\n  if (pdfDataRangeTransport) {\r\n    source.length = pdfDataRangeTransport.length;\r\n    source.initialData = pdfDataRangeTransport.initialData;\r\n  }\r\n  return worker.messageHandler.sendWithPromise('GetDocRequest', {\r\n    docId: docId,\r\n    apiVersion: '2.0.489',\r\n    source: {\r\n      data: source.data,\r\n      url: source.url,\r\n      password: source.password,\r\n      disableAutoFetch: source.disableAutoFetch,\r\n      rangeChunkSize: source.rangeChunkSize,\r\n      length: source.length\r\n    },\r\n    maxImageSize: source.maxImageSize,\r\n    disableFontFace: source.disableFontFace,\r\n    disableCreateObjectURL: source.disableCreateObjectURL,\r\n    postMessageTransfers: worker.postMessageTransfers,\r\n    docBaseUrl: source.docBaseUrl,\r\n    nativeImageDecoderSupport: source.nativeImageDecoderSupport,\r\n    ignoreErrors: source.ignoreErrors,\r\n    isEvalSupported: source.isEvalSupported\r\n  }).then(function (workerId) {\r\n    if (worker.destroyed) {\r\n      throw new Error('Worker was destroyed');\r\n    }\r\n    return workerId;\r\n  });\r\n}\r\nvar PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {\r\n  var nextDocumentId = 0;\r\n  function PDFDocumentLoadingTask() {\r\n    this._capability = (0, _util.createPromiseCapability)();\r\n    this._transport = null;\r\n    this._worker = null;\r\n    this.docId = 'd' + nextDocumentId++;\r\n    this.destroyed = false;\r\n    this.onPassword = null;\r\n    this.onProgress = null;\r\n    this.onUnsupportedFeature = null;\r\n  }\r\n  PDFDocumentLoadingTask.prototype = {\r\n    get promise() {\r\n      return this._capability.promise;\r\n    },\r\n    destroy: function destroy() {\r\n      var _this = this;\r\n\r\n      this.destroyed = true;\r\n      var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();\r\n      return transportDestroyed.then(function () {\r\n        _this._transport = null;\r\n        if (_this._worker) {\r\n          _this._worker.destroy();\r\n          _this._worker = null;\r\n        }\r\n      });\r\n    },\r\n\r\n    then: function PDFDocumentLoadingTask_then(onFulfilled, onRejected) {\r\n      return this.promise.then.apply(this.promise, arguments);\r\n    }\r\n  };\r\n  return PDFDocumentLoadingTask;\r\n}();\r\nvar PDFDataRangeTransport = function pdfDataRangeTransportClosure() {\r\n  function PDFDataRangeTransport(length, initialData) {\r\n    this.length = length;\r\n    this.initialData = initialData;\r\n    this._rangeListeners = [];\r\n    this._progressListeners = [];\r\n    this._progressiveReadListeners = [];\r\n    this._readyCapability = (0, _util.createPromiseCapability)();\r\n  }\r\n  PDFDataRangeTransport.prototype = {\r\n    addRangeListener: function PDFDataRangeTransport_addRangeListener(listener) {\r\n      this._rangeListeners.push(listener);\r\n    },\r\n    addProgressListener: function PDFDataRangeTransport_addProgressListener(listener) {\r\n      this._progressListeners.push(listener);\r\n    },\r\n    addProgressiveReadListener: function PDFDataRangeTransport_addProgressiveReadListener(listener) {\r\n      this._progressiveReadListeners.push(listener);\r\n    },\r\n    onDataRange: function PDFDataRangeTransport_onDataRange(begin, chunk) {\r\n      var listeners = this._rangeListeners;\r\n      for (var i = 0, n = listeners.length; i < n; ++i) {\r\n        listeners[i](begin, chunk);\r\n      }\r\n    },\r\n    onDataProgress: function PDFDataRangeTransport_onDataProgress(loaded) {\r\n      var _this2 = this;\r\n\r\n      this._readyCapability.promise.then(function () {\r\n        var listeners = _this2._progressListeners;\r\n        for (var i = 0, n = listeners.length; i < n; ++i) {\r\n          listeners[i](loaded);\r\n        }\r\n      });\r\n    },\r\n    onDataProgressiveRead: function PDFDataRangeTransport_onDataProgress(chunk) {\r\n      var _this3 = this;\r\n\r\n      this._readyCapability.promise.then(function () {\r\n        var listeners = _this3._progressiveReadListeners;\r\n        for (var i = 0, n = listeners.length; i < n; ++i) {\r\n          listeners[i](chunk);\r\n        }\r\n      });\r\n    },\r\n    transportReady: function PDFDataRangeTransport_transportReady() {\r\n      this._readyCapability.resolve();\r\n    },\r\n    requestDataRange: function PDFDataRangeTransport_requestDataRange(begin, end) {\r\n      (0, _util.unreachable)('Abstract method PDFDataRangeTransport.requestDataRange');\r\n    },\r\n    abort: function PDFDataRangeTransport_abort() {}\r\n  };\r\n  return PDFDataRangeTransport;\r\n}();\r\nvar PDFDocumentProxy = function PDFDocumentProxyClosure() {\r\n  function PDFDocumentProxy(pdfInfo, transport, loadingTask) {\r\n    this.pdfInfo = pdfInfo;\r\n    this.transport = transport;\r\n    this.loadingTask = loadingTask;\r\n  }\r\n  PDFDocumentProxy.prototype = {\r\n    get numPages() {\r\n      return this.pdfInfo.numPages;\r\n    },\r\n    get fingerprint() {\r\n      return this.pdfInfo.fingerprint;\r\n    },\r\n    getPage: function getPage(pageNumber) {\r\n      return this.transport.getPage(pageNumber);\r\n    },\r\n\r\n    getPageIndex: function PDFDocumentProxy_getPageIndex(ref) {\r\n      return this.transport.getPageIndex(ref);\r\n    },\r\n    getDestinations: function PDFDocumentProxy_getDestinations() {\r\n      return this.transport.getDestinations();\r\n    },\r\n    getDestination: function PDFDocumentProxy_getDestination(id) {\r\n      return this.transport.getDestination(id);\r\n    },\r\n    getPageLabels: function PDFDocumentProxy_getPageLabels() {\r\n      return this.transport.getPageLabels();\r\n    },\r\n    getPageMode: function getPageMode() {\r\n      return this.transport.getPageMode();\r\n    },\r\n\r\n    getAttachments: function PDFDocumentProxy_getAttachments() {\r\n      return this.transport.getAttachments();\r\n    },\r\n    getJavaScript: function getJavaScript() {\r\n      return this.transport.getJavaScript();\r\n    },\r\n\r\n    getOutline: function PDFDocumentProxy_getOutline() {\r\n      return this.transport.getOutline();\r\n    },\r\n    getMetadata: function PDFDocumentProxy_getMetadata() {\r\n      return this.transport.getMetadata();\r\n    },\r\n    getData: function PDFDocumentProxy_getData() {\r\n      return this.transport.getData();\r\n    },\r\n    getDownloadInfo: function PDFDocumentProxy_getDownloadInfo() {\r\n      return this.transport.downloadInfoCapability.promise;\r\n    },\r\n    getStats: function PDFDocumentProxy_getStats() {\r\n      return this.transport.getStats();\r\n    },\r\n    cleanup: function PDFDocumentProxy_cleanup() {\r\n      this.transport.startCleanup();\r\n    },\r\n    destroy: function PDFDocumentProxy_destroy() {\r\n      return this.loadingTask.destroy();\r\n    },\r\n    get loadingParams() {\r\n      return this.transport.loadingParams;\r\n    }\r\n  };\r\n  return PDFDocumentProxy;\r\n}();\r\nvar PDFPageProxy = function PDFPageProxyClosure() {\r\n  function PDFPageProxy(pageIndex, pageInfo, transport) {\r\n    var pdfBug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n\r\n    this.pageIndex = pageIndex;\r\n    this.pageInfo = pageInfo;\r\n    this.transport = transport;\r\n    this._stats = pdfBug ? new _dom_utils.StatTimer() : _dom_utils.DummyStatTimer;\r\n    this._pdfBug = pdfBug;\r\n    this.commonObjs = transport.commonObjs;\r\n    this.objs = new PDFObjects();\r\n    this.cleanupAfterRender = false;\r\n    this.pendingCleanup = false;\r\n    this.intentStates = Object.create(null);\r\n    this.destroyed = false;\r\n  }\r\n  PDFPageProxy.prototype = {\r\n    get pageNumber() {\r\n      return this.pageIndex + 1;\r\n    },\r\n    get rotate() {\r\n      return this.pageInfo.rotate;\r\n    },\r\n    get ref() {\r\n      return this.pageInfo.ref;\r\n    },\r\n    get userUnit() {\r\n      return this.pageInfo.userUnit;\r\n    },\r\n    get view() {\r\n      return this.pageInfo.view;\r\n    },\r\n    getViewport: function getViewport(scale) {\r\n      var rotate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.rotate;\r\n      var dontFlip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n\r\n      return new _util.PageViewport(this.view, scale, rotate, 0, 0, dontFlip);\r\n    },\r\n\r\n    getAnnotations: function PDFPageProxy_getAnnotations(params) {\r\n      var intent = params && params.intent || null;\r\n      if (!this.annotationsPromise || this.annotationsIntent !== intent) {\r\n        this.annotationsPromise = this.transport.getAnnotations(this.pageIndex, intent);\r\n        this.annotationsIntent = intent;\r\n      }\r\n      return this.annotationsPromise;\r\n    },\r\n    render: function PDFPageProxy_render(params) {\r\n      var _this4 = this;\r\n\r\n      var stats = this._stats;\r\n      stats.time('Overall');\r\n      this.pendingCleanup = false;\r\n      var renderingIntent = params.intent === 'print' ? 'print' : 'display';\r\n      var canvasFactory = params.canvasFactory || new _dom_utils.DOMCanvasFactory();\r\n      var webGLContext = new _webgl.WebGLContext({ enable: params.enableWebGL });\r\n      if (!this.intentStates[renderingIntent]) {\r\n        this.intentStates[renderingIntent] = Object.create(null);\r\n      }\r\n      var intentState = this.intentStates[renderingIntent];\r\n      if (!intentState.displayReadyCapability) {\r\n        intentState.receivingOperatorList = true;\r\n        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\r\n        intentState.operatorList = {\r\n          fnArray: [],\r\n          argsArray: [],\r\n          lastChunk: false\r\n        };\r\n        stats.time('Page Request');\r\n        this.transport.messageHandler.send('RenderPageRequest', {\r\n          pageIndex: this.pageNumber - 1,\r\n          intent: renderingIntent,\r\n          renderInteractiveForms: params.renderInteractiveForms === true\r\n        });\r\n      }\r\n      var complete = function complete(error) {\r\n        var i = intentState.renderTasks.indexOf(internalRenderTask);\r\n        if (i >= 0) {\r\n          intentState.renderTasks.splice(i, 1);\r\n        }\r\n        if (_this4.cleanupAfterRender) {\r\n          _this4.pendingCleanup = true;\r\n        }\r\n        _this4._tryCleanup();\r\n        if (error) {\r\n          internalRenderTask.capability.reject(error);\r\n        } else {\r\n          internalRenderTask.capability.resolve();\r\n        }\r\n        stats.timeEnd('Rendering');\r\n        stats.timeEnd('Overall');\r\n      };\r\n      var internalRenderTask = new InternalRenderTask(complete, params, this.objs, this.commonObjs, intentState.operatorList, this.pageNumber, canvasFactory, webGLContext, this._pdfBug);\r\n      internalRenderTask.useRequestAnimationFrame = renderingIntent !== 'print';\r\n      if (!intentState.renderTasks) {\r\n        intentState.renderTasks = [];\r\n      }\r\n      intentState.renderTasks.push(internalRenderTask);\r\n      var renderTask = internalRenderTask.task;\r\n      intentState.displayReadyCapability.promise.then(function (transparency) {\r\n        if (_this4.pendingCleanup) {\r\n          complete();\r\n          return;\r\n        }\r\n        stats.time('Rendering');\r\n        internalRenderTask.initializeGraphics(transparency);\r\n        internalRenderTask.operatorListChanged();\r\n      }).catch(complete);\r\n      return renderTask;\r\n    },\r\n    getOperatorList: function PDFPageProxy_getOperatorList() {\r\n      function operatorListChanged() {\r\n        if (intentState.operatorList.lastChunk) {\r\n          intentState.opListReadCapability.resolve(intentState.operatorList);\r\n          var i = intentState.renderTasks.indexOf(opListTask);\r\n          if (i >= 0) {\r\n            intentState.renderTasks.splice(i, 1);\r\n          }\r\n        }\r\n      }\r\n      var renderingIntent = 'oplist';\r\n      if (!this.intentStates[renderingIntent]) {\r\n        this.intentStates[renderingIntent] = Object.create(null);\r\n      }\r\n      var intentState = this.intentStates[renderingIntent];\r\n      var opListTask;\r\n      if (!intentState.opListReadCapability) {\r\n        opListTask = {};\r\n        opListTask.operatorListChanged = operatorListChanged;\r\n        intentState.receivingOperatorList = true;\r\n        intentState.opListReadCapability = (0, _util.createPromiseCapability)();\r\n        intentState.renderTasks = [];\r\n        intentState.renderTasks.push(opListTask);\r\n        intentState.operatorList = {\r\n          fnArray: [],\r\n          argsArray: [],\r\n          lastChunk: false\r\n        };\r\n        this.transport.messageHandler.send('RenderPageRequest', {\r\n          pageIndex: this.pageIndex,\r\n          intent: renderingIntent\r\n        });\r\n      }\r\n      return intentState.opListReadCapability.promise;\r\n    },\r\n    streamTextContent: function streamTextContent() {\r\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n      var TEXT_CONTENT_CHUNK_SIZE = 100;\r\n      return this.transport.messageHandler.sendWithStream('GetTextContent', {\r\n        pageIndex: this.pageNumber - 1,\r\n        normalizeWhitespace: params.normalizeWhitespace === true,\r\n        combineTextItems: params.disableCombineTextItems !== true\r\n      }, {\r\n        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\r\n        size: function size(textContent) {\r\n          return textContent.items.length;\r\n        }\r\n      });\r\n    },\r\n\r\n    getTextContent: function PDFPageProxy_getTextContent(params) {\r\n      params = params || {};\r\n      var readableStream = this.streamTextContent(params);\r\n      return new Promise(function (resolve, reject) {\r\n        function pump() {\r\n          reader.read().then(function (_ref) {\r\n            var value = _ref.value,\r\n                done = _ref.done;\r\n\r\n            if (done) {\r\n              resolve(textContent);\r\n              return;\r\n            }\r\n            _util.Util.extendObj(textContent.styles, value.styles);\r\n            _util.Util.appendToArray(textContent.items, value.items);\r\n            pump();\r\n          }, reject);\r\n        }\r\n        var reader = readableStream.getReader();\r\n        var textContent = {\r\n          items: [],\r\n          styles: Object.create(null)\r\n        };\r\n        pump();\r\n      });\r\n    },\r\n    _destroy: function PDFPageProxy_destroy() {\r\n      this.destroyed = true;\r\n      this.transport.pageCache[this.pageIndex] = null;\r\n      var waitOn = [];\r\n      Object.keys(this.intentStates).forEach(function (intent) {\r\n        if (intent === 'oplist') {\r\n          return;\r\n        }\r\n        var intentState = this.intentStates[intent];\r\n        intentState.renderTasks.forEach(function (renderTask) {\r\n          var renderCompleted = renderTask.capability.promise.catch(function () {});\r\n          waitOn.push(renderCompleted);\r\n          renderTask.cancel();\r\n        });\r\n      }, this);\r\n      this.objs.clear();\r\n      this.annotationsPromise = null;\r\n      this.pendingCleanup = false;\r\n      return Promise.all(waitOn);\r\n    },\r\n    cleanup: function cleanup() {\r\n      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n\r\n      this.pendingCleanup = true;\r\n      this._tryCleanup(resetStats);\r\n    },\r\n    _tryCleanup: function _tryCleanup() {\r\n      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n\r\n      if (!this.pendingCleanup || Object.keys(this.intentStates).some(function (intent) {\r\n        var intentState = this.intentStates[intent];\r\n        return intentState.renderTasks.length !== 0 || intentState.receivingOperatorList;\r\n      }, this)) {\r\n        return;\r\n      }\r\n      Object.keys(this.intentStates).forEach(function (intent) {\r\n        delete this.intentStates[intent];\r\n      }, this);\r\n      this.objs.clear();\r\n      this.annotationsPromise = null;\r\n      if (resetStats && this._stats instanceof _dom_utils.StatTimer) {\r\n        this._stats = new _dom_utils.StatTimer();\r\n      }\r\n      this.pendingCleanup = false;\r\n    },\r\n\r\n    _startRenderPage: function PDFPageProxy_startRenderPage(transparency, intent) {\r\n      var intentState = this.intentStates[intent];\r\n      if (intentState.displayReadyCapability) {\r\n        intentState.displayReadyCapability.resolve(transparency);\r\n      }\r\n    },\r\n    _renderPageChunk: function PDFPageProxy_renderPageChunk(operatorListChunk, intent) {\r\n      var intentState = this.intentStates[intent];\r\n      var i, ii;\r\n      for (i = 0, ii = operatorListChunk.length; i < ii; i++) {\r\n        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\r\n        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\r\n      }\r\n      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\r\n      for (i = 0; i < intentState.renderTasks.length; i++) {\r\n        intentState.renderTasks[i].operatorListChanged();\r\n      }\r\n      if (operatorListChunk.lastChunk) {\r\n        intentState.receivingOperatorList = false;\r\n        this._tryCleanup();\r\n      }\r\n    },\r\n    get stats() {\r\n      return this._stats instanceof _dom_utils.StatTimer ? this._stats : null;\r\n    }\r\n  };\r\n  return PDFPageProxy;\r\n}();\r\n\r\nvar LoopbackPort = function () {\r\n  function LoopbackPort(defer) {\r\n    _classCallCheck(this, LoopbackPort);\r\n\r\n    this._listeners = [];\r\n    this._defer = defer;\r\n    this._deferred = Promise.resolve(undefined);\r\n  }\r\n\r\n  _createClass(LoopbackPort, [{\r\n    key: 'postMessage',\r\n    value: function postMessage(obj, transfers) {\r\n      var _this5 = this;\r\n\r\n      function cloneValue(value) {\r\n        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null) {\r\n          return value;\r\n        }\r\n        if (cloned.has(value)) {\r\n          return cloned.get(value);\r\n        }\r\n        var result;\r\n        var buffer;\r\n        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\r\n          var transferable = transfers && transfers.includes(buffer);\r\n          if (value === buffer) {\r\n            result = value;\r\n          } else if (transferable) {\r\n            result = new value.constructor(buffer, value.byteOffset, value.byteLength);\r\n          } else {\r\n            result = new value.constructor(value);\r\n          }\r\n          cloned.set(value, result);\r\n          return result;\r\n        }\r\n        result = Array.isArray(value) ? [] : {};\r\n        cloned.set(value, result);\r\n        for (var i in value) {\r\n          var desc,\r\n              p = value;\r\n          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\r\n            p = Object.getPrototypeOf(p);\r\n          }\r\n          if (typeof desc.value === 'undefined' || typeof desc.value === 'function') {\r\n            continue;\r\n          }\r\n          result[i] = cloneValue(desc.value);\r\n        }\r\n        return result;\r\n      }\r\n      if (!this._defer) {\r\n        this._listeners.forEach(function (listener) {\r\n          listener.call(this, { data: obj });\r\n        }, this);\r\n        return;\r\n      }\r\n      var cloned = new WeakMap();\r\n      var e = { data: cloneValue(obj) };\r\n      this._deferred.then(function () {\r\n        _this5._listeners.forEach(function (listener) {\r\n          listener.call(this, e);\r\n        }, _this5);\r\n      });\r\n    }\r\n  }, {\r\n    key: 'addEventListener',\r\n    value: function addEventListener(name, listener) {\r\n      this._listeners.push(listener);\r\n    }\r\n  }, {\r\n    key: 'removeEventListener',\r\n    value: function removeEventListener(name, listener) {\r\n      var i = this._listeners.indexOf(listener);\r\n      this._listeners.splice(i, 1);\r\n    }\r\n  }, {\r\n    key: 'terminate',\r\n    value: function terminate() {\r\n      this._listeners = [];\r\n    }\r\n  }]);\r\n\r\n  return LoopbackPort;\r\n}();\r\n\r\nvar PDFWorker = function PDFWorkerClosure() {\r\n  var nextFakeWorkerId = 0;\r\n  function getWorkerSrc() {\r\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\r\n      return _worker_options.GlobalWorkerOptions.workerSrc;\r\n    }\r\n    if (typeof workerSrc !== 'undefined') {\r\n      return workerSrc;\r\n    }\r\n    if (pdfjsFilePath) {\r\n      return pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, '.worker$1$2');\r\n    }\r\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\r\n  }\r\n  function getMainThreadWorkerMessageHandler() {\r\n    if (typeof window === 'undefined') {\r\n      return null;\r\n    }\r\n    return window.pdfjsWorker && window.pdfjsWorker.WorkerMessageHandler;\r\n  }\r\n  var fakeWorkerFilesLoadedCapability = void 0;\r\n  function setupFakeWorkerGlobal() {\r\n    if (fakeWorkerFilesLoadedCapability) {\r\n      return fakeWorkerFilesLoadedCapability.promise;\r\n    }\r\n    fakeWorkerFilesLoadedCapability = (0, _util.createPromiseCapability)();\r\n    var mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();\r\n    if (mainWorkerMessageHandler) {\r\n      fakeWorkerFilesLoadedCapability.resolve(mainWorkerMessageHandler);\r\n      return fakeWorkerFilesLoadedCapability.promise;\r\n    }\r\n    var loader = fakeWorkerFilesLoader || function (callback) {\r\n      _util.Util.loadScript(getWorkerSrc(), function () {\r\n        callback(window.pdfjsWorker.WorkerMessageHandler);\r\n      });\r\n    };\r\n    loader(fakeWorkerFilesLoadedCapability.resolve);\r\n    return fakeWorkerFilesLoadedCapability.promise;\r\n  }\r\n  function createCDNWrapper(url) {\r\n    var wrapper = 'importScripts(\\'' + url + '\\');';\r\n    return URL.createObjectURL(new Blob([wrapper]));\r\n  }\r\n  var pdfWorkerPorts = new WeakMap();\r\n  function PDFWorker() {\r\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n        _ref2$name = _ref2.name,\r\n        name = _ref2$name === undefined ? null : _ref2$name,\r\n        _ref2$port = _ref2.port,\r\n        port = _ref2$port === undefined ? null : _ref2$port,\r\n        _ref2$postMessageTran = _ref2.postMessageTransfers,\r\n        postMessageTransfers = _ref2$postMessageTran === undefined ? true : _ref2$postMessageTran,\r\n        _ref2$verbosity = _ref2.verbosity,\r\n        verbosity = _ref2$verbosity === undefined ? null : _ref2$verbosity;\r\n\r\n    if (port && pdfWorkerPorts.has(port)) {\r\n      throw new Error('Cannot use more than one PDFWorker per port');\r\n    }\r\n    this.name = name;\r\n    this.destroyed = false;\r\n    this.postMessageTransfers = postMessageTransfers !== false;\r\n    this.verbosity = (0, _util.isNum)(verbosity) ? verbosity : (0, _util.getVerbosityLevel)();\r\n    this._readyCapability = (0, _util.createPromiseCapability)();\r\n    this._port = null;\r\n    this._webWorker = null;\r\n    this._messageHandler = null;\r\n    if (port) {\r\n      pdfWorkerPorts.set(port, this);\r\n      this._initializeFromPort(port);\r\n      return;\r\n    }\r\n    this._initialize();\r\n  }\r\n  PDFWorker.prototype = {\r\n    get promise() {\r\n      return this._readyCapability.promise;\r\n    },\r\n    get port() {\r\n      return this._port;\r\n    },\r\n    get messageHandler() {\r\n      return this._messageHandler;\r\n    },\r\n    _initializeFromPort: function PDFWorker_initializeFromPort(port) {\r\n      this._port = port;\r\n      this._messageHandler = new _util.MessageHandler('main', 'worker', port);\r\n      this._messageHandler.on('ready', function () {});\r\n      this._readyCapability.resolve();\r\n    },\r\n    _initialize: function PDFWorker_initialize() {\r\n      var _this6 = this;\r\n\r\n      if (typeof Worker !== 'undefined' && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {\r\n        var workerSrc = getWorkerSrc();\r\n        try {\r\n          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\r\n            workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);\r\n          }\r\n          var worker = new Worker(workerSrc);\r\n          var messageHandler = new _util.MessageHandler('main', 'worker', worker);\r\n          var terminateEarly = function terminateEarly() {\r\n            worker.removeEventListener('error', onWorkerError);\r\n            messageHandler.destroy();\r\n            worker.terminate();\r\n            if (_this6.destroyed) {\r\n              _this6._readyCapability.reject(new Error('Worker was destroyed'));\r\n            } else {\r\n              _this6._setupFakeWorker();\r\n            }\r\n          };\r\n          var onWorkerError = function onWorkerError() {\r\n            if (!_this6._webWorker) {\r\n              terminateEarly();\r\n            }\r\n          };\r\n          worker.addEventListener('error', onWorkerError);\r\n          messageHandler.on('test', function (data) {\r\n            worker.removeEventListener('error', onWorkerError);\r\n            if (_this6.destroyed) {\r\n              terminateEarly();\r\n              return;\r\n            }\r\n            var supportTypedArray = data && data.supportTypedArray;\r\n            if (supportTypedArray) {\r\n              _this6._messageHandler = messageHandler;\r\n              _this6._port = worker;\r\n              _this6._webWorker = worker;\r\n              if (!data.supportTransfers) {\r\n                _this6.postMessageTransfers = false;\r\n              }\r\n              _this6._readyCapability.resolve();\r\n              messageHandler.send('configure', { verbosity: _this6.verbosity });\r\n            } else {\r\n              _this6._setupFakeWorker();\r\n              messageHandler.destroy();\r\n              worker.terminate();\r\n            }\r\n          });\r\n          messageHandler.on('ready', function (data) {\r\n            worker.removeEventListener('error', onWorkerError);\r\n            if (_this6.destroyed) {\r\n              terminateEarly();\r\n              return;\r\n            }\r\n            try {\r\n              sendTest();\r\n            } catch (e) {\r\n              _this6._setupFakeWorker();\r\n            }\r\n          });\r\n          var sendTest = function sendTest() {\r\n            var testObj = new Uint8Array([_this6.postMessageTransfers ? 255 : 0]);\r\n            try {\r\n              messageHandler.send('test', testObj, [testObj.buffer]);\r\n            } catch (ex) {\r\n              (0, _util.info)('Cannot use postMessage transfers');\r\n              testObj[0] = 0;\r\n              messageHandler.send('test', testObj);\r\n            }\r\n          };\r\n          sendTest();\r\n          return;\r\n        } catch (e) {\r\n          (0, _util.info)('The worker has been disabled.');\r\n        }\r\n      }\r\n      this._setupFakeWorker();\r\n    },\r\n    _setupFakeWorker: function PDFWorker_setupFakeWorker() {\r\n      var _this7 = this;\r\n\r\n      if (!isWorkerDisabled) {\r\n        (0, _util.warn)('Setting up fake worker.');\r\n        isWorkerDisabled = true;\r\n      }\r\n      setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {\r\n        if (_this7.destroyed) {\r\n          _this7._readyCapability.reject(new Error('Worker was destroyed'));\r\n          return;\r\n        }\r\n        var isTypedArraysPresent = Uint8Array !== Float32Array;\r\n        var port = new LoopbackPort(isTypedArraysPresent);\r\n        _this7._port = port;\r\n        var id = 'fake' + nextFakeWorkerId++;\r\n        var workerHandler = new _util.MessageHandler(id + '_worker', id, port);\r\n        WorkerMessageHandler.setup(workerHandler, port);\r\n        var messageHandler = new _util.MessageHandler(id, id + '_worker', port);\r\n        _this7._messageHandler = messageHandler;\r\n        _this7._readyCapability.resolve();\r\n      });\r\n    },\r\n    destroy: function PDFWorker_destroy() {\r\n      this.destroyed = true;\r\n      if (this._webWorker) {\r\n        this._webWorker.terminate();\r\n        this._webWorker = null;\r\n      }\r\n      pdfWorkerPorts.delete(this._port);\r\n      this._port = null;\r\n      if (this._messageHandler) {\r\n        this._messageHandler.destroy();\r\n        this._messageHandler = null;\r\n      }\r\n    }\r\n  };\r\n  PDFWorker.fromPort = function (params) {\r\n    if (pdfWorkerPorts.has(params.port)) {\r\n      return pdfWorkerPorts.get(params.port);\r\n    }\r\n    return new PDFWorker(params);\r\n  };\r\n  PDFWorker.getWorkerSrc = function () {\r\n    return getWorkerSrc();\r\n  };\r\n  return PDFWorker;\r\n}();\r\nvar WorkerTransport = function WorkerTransportClosure() {\r\n  function WorkerTransport(messageHandler, loadingTask, networkStream, params, CMapReaderFactory) {\r\n    this.messageHandler = messageHandler;\r\n    this.loadingTask = loadingTask;\r\n    this.commonObjs = new PDFObjects();\r\n    this.fontLoader = new _font_loader.FontLoader(loadingTask.docId);\r\n    this._params = params;\r\n    this.CMapReaderFactory = new CMapReaderFactory({\r\n      baseUrl: params.cMapUrl,\r\n      isCompressed: params.cMapPacked\r\n    });\r\n    this.destroyed = false;\r\n    this.destroyCapability = null;\r\n    this._passwordCapability = null;\r\n    this._networkStream = networkStream;\r\n    this._fullReader = null;\r\n    this._lastProgress = null;\r\n    this.pageCache = [];\r\n    this.pagePromises = [];\r\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\r\n    this.setupMessageHandler();\r\n  }\r\n  WorkerTransport.prototype = {\r\n    destroy: function WorkerTransport_destroy() {\r\n      var _this8 = this;\r\n\r\n      if (this.destroyCapability) {\r\n        return this.destroyCapability.promise;\r\n      }\r\n      this.destroyed = true;\r\n      this.destroyCapability = (0, _util.createPromiseCapability)();\r\n      if (this._passwordCapability) {\r\n        this._passwordCapability.reject(new Error('Worker was destroyed during onPassword callback'));\r\n      }\r\n      var waitOn = [];\r\n      this.pageCache.forEach(function (page) {\r\n        if (page) {\r\n          waitOn.push(page._destroy());\r\n        }\r\n      });\r\n      this.pageCache = [];\r\n      this.pagePromises = [];\r\n      var terminated = this.messageHandler.sendWithPromise('Terminate', null);\r\n      waitOn.push(terminated);\r\n      Promise.all(waitOn).then(function () {\r\n        _this8.fontLoader.clear();\r\n        if (_this8._networkStream) {\r\n          _this8._networkStream.cancelAllRequests();\r\n        }\r\n        if (_this8.messageHandler) {\r\n          _this8.messageHandler.destroy();\r\n          _this8.messageHandler = null;\r\n        }\r\n        _this8.destroyCapability.resolve();\r\n      }, this.destroyCapability.reject);\r\n      return this.destroyCapability.promise;\r\n    },\r\n    setupMessageHandler: function WorkerTransport_setupMessageHandler() {\r\n      var messageHandler = this.messageHandler;\r\n      var loadingTask = this.loadingTask;\r\n      messageHandler.on('GetReader', function (data, sink) {\r\n        var _this9 = this;\r\n\r\n        (0, _util.assert)(this._networkStream);\r\n        this._fullReader = this._networkStream.getFullReader();\r\n        this._fullReader.onProgress = function (evt) {\r\n          _this9._lastProgress = {\r\n            loaded: evt.loaded,\r\n            total: evt.total\r\n          };\r\n        };\r\n        sink.onPull = function () {\r\n          _this9._fullReader.read().then(function (_ref3) {\r\n            var value = _ref3.value,\r\n                done = _ref3.done;\r\n\r\n            if (done) {\r\n              sink.close();\r\n              return;\r\n            }\r\n            (0, _util.assert)((0, _util.isArrayBuffer)(value));\r\n            sink.enqueue(new Uint8Array(value), 1, [value]);\r\n          }).catch(function (reason) {\r\n            sink.error(reason);\r\n          });\r\n        };\r\n        sink.onCancel = function (reason) {\r\n          _this9._fullReader.cancel(reason);\r\n        };\r\n      }, this);\r\n      messageHandler.on('ReaderHeadersReady', function (data) {\r\n        var _this10 = this;\r\n\r\n        var headersCapability = (0, _util.createPromiseCapability)();\r\n        var fullReader = this._fullReader;\r\n        fullReader.headersReady.then(function () {\r\n          if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\r\n            if (_this10._lastProgress) {\r\n              var _loadingTask = _this10.loadingTask;\r\n              if (_loadingTask.onProgress) {\r\n                _loadingTask.onProgress(_this10._lastProgress);\r\n              }\r\n            }\r\n            fullReader.onProgress = function (evt) {\r\n              var loadingTask = _this10.loadingTask;\r\n              if (loadingTask.onProgress) {\r\n                loadingTask.onProgress({\r\n                  loaded: evt.loaded,\r\n                  total: evt.total\r\n                });\r\n              }\r\n            };\r\n          }\r\n          headersCapability.resolve({\r\n            isStreamingSupported: fullReader.isStreamingSupported,\r\n            isRangeSupported: fullReader.isRangeSupported,\r\n            contentLength: fullReader.contentLength\r\n          });\r\n        }, headersCapability.reject);\r\n        return headersCapability.promise;\r\n      }, this);\r\n      messageHandler.on('GetRangeReader', function (data, sink) {\r\n        (0, _util.assert)(this._networkStream);\r\n        var _rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\r\n        sink.onPull = function () {\r\n          _rangeReader.read().then(function (_ref4) {\r\n            var value = _ref4.value,\r\n                done = _ref4.done;\r\n\r\n            if (done) {\r\n              sink.close();\r\n              return;\r\n            }\r\n            (0, _util.assert)((0, _util.isArrayBuffer)(value));\r\n            sink.enqueue(new Uint8Array(value), 1, [value]);\r\n          }).catch(function (reason) {\r\n            sink.error(reason);\r\n          });\r\n        };\r\n        sink.onCancel = function (reason) {\r\n          _rangeReader.cancel(reason);\r\n        };\r\n      }, this);\r\n      messageHandler.on('GetDoc', function transportDoc(_ref5) {\r\n        var pdfInfo = _ref5.pdfInfo;\r\n\r\n        this.numPages = pdfInfo.numPages;\r\n        var loadingTask = this.loadingTask;\r\n        var pdfDocument = new PDFDocumentProxy(pdfInfo, this, loadingTask);\r\n        this.pdfDocument = pdfDocument;\r\n        loadingTask._capability.resolve(pdfDocument);\r\n      }, this);\r\n      messageHandler.on('PasswordRequest', function transportPasswordRequest(exception) {\r\n        var _this11 = this;\r\n\r\n        this._passwordCapability = (0, _util.createPromiseCapability)();\r\n        if (loadingTask.onPassword) {\r\n          var updatePassword = function updatePassword(password) {\r\n            _this11._passwordCapability.resolve({ password: password });\r\n          };\r\n          loadingTask.onPassword(updatePassword, exception.code);\r\n        } else {\r\n          this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\r\n        }\r\n        return this._passwordCapability.promise;\r\n      }, this);\r\n      messageHandler.on('PasswordException', function transportPasswordException(exception) {\r\n        loadingTask._capability.reject(new _util.PasswordException(exception.message, exception.code));\r\n      }, this);\r\n      messageHandler.on('InvalidPDF', function transportInvalidPDF(exception) {\r\n        this.loadingTask._capability.reject(new _util.InvalidPDFException(exception.message));\r\n      }, this);\r\n      messageHandler.on('MissingPDF', function transportMissingPDF(exception) {\r\n        this.loadingTask._capability.reject(new _util.MissingPDFException(exception.message));\r\n      }, this);\r\n      messageHandler.on('UnexpectedResponse', function transportUnexpectedResponse(exception) {\r\n        this.loadingTask._capability.reject(new _util.UnexpectedResponseException(exception.message, exception.status));\r\n      }, this);\r\n      messageHandler.on('UnknownError', function transportUnknownError(exception) {\r\n        this.loadingTask._capability.reject(new _util.UnknownErrorException(exception.message, exception.details));\r\n      }, this);\r\n      messageHandler.on('DataLoaded', function transportPage(data) {\r\n        this.downloadInfoCapability.resolve(data);\r\n      }, this);\r\n      messageHandler.on('PDFManagerReady', function transportPage(data) {}, this);\r\n      messageHandler.on('StartRenderPage', function transportRender(data) {\r\n        if (this.destroyed) {\r\n          return;\r\n        }\r\n        var page = this.pageCache[data.pageIndex];\r\n        page._stats.timeEnd('Page Request');\r\n        page._startRenderPage(data.transparency, data.intent);\r\n      }, this);\r\n      messageHandler.on('RenderPageChunk', function transportRender(data) {\r\n        if (this.destroyed) {\r\n          return;\r\n        }\r\n        var page = this.pageCache[data.pageIndex];\r\n        page._renderPageChunk(data.operatorList, data.intent);\r\n      }, this);\r\n      messageHandler.on('commonobj', function transportObj(data) {\r\n        var _this12 = this;\r\n\r\n        if (this.destroyed) {\r\n          return;\r\n        }\r\n        var id = data[0];\r\n        var type = data[1];\r\n        if (this.commonObjs.hasData(id)) {\r\n          return;\r\n        }\r\n        switch (type) {\r\n          case 'Font':\r\n            var exportedData = data[2];\r\n            var params = this._params;\r\n            if ('error' in exportedData) {\r\n              var exportedError = exportedData.error;\r\n              (0, _util.warn)('Error during font loading: ' + exportedError);\r\n              this.commonObjs.resolve(id, exportedError);\r\n              break;\r\n            }\r\n            var fontRegistry = null;\r\n            if (params.pdfBug && _global_scope2.default.FontInspector && _global_scope2.default.FontInspector.enabled) {\r\n              fontRegistry = {\r\n                registerFont: function registerFont(font, url) {\r\n                  _global_scope2.default['FontInspector'].fontAdded(font, url);\r\n                }\r\n              };\r\n            }\r\n            var font = new _font_loader.FontFaceObject(exportedData, {\r\n              isEvalSupported: params.isEvalSupported,\r\n              disableFontFace: params.disableFontFace,\r\n              fontRegistry: fontRegistry\r\n            });\r\n            var fontReady = function fontReady(fontObjs) {\r\n              _this12.commonObjs.resolve(id, font);\r\n            };\r\n            this.fontLoader.bind([font], fontReady);\r\n            break;\r\n          case 'FontPath':\r\n            this.commonObjs.resolve(id, data[2]);\r\n            break;\r\n          default:\r\n            throw new Error('Got unknown common object type ' + type);\r\n        }\r\n      }, this);\r\n      messageHandler.on('obj', function transportObj(data) {\r\n        if (this.destroyed) {\r\n          return;\r\n        }\r\n        var id = data[0];\r\n        var pageIndex = data[1];\r\n        var type = data[2];\r\n        var pageProxy = this.pageCache[pageIndex];\r\n        var imageData;\r\n        if (pageProxy.objs.hasData(id)) {\r\n          return;\r\n        }\r\n        switch (type) {\r\n          case 'JpegStream':\r\n            imageData = data[3];\r\n            return new Promise(function (resolve, reject) {\r\n              var img = new Image();\r\n              img.onload = function () {\r\n                resolve(img);\r\n              };\r\n              img.onerror = function () {\r\n                reject(new Error('Error during JPEG image loading'));\r\n              };\r\n              img.src = imageData;\r\n            }).then(function (img) {\r\n              pageProxy.objs.resolve(id, img);\r\n            });\r\n          case 'Image':\r\n            imageData = data[3];\r\n            pageProxy.objs.resolve(id, imageData);\r\n            var MAX_IMAGE_SIZE_TO_STORE = 8000000;\r\n            if (imageData && 'data' in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {\r\n              pageProxy.cleanupAfterRender = true;\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('Got unknown object type ' + type);\r\n        }\r\n      }, this);\r\n      messageHandler.on('DocProgress', function transportDocProgress(data) {\r\n        if (this.destroyed) {\r\n          return;\r\n        }\r\n        var loadingTask = this.loadingTask;\r\n        if (loadingTask.onProgress) {\r\n          loadingTask.onProgress({\r\n            loaded: data.loaded,\r\n            total: data.total\r\n          });\r\n        }\r\n      }, this);\r\n      messageHandler.on('PageError', function transportError(data) {\r\n        if (this.destroyed) {\r\n          return;\r\n        }\r\n        var page = this.pageCache[data.pageNum - 1];\r\n        var intentState = page.intentStates[data.intent];\r\n        if (intentState.displayReadyCapability) {\r\n          intentState.displayReadyCapability.reject(data.error);\r\n        } else {\r\n          throw new Error(data.error);\r\n        }\r\n        if (intentState.operatorList) {\r\n          intentState.operatorList.lastChunk = true;\r\n          for (var i = 0; i < intentState.renderTasks.length; i++) {\r\n            intentState.renderTasks[i].operatorListChanged();\r\n          }\r\n        }\r\n      }, this);\r\n      messageHandler.on('UnsupportedFeature', function (data) {\r\n        if (this.destroyed) {\r\n          return;\r\n        }\r\n        var loadingTask = this.loadingTask;\r\n        if (loadingTask.onUnsupportedFeature) {\r\n          loadingTask.onUnsupportedFeature(data.featureId);\r\n        }\r\n      }, this);\r\n      messageHandler.on('JpegDecode', function (data) {\r\n        if (this.destroyed) {\r\n          return Promise.reject(new Error('Worker was destroyed'));\r\n        }\r\n        if (typeof document === 'undefined') {\r\n          return Promise.reject(new Error('\"document\" is not defined.'));\r\n        }\r\n        var imageUrl = data[0];\r\n        var components = data[1];\r\n        if (components !== 3 && components !== 1) {\r\n          return Promise.reject(new Error('Only 3 components or 1 component can be returned'));\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n          var img = new Image();\r\n          img.onload = function () {\r\n            var width = img.width;\r\n            var height = img.height;\r\n            var size = width * height;\r\n            var rgbaLength = size * 4;\r\n            var buf = new Uint8Array(size * components);\r\n            var tmpCanvas = document.createElement('canvas');\r\n            tmpCanvas.width = width;\r\n            tmpCanvas.height = height;\r\n            var tmpCtx = tmpCanvas.getContext('2d');\r\n            tmpCtx.drawImage(img, 0, 0);\r\n            var data = tmpCtx.getImageData(0, 0, width, height).data;\r\n            var i, j;\r\n            if (components === 3) {\r\n              for (i = 0, j = 0; i < rgbaLength; i += 4, j += 3) {\r\n                buf[j] = data[i];\r\n                buf[j + 1] = data[i + 1];\r\n                buf[j + 2] = data[i + 2];\r\n              }\r\n            } else if (components === 1) {\r\n              for (i = 0, j = 0; i < rgbaLength; i += 4, j++) {\r\n                buf[j] = data[i];\r\n              }\r\n            }\r\n            resolve({\r\n              data: buf,\r\n              width: width,\r\n              height: height\r\n            });\r\n          };\r\n          img.onerror = function () {\r\n            reject(new Error('JpegDecode failed to load image'));\r\n          };\r\n          img.src = imageUrl;\r\n        });\r\n      }, this);\r\n      messageHandler.on('FetchBuiltInCMap', function (data) {\r\n        if (this.destroyed) {\r\n          return Promise.reject(new Error('Worker was destroyed'));\r\n        }\r\n        return this.CMapReaderFactory.fetch({ name: data.name });\r\n      }, this);\r\n    },\r\n    getData: function WorkerTransport_getData() {\r\n      return this.messageHandler.sendWithPromise('GetData', null);\r\n    },\r\n    getPage: function getPage(pageNumber) {\r\n      var _this13 = this;\r\n\r\n      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this.numPages) {\r\n        return Promise.reject(new Error('Invalid page request'));\r\n      }\r\n      var pageIndex = pageNumber - 1;\r\n      if (pageIndex in this.pagePromises) {\r\n        return this.pagePromises[pageIndex];\r\n      }\r\n      var promise = this.messageHandler.sendWithPromise('GetPage', { pageIndex: pageIndex }).then(function (pageInfo) {\r\n        if (_this13.destroyed) {\r\n          throw new Error('Transport destroyed');\r\n        }\r\n        var page = new PDFPageProxy(pageIndex, pageInfo, _this13, _this13._params.pdfBug);\r\n        _this13.pageCache[pageIndex] = page;\r\n        return page;\r\n      });\r\n      this.pagePromises[pageIndex] = promise;\r\n      return promise;\r\n    },\r\n\r\n    getPageIndex: function WorkerTransport_getPageIndexByRef(ref) {\r\n      return this.messageHandler.sendWithPromise('GetPageIndex', { ref: ref }).catch(function (reason) {\r\n        return Promise.reject(new Error(reason));\r\n      });\r\n    },\r\n    getAnnotations: function WorkerTransport_getAnnotations(pageIndex, intent) {\r\n      return this.messageHandler.sendWithPromise('GetAnnotations', {\r\n        pageIndex: pageIndex,\r\n        intent: intent\r\n      });\r\n    },\r\n    getDestinations: function WorkerTransport_getDestinations() {\r\n      return this.messageHandler.sendWithPromise('GetDestinations', null);\r\n    },\r\n    getDestination: function WorkerTransport_getDestination(id) {\r\n      return this.messageHandler.sendWithPromise('GetDestination', { id: id });\r\n    },\r\n    getPageLabels: function WorkerTransport_getPageLabels() {\r\n      return this.messageHandler.sendWithPromise('GetPageLabels', null);\r\n    },\r\n    getPageMode: function getPageMode() {\r\n      return this.messageHandler.sendWithPromise('GetPageMode', null);\r\n    },\r\n\r\n    getAttachments: function WorkerTransport_getAttachments() {\r\n      return this.messageHandler.sendWithPromise('GetAttachments', null);\r\n    },\r\n    getJavaScript: function WorkerTransport_getJavaScript() {\r\n      return this.messageHandler.sendWithPromise('GetJavaScript', null);\r\n    },\r\n    getOutline: function WorkerTransport_getOutline() {\r\n      return this.messageHandler.sendWithPromise('GetOutline', null);\r\n    },\r\n    getMetadata: function WorkerTransport_getMetadata() {\r\n      var _this14 = this;\r\n\r\n      return this.messageHandler.sendWithPromise('GetMetadata', null).then(function (results) {\r\n        return {\r\n          info: results[0],\r\n          metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\r\n          contentDispositionFilename: _this14._fullReader ? _this14._fullReader.filename : null\r\n        };\r\n      });\r\n    },\r\n    getStats: function WorkerTransport_getStats() {\r\n      return this.messageHandler.sendWithPromise('GetStats', null);\r\n    },\r\n    startCleanup: function WorkerTransport_startCleanup() {\r\n      var _this15 = this;\r\n\r\n      this.messageHandler.sendWithPromise('Cleanup', null).then(function () {\r\n        for (var i = 0, ii = _this15.pageCache.length; i < ii; i++) {\r\n          var page = _this15.pageCache[i];\r\n          if (page) {\r\n            page.cleanup();\r\n          }\r\n        }\r\n        _this15.commonObjs.clear();\r\n        _this15.fontLoader.clear();\r\n      });\r\n    },\r\n    get loadingParams() {\r\n      var params = this._params;\r\n      return (0, _util.shadow)(this, 'loadingParams', {\r\n        disableRange: params.disableRange,\r\n        disableStream: params.disableStream,\r\n        disableAutoFetch: params.disableAutoFetch,\r\n        disableCreateObjectURL: params.disableCreateObjectURL\r\n      });\r\n    }\r\n  };\r\n  return WorkerTransport;\r\n}();\r\nvar PDFObjects = function PDFObjectsClosure() {\r\n  function PDFObjects() {\r\n    this.objs = Object.create(null);\r\n  }\r\n  PDFObjects.prototype = {\r\n    ensureObj: function PDFObjects_ensureObj(objId) {\r\n      if (this.objs[objId]) {\r\n        return this.objs[objId];\r\n      }\r\n      var obj = {\r\n        capability: (0, _util.createPromiseCapability)(),\r\n        data: null,\r\n        resolved: false\r\n      };\r\n      this.objs[objId] = obj;\r\n      return obj;\r\n    },\r\n    get: function PDFObjects_get(objId, callback) {\r\n      if (callback) {\r\n        this.ensureObj(objId).capability.promise.then(callback);\r\n        return null;\r\n      }\r\n      var obj = this.objs[objId];\r\n      if (!obj || !obj.resolved) {\r\n        throw new Error('Requesting object that isn\\'t resolved yet ' + objId);\r\n      }\r\n      return obj.data;\r\n    },\r\n    resolve: function PDFObjects_resolve(objId, data) {\r\n      var obj = this.ensureObj(objId);\r\n      obj.resolved = true;\r\n      obj.data = data;\r\n      obj.capability.resolve(data);\r\n    },\r\n    isResolved: function PDFObjects_isResolved(objId) {\r\n      var objs = this.objs;\r\n      if (!objs[objId]) {\r\n        return false;\r\n      }\r\n      return objs[objId].resolved;\r\n    },\r\n    hasData: function PDFObjects_hasData(objId) {\r\n      return this.isResolved(objId);\r\n    },\r\n    getData: function PDFObjects_getData(objId) {\r\n      var objs = this.objs;\r\n      if (!objs[objId] || !objs[objId].resolved) {\r\n        return null;\r\n      }\r\n      return objs[objId].data;\r\n    },\r\n    clear: function PDFObjects_clear() {\r\n      this.objs = Object.create(null);\r\n    }\r\n  };\r\n  return PDFObjects;\r\n}();\r\nvar RenderTask = function RenderTaskClosure() {\r\n  function RenderTask(internalRenderTask) {\r\n    this._internalRenderTask = internalRenderTask;\r\n    this.onContinue = null;\r\n  }\r\n  RenderTask.prototype = {\r\n    get promise() {\r\n      return this._internalRenderTask.capability.promise;\r\n    },\r\n    cancel: function RenderTask_cancel() {\r\n      this._internalRenderTask.cancel();\r\n    },\r\n    then: function RenderTask_then(onFulfilled, onRejected) {\r\n      return this.promise.then.apply(this.promise, arguments);\r\n    }\r\n  };\r\n  return RenderTask;\r\n}();\r\nvar InternalRenderTask = function InternalRenderTaskClosure() {\r\n  var canvasInRendering = new WeakMap();\r\n  function InternalRenderTask(callback, params, objs, commonObjs, operatorList, pageNumber, canvasFactory, webGLContext) {\r\n    var pdfBug = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\r\n\r\n    this.callback = callback;\r\n    this.params = params;\r\n    this.objs = objs;\r\n    this.commonObjs = commonObjs;\r\n    this.operatorListIdx = null;\r\n    this.operatorList = operatorList;\r\n    this.pageNumber = pageNumber;\r\n    this.canvasFactory = canvasFactory;\r\n    this.webGLContext = webGLContext;\r\n    this._pdfBug = pdfBug;\r\n    this.running = false;\r\n    this.graphicsReadyCallback = null;\r\n    this.graphicsReady = false;\r\n    this.useRequestAnimationFrame = false;\r\n    this.cancelled = false;\r\n    this.capability = (0, _util.createPromiseCapability)();\r\n    this.task = new RenderTask(this);\r\n    this._continueBound = this._continue.bind(this);\r\n    this._scheduleNextBound = this._scheduleNext.bind(this);\r\n    this._nextBound = this._next.bind(this);\r\n    this._canvas = params.canvasContext.canvas;\r\n  }\r\n  InternalRenderTask.prototype = {\r\n    initializeGraphics: function InternalRenderTask_initializeGraphics(transparency) {\r\n      if (this._canvas) {\r\n        if (canvasInRendering.has(this._canvas)) {\r\n          throw new Error('Cannot use the same canvas during multiple render() operations. ' + 'Use different canvas or ensure previous operations were ' + 'cancelled or completed.');\r\n        }\r\n        canvasInRendering.set(this._canvas, this);\r\n      }\r\n      if (this.cancelled) {\r\n        return;\r\n      }\r\n      if (this._pdfBug && _global_scope2.default.StepperManager && _global_scope2.default.StepperManager.enabled) {\r\n        this.stepper = _global_scope2.default.StepperManager.create(this.pageNumber - 1);\r\n        this.stepper.init(this.operatorList);\r\n        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\r\n      }\r\n      var params = this.params;\r\n      this.gfx = new _canvas.CanvasGraphics(params.canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, params.imageLayer);\r\n      this.gfx.beginDrawing({\r\n        transform: params.transform,\r\n        viewport: params.viewport,\r\n        transparency: transparency,\r\n        background: params.background\r\n      });\r\n      this.operatorListIdx = 0;\r\n      this.graphicsReady = true;\r\n      if (this.graphicsReadyCallback) {\r\n        this.graphicsReadyCallback();\r\n      }\r\n    },\r\n    cancel: function InternalRenderTask_cancel() {\r\n      this.running = false;\r\n      this.cancelled = true;\r\n      if (this._canvas) {\r\n        canvasInRendering.delete(this._canvas);\r\n      }\r\n      this.callback(new _dom_utils.RenderingCancelledException('Rendering cancelled, page ' + this.pageNumber, 'canvas'));\r\n    },\r\n    operatorListChanged: function InternalRenderTask_operatorListChanged() {\r\n      if (!this.graphicsReady) {\r\n        if (!this.graphicsReadyCallback) {\r\n          this.graphicsReadyCallback = this._continueBound;\r\n        }\r\n        return;\r\n      }\r\n      if (this.stepper) {\r\n        this.stepper.updateOperatorList(this.operatorList);\r\n      }\r\n      if (this.running) {\r\n        return;\r\n      }\r\n      this._continue();\r\n    },\r\n    _continue: function InternalRenderTask__continue() {\r\n      this.running = true;\r\n      if (this.cancelled) {\r\n        return;\r\n      }\r\n      if (this.task.onContinue) {\r\n        this.task.onContinue(this._scheduleNextBound);\r\n      } else {\r\n        this._scheduleNext();\r\n      }\r\n    },\r\n    _scheduleNext: function InternalRenderTask__scheduleNext() {\r\n      if (this.useRequestAnimationFrame && typeof window !== 'undefined') {\r\n        window.requestAnimationFrame(this._nextBound);\r\n      } else {\r\n        Promise.resolve(undefined).then(this._nextBound);\r\n      }\r\n    },\r\n    _next: function InternalRenderTask__next() {\r\n      if (this.cancelled) {\r\n        return;\r\n      }\r\n      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\r\n      if (this.operatorListIdx === this.operatorList.argsArray.length) {\r\n        this.running = false;\r\n        if (this.operatorList.lastChunk) {\r\n          this.gfx.endDrawing();\r\n          if (this._canvas) {\r\n            canvasInRendering.delete(this._canvas);\r\n          }\r\n          this.callback();\r\n        }\r\n      }\r\n    }\r\n  };\r\n  return InternalRenderTask;\r\n}();\r\nvar version, build;\r\n{\r\n  exports.version = version = '2.0.489';\r\n  exports.build = build = '7d7bc80e';\r\n}\r\nexports.getDocument = getDocument;\r\nexports.LoopbackPort = LoopbackPort;\r\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\r\nexports.PDFWorker = PDFWorker;\r\nexports.PDFDocumentProxy = PDFDocumentProxy;\r\nexports.PDFPageProxy = PDFPageProxy;\r\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\r\nexports.version = version;\r\nexports.build = build;\r\n\r\n/***/ }),\r\n/* 118 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.FontLoader = exports.FontFaceObject = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nfunction FontLoader(docId) {\r\n  this.docId = docId;\r\n  this.styleElement = null;\r\n  this.nativeFontFaces = [];\r\n  this.loadTestFontId = 0;\r\n  this.loadingContext = {\r\n    requests: [],\r\n    nextRequestId: 0\r\n  };\r\n}\r\nFontLoader.prototype = {\r\n  insertRule: function fontLoaderInsertRule(rule) {\r\n    var styleElement = this.styleElement;\r\n    if (!styleElement) {\r\n      styleElement = this.styleElement = document.createElement('style');\r\n      styleElement.id = 'PDFJS_FONT_STYLE_TAG_' + this.docId;\r\n      document.documentElement.getElementsByTagName('head')[0].appendChild(styleElement);\r\n    }\r\n    var styleSheet = styleElement.sheet;\r\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\r\n  },\r\n  clear: function fontLoaderClear() {\r\n    if (this.styleElement) {\r\n      this.styleElement.remove();\r\n      this.styleElement = null;\r\n    }\r\n    this.nativeFontFaces.forEach(function (nativeFontFace) {\r\n      document.fonts.delete(nativeFontFace);\r\n    });\r\n    this.nativeFontFaces.length = 0;\r\n  }\r\n};\r\n{\r\n  var getLoadTestFont = function getLoadTestFont() {\r\n    return atob('T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ' + 'AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA' + 'AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm' + 'FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA' + 'AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A' + 'ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA' + 'MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA' + 'AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA' + 'AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ' + 'AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA' + 'AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA' + 'EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA' + 'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA' + 'AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc' + 'A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF' + 'hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA' + 'AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg' + 'ABAAAAAAAAAAAD6AAAAAAAAA==');\r\n  };\r\n  Object.defineProperty(FontLoader.prototype, 'loadTestFont', {\r\n    get: function get() {\r\n      return (0, _util.shadow)(this, 'loadTestFont', getLoadTestFont());\r\n    },\r\n\r\n    configurable: true\r\n  });\r\n  FontLoader.prototype.addNativeFontFace = function fontLoader_addNativeFontFace(nativeFontFace) {\r\n    this.nativeFontFaces.push(nativeFontFace);\r\n    document.fonts.add(nativeFontFace);\r\n  };\r\n  FontLoader.prototype.bind = function fontLoaderBind(fonts, callback) {\r\n    var rules = [];\r\n    var fontsToLoad = [];\r\n    var fontLoadPromises = [];\r\n    var getNativeFontPromise = function getNativeFontPromise(nativeFontFace) {\r\n      return nativeFontFace.loaded.catch(function (e) {\r\n        (0, _util.warn)('Failed to load font \"' + nativeFontFace.family + '\": ' + e);\r\n      });\r\n    };\r\n    var isFontLoadingAPISupported = FontLoader.isFontLoadingAPISupported && !FontLoader.isSyncFontLoadingSupported;\r\n    for (var i = 0, ii = fonts.length; i < ii; i++) {\r\n      var font = fonts[i];\r\n      if (font.attached || font.loading === false) {\r\n        continue;\r\n      }\r\n      font.attached = true;\r\n      if (isFontLoadingAPISupported) {\r\n        var nativeFontFace = font.createNativeFontFace();\r\n        if (nativeFontFace) {\r\n          this.addNativeFontFace(nativeFontFace);\r\n          fontLoadPromises.push(getNativeFontPromise(nativeFontFace));\r\n        }\r\n      } else {\r\n        var rule = font.createFontFaceRule();\r\n        if (rule) {\r\n          this.insertRule(rule);\r\n          rules.push(rule);\r\n          fontsToLoad.push(font);\r\n        }\r\n      }\r\n    }\r\n    var request = this.queueLoadingCallback(callback);\r\n    if (isFontLoadingAPISupported) {\r\n      Promise.all(fontLoadPromises).then(function () {\r\n        request.complete();\r\n      });\r\n    } else if (rules.length > 0 && !FontLoader.isSyncFontLoadingSupported) {\r\n      this.prepareFontLoadEvent(rules, fontsToLoad, request);\r\n    } else {\r\n      request.complete();\r\n    }\r\n  };\r\n  FontLoader.prototype.queueLoadingCallback = function FontLoader_queueLoadingCallback(callback) {\r\n    function LoadLoader_completeRequest() {\r\n      (0, _util.assert)(!request.end, 'completeRequest() cannot be called twice');\r\n      request.end = Date.now();\r\n      while (context.requests.length > 0 && context.requests[0].end) {\r\n        var otherRequest = context.requests.shift();\r\n        setTimeout(otherRequest.callback, 0);\r\n      }\r\n    }\r\n    var context = this.loadingContext;\r\n    var requestId = 'pdfjs-font-loading-' + context.nextRequestId++;\r\n    var request = {\r\n      id: requestId,\r\n      complete: LoadLoader_completeRequest,\r\n      callback: callback,\r\n      started: Date.now()\r\n    };\r\n    context.requests.push(request);\r\n    return request;\r\n  };\r\n  FontLoader.prototype.prepareFontLoadEvent = function fontLoaderPrepareFontLoadEvent(rules, fonts, request) {\r\n    function int32(data, offset) {\r\n      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\r\n    }\r\n    function spliceString(s, offset, remove, insert) {\r\n      var chunk1 = s.substr(0, offset);\r\n      var chunk2 = s.substr(offset + remove);\r\n      return chunk1 + insert + chunk2;\r\n    }\r\n    var i, ii;\r\n    var canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = 1;\r\n    var ctx = canvas.getContext('2d');\r\n    var called = 0;\r\n    function isFontReady(name, callback) {\r\n      called++;\r\n      if (called > 30) {\r\n        (0, _util.warn)('Load test font never loaded.');\r\n        callback();\r\n        return;\r\n      }\r\n      ctx.font = '30px ' + name;\r\n      ctx.fillText('.', 0, 20);\r\n      var imageData = ctx.getImageData(0, 0, 1, 1);\r\n      if (imageData.data[3] > 0) {\r\n        callback();\r\n        return;\r\n      }\r\n      setTimeout(isFontReady.bind(null, name, callback));\r\n    }\r\n    var loadTestFontId = 'lt' + Date.now() + this.loadTestFontId++;\r\n    var data = this.loadTestFont;\r\n    var COMMENT_OFFSET = 976;\r\n    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\r\n    var CFF_CHECKSUM_OFFSET = 16;\r\n    var XXXX_VALUE = 0x58585858;\r\n    var checksum = int32(data, CFF_CHECKSUM_OFFSET);\r\n    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\r\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\r\n    }\r\n    if (i < loadTestFontId.length) {\r\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + 'XXX', i) | 0;\r\n    }\r\n    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\r\n    var url = 'url(data:font/opentype;base64,' + btoa(data) + ');';\r\n    var rule = '@font-face { font-family:\"' + loadTestFontId + '\";src:' + url + '}';\r\n    this.insertRule(rule);\r\n    var names = [];\r\n    for (i = 0, ii = fonts.length; i < ii; i++) {\r\n      names.push(fonts[i].loadedName);\r\n    }\r\n    names.push(loadTestFontId);\r\n    var div = document.createElement('div');\r\n    div.setAttribute('style', 'visibility: hidden;' + 'width: 10px; height: 10px;' + 'position: absolute; top: 0px; left: 0px;');\r\n    for (i = 0, ii = names.length; i < ii; ++i) {\r\n      var span = document.createElement('span');\r\n      span.textContent = 'Hi';\r\n      span.style.fontFamily = names[i];\r\n      div.appendChild(span);\r\n    }\r\n    document.body.appendChild(div);\r\n    isFontReady(loadTestFontId, function () {\r\n      document.body.removeChild(div);\r\n      request.complete();\r\n    });\r\n  };\r\n}\r\n{\r\n  FontLoader.isFontLoadingAPISupported = typeof document !== 'undefined' && !!document.fonts;\r\n}\r\n{\r\n  var isSyncFontLoadingSupported = function isSyncFontLoadingSupported() {\r\n    if (typeof navigator === 'undefined') {\r\n      return true;\r\n    }\r\n    var supported = false;\r\n    var m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\r\n    if (m && m[1] >= 14) {\r\n      supported = true;\r\n    }\r\n    return supported;\r\n  };\r\n  Object.defineProperty(FontLoader, 'isSyncFontLoadingSupported', {\r\n    get: function get() {\r\n      return (0, _util.shadow)(FontLoader, 'isSyncFontLoadingSupported', isSyncFontLoadingSupported());\r\n    },\r\n\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n}\r\nvar IsEvalSupportedCached = {\r\n  get value() {\r\n    return (0, _util.shadow)(this, 'value', (0, _util.isEvalSupported)());\r\n  }\r\n};\r\nvar FontFaceObject = function FontFaceObjectClosure() {\r\n  function FontFaceObject(translatedData, _ref) {\r\n    var _ref$isEvalSupported = _ref.isEvalSupported,\r\n        isEvalSupported = _ref$isEvalSupported === undefined ? true : _ref$isEvalSupported,\r\n        _ref$disableFontFace = _ref.disableFontFace,\r\n        disableFontFace = _ref$disableFontFace === undefined ? false : _ref$disableFontFace,\r\n        _ref$fontRegistry = _ref.fontRegistry,\r\n        fontRegistry = _ref$fontRegistry === undefined ? null : _ref$fontRegistry;\r\n\r\n    this.compiledGlyphs = Object.create(null);\r\n    for (var i in translatedData) {\r\n      this[i] = translatedData[i];\r\n    }\r\n    this.isEvalSupported = isEvalSupported !== false;\r\n    this.disableFontFace = disableFontFace === true;\r\n    this.fontRegistry = fontRegistry;\r\n  }\r\n  FontFaceObject.prototype = {\r\n    createNativeFontFace: function FontFaceObject_createNativeFontFace() {\r\n      if (!this.data || this.disableFontFace) {\r\n        return null;\r\n      }\r\n      var nativeFontFace = new FontFace(this.loadedName, this.data, {});\r\n      if (this.fontRegistry) {\r\n        this.fontRegistry.registerFont(this);\r\n      }\r\n      return nativeFontFace;\r\n    },\r\n    createFontFaceRule: function FontFaceObject_createFontFaceRule() {\r\n      if (!this.data || this.disableFontFace) {\r\n        return null;\r\n      }\r\n      var data = (0, _util.bytesToString)(new Uint8Array(this.data));\r\n      var fontName = this.loadedName;\r\n      var url = 'url(data:' + this.mimetype + ';base64,' + btoa(data) + ');';\r\n      var rule = '@font-face { font-family:\"' + fontName + '\";src:' + url + '}';\r\n      if (this.fontRegistry) {\r\n        this.fontRegistry.registerFont(this, url);\r\n      }\r\n      return rule;\r\n    },\r\n    getPathGenerator: function FontFaceObject_getPathGenerator(objs, character) {\r\n      if (!(character in this.compiledGlyphs)) {\r\n        var cmds = objs.get(this.loadedName + '_path_' + character);\r\n        var current, i, len;\r\n        if (this.isEvalSupported && IsEvalSupportedCached.value) {\r\n          var args,\r\n              js = '';\r\n          for (i = 0, len = cmds.length; i < len; i++) {\r\n            current = cmds[i];\r\n            if (current.args !== undefined) {\r\n              args = current.args.join(',');\r\n            } else {\r\n              args = '';\r\n            }\r\n            js += 'c.' + current.cmd + '(' + args + ');\\n';\r\n          }\r\n          this.compiledGlyphs[character] = new Function('c', 'size', js);\r\n        } else {\r\n          this.compiledGlyphs[character] = function (c, size) {\r\n            for (i = 0, len = cmds.length; i < len; i++) {\r\n              current = cmds[i];\r\n              if (current.cmd === 'scale') {\r\n                current.args = [size, -size];\r\n              }\r\n              c[current.cmd].apply(c, current.args);\r\n            }\r\n          };\r\n        }\r\n      }\r\n      return this.compiledGlyphs[character];\r\n    }\r\n  };\r\n  return FontFaceObject;\r\n}();\r\nexports.FontFaceObject = FontFaceObject;\r\nexports.FontLoader = FontLoader;\r\n\r\n/***/ }),\r\n/* 119 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.CanvasGraphics = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _pattern_helper = __w_pdfjs_require__(120);\r\n\r\nvar MIN_FONT_SIZE = 16;\r\nvar MAX_FONT_SIZE = 100;\r\nvar MAX_GROUP_SIZE = 4096;\r\nvar MIN_WIDTH_FACTOR = 0.65;\r\nvar COMPILE_TYPE3_GLYPHS = true;\r\nvar MAX_SIZE_TO_COMPILE = 1000;\r\nvar FULL_CHUNK_HEIGHT = 16;\r\nvar IsLittleEndianCached = {\r\n  get value() {\r\n    return (0, _util.shadow)(IsLittleEndianCached, 'value', (0, _util.isLittleEndian)());\r\n  }\r\n};\r\nfunction addContextCurrentTransform(ctx) {\r\n  if (!ctx.mozCurrentTransform) {\r\n    ctx._originalSave = ctx.save;\r\n    ctx._originalRestore = ctx.restore;\r\n    ctx._originalRotate = ctx.rotate;\r\n    ctx._originalScale = ctx.scale;\r\n    ctx._originalTranslate = ctx.translate;\r\n    ctx._originalTransform = ctx.transform;\r\n    ctx._originalSetTransform = ctx.setTransform;\r\n    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\r\n    ctx._transformStack = [];\r\n    Object.defineProperty(ctx, 'mozCurrentTransform', {\r\n      get: function getCurrentTransform() {\r\n        return this._transformMatrix;\r\n      }\r\n    });\r\n    Object.defineProperty(ctx, 'mozCurrentTransformInverse', {\r\n      get: function getCurrentTransformInverse() {\r\n        var m = this._transformMatrix;\r\n        var a = m[0],\r\n            b = m[1],\r\n            c = m[2],\r\n            d = m[3],\r\n            e = m[4],\r\n            f = m[5];\r\n        var ad_bc = a * d - b * c;\r\n        var bc_ad = b * c - a * d;\r\n        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\r\n      }\r\n    });\r\n    ctx.save = function ctxSave() {\r\n      var old = this._transformMatrix;\r\n      this._transformStack.push(old);\r\n      this._transformMatrix = old.slice(0, 6);\r\n      this._originalSave();\r\n    };\r\n    ctx.restore = function ctxRestore() {\r\n      var prev = this._transformStack.pop();\r\n      if (prev) {\r\n        this._transformMatrix = prev;\r\n        this._originalRestore();\r\n      }\r\n    };\r\n    ctx.translate = function ctxTranslate(x, y) {\r\n      var m = this._transformMatrix;\r\n      m[4] = m[0] * x + m[2] * y + m[4];\r\n      m[5] = m[1] * x + m[3] * y + m[5];\r\n      this._originalTranslate(x, y);\r\n    };\r\n    ctx.scale = function ctxScale(x, y) {\r\n      var m = this._transformMatrix;\r\n      m[0] = m[0] * x;\r\n      m[1] = m[1] * x;\r\n      m[2] = m[2] * y;\r\n      m[3] = m[3] * y;\r\n      this._originalScale(x, y);\r\n    };\r\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\r\n      var m = this._transformMatrix;\r\n      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\r\n      ctx._originalTransform(a, b, c, d, e, f);\r\n    };\r\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\r\n      this._transformMatrix = [a, b, c, d, e, f];\r\n      ctx._originalSetTransform(a, b, c, d, e, f);\r\n    };\r\n    ctx.rotate = function ctxRotate(angle) {\r\n      var cosValue = Math.cos(angle);\r\n      var sinValue = Math.sin(angle);\r\n      var m = this._transformMatrix;\r\n      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\r\n      this._originalRotate(angle);\r\n    };\r\n  }\r\n}\r\nvar CachedCanvases = function CachedCanvasesClosure() {\r\n  function CachedCanvases(canvasFactory) {\r\n    this.canvasFactory = canvasFactory;\r\n    this.cache = Object.create(null);\r\n  }\r\n  CachedCanvases.prototype = {\r\n    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {\r\n      var canvasEntry;\r\n      if (this.cache[id] !== undefined) {\r\n        canvasEntry = this.cache[id];\r\n        this.canvasFactory.reset(canvasEntry, width, height);\r\n        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\r\n      } else {\r\n        canvasEntry = this.canvasFactory.create(width, height);\r\n        this.cache[id] = canvasEntry;\r\n      }\r\n      if (trackTransform) {\r\n        addContextCurrentTransform(canvasEntry.context);\r\n      }\r\n      return canvasEntry;\r\n    },\r\n    clear: function clear() {\r\n      for (var id in this.cache) {\r\n        var canvasEntry = this.cache[id];\r\n        this.canvasFactory.destroy(canvasEntry);\r\n        delete this.cache[id];\r\n      }\r\n    }\r\n  };\r\n  return CachedCanvases;\r\n}();\r\nfunction compileType3Glyph(imgData) {\r\n  var POINT_TO_PROCESS_LIMIT = 1000;\r\n  var width = imgData.width,\r\n      height = imgData.height;\r\n  var i,\r\n      j,\r\n      j0,\r\n      width1 = width + 1;\r\n  var points = new Uint8Array(width1 * (height + 1));\r\n  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\r\n  var lineSize = width + 7 & ~7,\r\n      data0 = imgData.data;\r\n  var data = new Uint8Array(lineSize * height),\r\n      pos = 0,\r\n      ii;\r\n  for (i = 0, ii = data0.length; i < ii; i++) {\r\n    var mask = 128,\r\n        elem = data0[i];\r\n    while (mask > 0) {\r\n      data[pos++] = elem & mask ? 0 : 255;\r\n      mask >>= 1;\r\n    }\r\n  }\r\n  var count = 0;\r\n  pos = 0;\r\n  if (data[pos] !== 0) {\r\n    points[0] = 1;\r\n    ++count;\r\n  }\r\n  for (j = 1; j < width; j++) {\r\n    if (data[pos] !== data[pos + 1]) {\r\n      points[j] = data[pos] ? 2 : 1;\r\n      ++count;\r\n    }\r\n    pos++;\r\n  }\r\n  if (data[pos] !== 0) {\r\n    points[j] = 2;\r\n    ++count;\r\n  }\r\n  for (i = 1; i < height; i++) {\r\n    pos = i * lineSize;\r\n    j0 = i * width1;\r\n    if (data[pos - lineSize] !== data[pos]) {\r\n      points[j0] = data[pos] ? 1 : 8;\r\n      ++count;\r\n    }\r\n    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\r\n    for (j = 1; j < width; j++) {\r\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\r\n      if (POINT_TYPES[sum]) {\r\n        points[j0 + j] = POINT_TYPES[sum];\r\n        ++count;\r\n      }\r\n      pos++;\r\n    }\r\n    if (data[pos - lineSize] !== data[pos]) {\r\n      points[j0 + j] = data[pos] ? 2 : 4;\r\n      ++count;\r\n    }\r\n    if (count > POINT_TO_PROCESS_LIMIT) {\r\n      return null;\r\n    }\r\n  }\r\n  pos = lineSize * (height - 1);\r\n  j0 = i * width1;\r\n  if (data[pos] !== 0) {\r\n    points[j0] = 8;\r\n    ++count;\r\n  }\r\n  for (j = 1; j < width; j++) {\r\n    if (data[pos] !== data[pos + 1]) {\r\n      points[j0 + j] = data[pos] ? 4 : 8;\r\n      ++count;\r\n    }\r\n    pos++;\r\n  }\r\n  if (data[pos] !== 0) {\r\n    points[j0 + j] = 4;\r\n    ++count;\r\n  }\r\n  if (count > POINT_TO_PROCESS_LIMIT) {\r\n    return null;\r\n  }\r\n  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\r\n  var outlines = [];\r\n  for (i = 0; count && i <= height; i++) {\r\n    var p = i * width1;\r\n    var end = p + width;\r\n    while (p < end && !points[p]) {\r\n      p++;\r\n    }\r\n    if (p === end) {\r\n      continue;\r\n    }\r\n    var coords = [p % width1, i];\r\n    var type = points[p],\r\n        p0 = p,\r\n        pp;\r\n    do {\r\n      var step = steps[type];\r\n      do {\r\n        p += step;\r\n      } while (!points[p]);\r\n      pp = points[p];\r\n      if (pp !== 5 && pp !== 10) {\r\n        type = pp;\r\n        points[p] = 0;\r\n      } else {\r\n        type = pp & 0x33 * type >> 4;\r\n        points[p] &= type >> 2 | type << 2;\r\n      }\r\n      coords.push(p % width1);\r\n      coords.push(p / width1 | 0);\r\n      --count;\r\n    } while (p0 !== p);\r\n    outlines.push(coords);\r\n    --i;\r\n  }\r\n  var drawOutline = function drawOutline(c) {\r\n    c.save();\r\n    c.scale(1 / width, -1 / height);\r\n    c.translate(0, -height);\r\n    c.beginPath();\r\n    for (var i = 0, ii = outlines.length; i < ii; i++) {\r\n      var o = outlines[i];\r\n      c.moveTo(o[0], o[1]);\r\n      for (var j = 2, jj = o.length; j < jj; j += 2) {\r\n        c.lineTo(o[j], o[j + 1]);\r\n      }\r\n    }\r\n    c.fill();\r\n    c.beginPath();\r\n    c.restore();\r\n  };\r\n  return drawOutline;\r\n}\r\nvar CanvasExtraState = function CanvasExtraStateClosure() {\r\n  function CanvasExtraState() {\r\n    this.alphaIsShape = false;\r\n    this.fontSize = 0;\r\n    this.fontSizeScale = 1;\r\n    this.textMatrix = _util.IDENTITY_MATRIX;\r\n    this.textMatrixScale = 1;\r\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\r\n    this.leading = 0;\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.lineX = 0;\r\n    this.lineY = 0;\r\n    this.charSpacing = 0;\r\n    this.wordSpacing = 0;\r\n    this.textHScale = 1;\r\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\r\n    this.textRise = 0;\r\n    this.fillColor = '#000000';\r\n    this.strokeColor = '#000000';\r\n    this.patternFill = false;\r\n    this.fillAlpha = 1;\r\n    this.strokeAlpha = 1;\r\n    this.lineWidth = 1;\r\n    this.activeSMask = null;\r\n    this.resumeSMaskCtx = null;\r\n  }\r\n  CanvasExtraState.prototype = {\r\n    clone: function CanvasExtraState_clone() {\r\n      return Object.create(this);\r\n    },\r\n    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n  };\r\n  return CanvasExtraState;\r\n}();\r\nvar CanvasGraphics = function CanvasGraphicsClosure() {\r\n  var EXECUTION_TIME = 15;\r\n  var EXECUTION_STEPS = 10;\r\n  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) {\r\n    this.ctx = canvasCtx;\r\n    this.current = new CanvasExtraState();\r\n    this.stateStack = [];\r\n    this.pendingClip = null;\r\n    this.pendingEOFill = false;\r\n    this.res = null;\r\n    this.xobjs = null;\r\n    this.commonObjs = commonObjs;\r\n    this.objs = objs;\r\n    this.canvasFactory = canvasFactory;\r\n    this.webGLContext = webGLContext;\r\n    this.imageLayer = imageLayer;\r\n    this.groupStack = [];\r\n    this.processingType3 = null;\r\n    this.baseTransform = null;\r\n    this.baseTransformStack = [];\r\n    this.groupLevel = 0;\r\n    this.smaskStack = [];\r\n    this.smaskCounter = 0;\r\n    this.tempSMask = null;\r\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\r\n    if (canvasCtx) {\r\n      addContextCurrentTransform(canvasCtx);\r\n    }\r\n    this.cachedGetSinglePixelWidth = null;\r\n  }\r\n  function putBinaryImageData(ctx, imgData) {\r\n    if (typeof ImageData !== 'undefined' && imgData instanceof ImageData) {\r\n      ctx.putImageData(imgData, 0, 0);\r\n      return;\r\n    }\r\n    var height = imgData.height,\r\n        width = imgData.width;\r\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\r\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\r\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\r\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\r\n    var srcPos = 0,\r\n        destPos;\r\n    var src = imgData.data;\r\n    var dest = chunkImgData.data;\r\n    var i, j, thisChunkHeight, elemsInThisChunk;\r\n    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\r\n      var srcLength = src.byteLength;\r\n      var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\r\n      var dest32DataLength = dest32.length;\r\n      var fullSrcDiff = width + 7 >> 3;\r\n      var white = 0xFFFFFFFF;\r\n      var black = IsLittleEndianCached.value ? 0xFF000000 : 0x000000FF;\r\n      for (i = 0; i < totalChunks; i++) {\r\n        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\r\n        destPos = 0;\r\n        for (j = 0; j < thisChunkHeight; j++) {\r\n          var srcDiff = srcLength - srcPos;\r\n          var k = 0;\r\n          var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\r\n          var kEndUnrolled = kEnd & ~7;\r\n          var mask = 0;\r\n          var srcByte = 0;\r\n          for (; k < kEndUnrolled; k += 8) {\r\n            srcByte = src[srcPos++];\r\n            dest32[destPos++] = srcByte & 128 ? white : black;\r\n            dest32[destPos++] = srcByte & 64 ? white : black;\r\n            dest32[destPos++] = srcByte & 32 ? white : black;\r\n            dest32[destPos++] = srcByte & 16 ? white : black;\r\n            dest32[destPos++] = srcByte & 8 ? white : black;\r\n            dest32[destPos++] = srcByte & 4 ? white : black;\r\n            dest32[destPos++] = srcByte & 2 ? white : black;\r\n            dest32[destPos++] = srcByte & 1 ? white : black;\r\n          }\r\n          for (; k < kEnd; k++) {\r\n            if (mask === 0) {\r\n              srcByte = src[srcPos++];\r\n              mask = 128;\r\n            }\r\n            dest32[destPos++] = srcByte & mask ? white : black;\r\n            mask >>= 1;\r\n          }\r\n        }\r\n        while (destPos < dest32DataLength) {\r\n          dest32[destPos++] = 0;\r\n        }\r\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\r\n      }\r\n    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\r\n      j = 0;\r\n      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\r\n      for (i = 0; i < fullChunks; i++) {\r\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\r\n        srcPos += elemsInThisChunk;\r\n        ctx.putImageData(chunkImgData, 0, j);\r\n        j += FULL_CHUNK_HEIGHT;\r\n      }\r\n      if (i < totalChunks) {\r\n        elemsInThisChunk = width * partialChunkHeight * 4;\r\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\r\n        ctx.putImageData(chunkImgData, 0, j);\r\n      }\r\n    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\r\n      thisChunkHeight = FULL_CHUNK_HEIGHT;\r\n      elemsInThisChunk = width * thisChunkHeight;\r\n      for (i = 0; i < totalChunks; i++) {\r\n        if (i >= fullChunks) {\r\n          thisChunkHeight = partialChunkHeight;\r\n          elemsInThisChunk = width * thisChunkHeight;\r\n        }\r\n        destPos = 0;\r\n        for (j = elemsInThisChunk; j--;) {\r\n          dest[destPos++] = src[srcPos++];\r\n          dest[destPos++] = src[srcPos++];\r\n          dest[destPos++] = src[srcPos++];\r\n          dest[destPos++] = 255;\r\n        }\r\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\r\n      }\r\n    } else {\r\n      throw new Error('bad image kind: ' + imgData.kind);\r\n    }\r\n  }\r\n  function putBinaryImageMask(ctx, imgData) {\r\n    var height = imgData.height,\r\n        width = imgData.width;\r\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\r\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\r\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\r\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\r\n    var srcPos = 0;\r\n    var src = imgData.data;\r\n    var dest = chunkImgData.data;\r\n    for (var i = 0; i < totalChunks; i++) {\r\n      var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\r\n      var destPos = 3;\r\n      for (var j = 0; j < thisChunkHeight; j++) {\r\n        var mask = 0;\r\n        for (var k = 0; k < width; k++) {\r\n          if (!mask) {\r\n            var elem = src[srcPos++];\r\n            mask = 128;\r\n          }\r\n          dest[destPos] = elem & mask ? 0 : 255;\r\n          destPos += 4;\r\n          mask >>= 1;\r\n        }\r\n      }\r\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\r\n    }\r\n  }\r\n  function copyCtxState(sourceCtx, destCtx) {\r\n    var properties = ['strokeStyle', 'fillStyle', 'fillRule', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'miterLimit', 'globalCompositeOperation', 'font'];\r\n    for (var i = 0, ii = properties.length; i < ii; i++) {\r\n      var property = properties[i];\r\n      if (sourceCtx[property] !== undefined) {\r\n        destCtx[property] = sourceCtx[property];\r\n      }\r\n    }\r\n    if (sourceCtx.setLineDash !== undefined) {\r\n      destCtx.setLineDash(sourceCtx.getLineDash());\r\n      destCtx.lineDashOffset = sourceCtx.lineDashOffset;\r\n    }\r\n  }\r\n  function resetCtxToDefault(ctx) {\r\n    ctx.strokeStyle = '#000000';\r\n    ctx.fillStyle = '#000000';\r\n    ctx.fillRule = 'nonzero';\r\n    ctx.globalAlpha = 1;\r\n    ctx.lineWidth = 1;\r\n    ctx.lineCap = 'butt';\r\n    ctx.lineJoin = 'miter';\r\n    ctx.miterLimit = 10;\r\n    ctx.globalCompositeOperation = 'source-over';\r\n    ctx.font = '10px sans-serif';\r\n    if (ctx.setLineDash !== undefined) {\r\n      ctx.setLineDash([]);\r\n      ctx.lineDashOffset = 0;\r\n    }\r\n  }\r\n  function composeSMaskBackdrop(bytes, r0, g0, b0) {\r\n    var length = bytes.length;\r\n    for (var i = 3; i < length; i += 4) {\r\n      var alpha = bytes[i];\r\n      if (alpha === 0) {\r\n        bytes[i - 3] = r0;\r\n        bytes[i - 2] = g0;\r\n        bytes[i - 1] = b0;\r\n      } else if (alpha < 255) {\r\n        var alpha_ = 255 - alpha;\r\n        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\r\n        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\r\n        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\r\n      }\r\n    }\r\n  }\r\n  function composeSMaskAlpha(maskData, layerData, transferMap) {\r\n    var length = maskData.length;\r\n    var scale = 1 / 255;\r\n    for (var i = 3; i < length; i += 4) {\r\n      var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\r\n      layerData[i] = layerData[i] * alpha * scale | 0;\r\n    }\r\n  }\r\n  function composeSMaskLuminosity(maskData, layerData, transferMap) {\r\n    var length = maskData.length;\r\n    for (var i = 3; i < length; i += 4) {\r\n      var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\r\n      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\r\n    }\r\n  }\r\n  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {\r\n    var hasBackdrop = !!backdrop;\r\n    var r0 = hasBackdrop ? backdrop[0] : 0;\r\n    var g0 = hasBackdrop ? backdrop[1] : 0;\r\n    var b0 = hasBackdrop ? backdrop[2] : 0;\r\n    var composeFn;\r\n    if (subtype === 'Luminosity') {\r\n      composeFn = composeSMaskLuminosity;\r\n    } else {\r\n      composeFn = composeSMaskAlpha;\r\n    }\r\n    var PIXELS_TO_PROCESS = 1048576;\r\n    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\r\n    for (var row = 0; row < height; row += chunkSize) {\r\n      var chunkHeight = Math.min(chunkSize, height - row);\r\n      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);\r\n      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);\r\n      if (hasBackdrop) {\r\n        composeSMaskBackdrop(maskData.data, r0, g0, b0);\r\n      }\r\n      composeFn(maskData.data, layerData.data, transferMap);\r\n      maskCtx.putImageData(layerData, 0, row);\r\n    }\r\n  }\r\n  function composeSMask(ctx, smask, layerCtx, webGLContext) {\r\n    var mask = smask.canvas;\r\n    var maskCtx = smask.context;\r\n    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);\r\n    var backdrop = smask.backdrop || null;\r\n    if (!smask.transferMap && webGLContext.isEnabled) {\r\n      var composed = webGLContext.composeSMask({\r\n        layer: layerCtx.canvas,\r\n        mask: mask,\r\n        properties: {\r\n          subtype: smask.subtype,\r\n          backdrop: backdrop\r\n        }\r\n      });\r\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n      ctx.drawImage(composed, smask.offsetX, smask.offsetY);\r\n      return;\r\n    }\r\n    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);\r\n    ctx.drawImage(mask, 0, 0);\r\n  }\r\n  var LINE_CAP_STYLES = ['butt', 'round', 'square'];\r\n  var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];\r\n  var NORMAL_CLIP = {};\r\n  var EO_CLIP = {};\r\n  CanvasGraphics.prototype = {\r\n    beginDrawing: function beginDrawing(_ref) {\r\n      var transform = _ref.transform,\r\n          viewport = _ref.viewport,\r\n          transparency = _ref.transparency,\r\n          _ref$background = _ref.background,\r\n          background = _ref$background === undefined ? null : _ref$background;\r\n\r\n      var width = this.ctx.canvas.width;\r\n      var height = this.ctx.canvas.height;\r\n      this.ctx.save();\r\n      this.ctx.fillStyle = background || 'rgb(255, 255, 255)';\r\n      this.ctx.fillRect(0, 0, width, height);\r\n      this.ctx.restore();\r\n      if (transparency) {\r\n        var transparentCanvas = this.cachedCanvases.getCanvas('transparent', width, height, true);\r\n        this.compositeCtx = this.ctx;\r\n        this.transparentCanvas = transparentCanvas.canvas;\r\n        this.ctx = transparentCanvas.context;\r\n        this.ctx.save();\r\n        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\r\n      }\r\n      this.ctx.save();\r\n      resetCtxToDefault(this.ctx);\r\n      if (transform) {\r\n        this.ctx.transform.apply(this.ctx, transform);\r\n      }\r\n      this.ctx.transform.apply(this.ctx, viewport.transform);\r\n      this.baseTransform = this.ctx.mozCurrentTransform.slice();\r\n      if (this.imageLayer) {\r\n        this.imageLayer.beginLayout();\r\n      }\r\n    },\r\n\r\n    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\r\n      var argsArray = operatorList.argsArray;\r\n      var fnArray = operatorList.fnArray;\r\n      var i = executionStartIdx || 0;\r\n      var argsArrayLen = argsArray.length;\r\n      if (argsArrayLen === i) {\r\n        return i;\r\n      }\r\n      var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === 'function';\r\n      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\r\n      var steps = 0;\r\n      var commonObjs = this.commonObjs;\r\n      var objs = this.objs;\r\n      var fnId;\r\n      while (true) {\r\n        if (stepper !== undefined && i === stepper.nextBreakPoint) {\r\n          stepper.breakIt(i, continueCallback);\r\n          return i;\r\n        }\r\n        fnId = fnArray[i];\r\n        if (fnId !== _util.OPS.dependency) {\r\n          this[fnId].apply(this, argsArray[i]);\r\n        } else {\r\n          var deps = argsArray[i];\r\n          for (var n = 0, nn = deps.length; n < nn; n++) {\r\n            var depObjId = deps[n];\r\n            var common = depObjId[0] === 'g' && depObjId[1] === '_';\r\n            var objsPool = common ? commonObjs : objs;\r\n            if (!objsPool.isResolved(depObjId)) {\r\n              objsPool.get(depObjId, continueCallback);\r\n              return i;\r\n            }\r\n          }\r\n        }\r\n        i++;\r\n        if (i === argsArrayLen) {\r\n          return i;\r\n        }\r\n        if (chunkOperations && ++steps > EXECUTION_STEPS) {\r\n          if (Date.now() > endTime) {\r\n            continueCallback();\r\n            return i;\r\n          }\r\n          steps = 0;\r\n        }\r\n      }\r\n    },\r\n    endDrawing: function CanvasGraphics_endDrawing() {\r\n      if (this.current.activeSMask !== null) {\r\n        this.endSMaskGroup();\r\n      }\r\n      this.ctx.restore();\r\n      if (this.transparentCanvas) {\r\n        this.ctx = this.compositeCtx;\r\n        this.ctx.save();\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this.ctx.drawImage(this.transparentCanvas, 0, 0);\r\n        this.ctx.restore();\r\n        this.transparentCanvas = null;\r\n      }\r\n      this.cachedCanvases.clear();\r\n      this.webGLContext.clear();\r\n      if (this.imageLayer) {\r\n        this.imageLayer.endLayout();\r\n      }\r\n    },\r\n    setLineWidth: function CanvasGraphics_setLineWidth(width) {\r\n      this.current.lineWidth = width;\r\n      this.ctx.lineWidth = width;\r\n    },\r\n    setLineCap: function CanvasGraphics_setLineCap(style) {\r\n      this.ctx.lineCap = LINE_CAP_STYLES[style];\r\n    },\r\n    setLineJoin: function CanvasGraphics_setLineJoin(style) {\r\n      this.ctx.lineJoin = LINE_JOIN_STYLES[style];\r\n    },\r\n    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\r\n      this.ctx.miterLimit = limit;\r\n    },\r\n    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\r\n      var ctx = this.ctx;\r\n      if (ctx.setLineDash !== undefined) {\r\n        ctx.setLineDash(dashArray);\r\n        ctx.lineDashOffset = dashPhase;\r\n      }\r\n    },\r\n    setRenderingIntent: function CanvasGraphics_setRenderingIntent(intent) {},\r\n    setFlatness: function CanvasGraphics_setFlatness(flatness) {},\r\n    setGState: function CanvasGraphics_setGState(states) {\r\n      for (var i = 0, ii = states.length; i < ii; i++) {\r\n        var state = states[i];\r\n        var key = state[0];\r\n        var value = state[1];\r\n        switch (key) {\r\n          case 'LW':\r\n            this.setLineWidth(value);\r\n            break;\r\n          case 'LC':\r\n            this.setLineCap(value);\r\n            break;\r\n          case 'LJ':\r\n            this.setLineJoin(value);\r\n            break;\r\n          case 'ML':\r\n            this.setMiterLimit(value);\r\n            break;\r\n          case 'D':\r\n            this.setDash(value[0], value[1]);\r\n            break;\r\n          case 'RI':\r\n            this.setRenderingIntent(value);\r\n            break;\r\n          case 'FL':\r\n            this.setFlatness(value);\r\n            break;\r\n          case 'Font':\r\n            this.setFont(value[0], value[1]);\r\n            break;\r\n          case 'CA':\r\n            this.current.strokeAlpha = state[1];\r\n            break;\r\n          case 'ca':\r\n            this.current.fillAlpha = state[1];\r\n            this.ctx.globalAlpha = state[1];\r\n            break;\r\n          case 'BM':\r\n            this.ctx.globalCompositeOperation = value;\r\n            break;\r\n          case 'SMask':\r\n            if (this.current.activeSMask) {\r\n              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {\r\n                this.suspendSMaskGroup();\r\n              } else {\r\n                this.endSMaskGroup();\r\n              }\r\n            }\r\n            this.current.activeSMask = value ? this.tempSMask : null;\r\n            if (this.current.activeSMask) {\r\n              this.beginSMaskGroup();\r\n            }\r\n            this.tempSMask = null;\r\n            break;\r\n        }\r\n      }\r\n    },\r\n    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\r\n      var activeSMask = this.current.activeSMask;\r\n      var drawnWidth = activeSMask.canvas.width;\r\n      var drawnHeight = activeSMask.canvas.height;\r\n      var cacheId = 'smaskGroupAt' + this.groupLevel;\r\n      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\r\n      var currentCtx = this.ctx;\r\n      var currentTransform = currentCtx.mozCurrentTransform;\r\n      this.ctx.save();\r\n      var groupCtx = scratchCanvas.context;\r\n      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\r\n      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\r\n      groupCtx.transform.apply(groupCtx, currentTransform);\r\n      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;\r\n      copyCtxState(currentCtx, groupCtx);\r\n      this.ctx = groupCtx;\r\n      this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);\r\n      this.groupStack.push(currentCtx);\r\n      this.groupLevel++;\r\n    },\r\n    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {\r\n      var groupCtx = this.ctx;\r\n      this.groupLevel--;\r\n      this.ctx = this.groupStack.pop();\r\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\r\n      this.ctx.restore();\r\n      this.ctx.save();\r\n      copyCtxState(groupCtx, this.ctx);\r\n      this.current.resumeSMaskCtx = groupCtx;\r\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\r\n      this.ctx.transform.apply(this.ctx, deltaTransform);\r\n      groupCtx.save();\r\n      groupCtx.setTransform(1, 0, 0, 1, 0, 0);\r\n      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);\r\n      groupCtx.restore();\r\n    },\r\n    resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {\r\n      var groupCtx = this.current.resumeSMaskCtx;\r\n      var currentCtx = this.ctx;\r\n      this.ctx = groupCtx;\r\n      this.groupStack.push(currentCtx);\r\n      this.groupLevel++;\r\n    },\r\n    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\r\n      var groupCtx = this.ctx;\r\n      this.groupLevel--;\r\n      this.ctx = this.groupStack.pop();\r\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\r\n      this.ctx.restore();\r\n      copyCtxState(groupCtx, this.ctx);\r\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\r\n      this.ctx.transform.apply(this.ctx, deltaTransform);\r\n    },\r\n    save: function CanvasGraphics_save() {\r\n      this.ctx.save();\r\n      var old = this.current;\r\n      this.stateStack.push(old);\r\n      this.current = old.clone();\r\n      this.current.resumeSMaskCtx = null;\r\n    },\r\n    restore: function CanvasGraphics_restore() {\r\n      if (this.current.resumeSMaskCtx) {\r\n        this.resumeSMaskGroup();\r\n      }\r\n      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {\r\n        this.endSMaskGroup();\r\n      }\r\n      if (this.stateStack.length !== 0) {\r\n        this.current = this.stateStack.pop();\r\n        this.ctx.restore();\r\n        this.pendingClip = null;\r\n        this.cachedGetSinglePixelWidth = null;\r\n      }\r\n    },\r\n    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\r\n      this.ctx.transform(a, b, c, d, e, f);\r\n      this.cachedGetSinglePixelWidth = null;\r\n    },\r\n    constructPath: function CanvasGraphics_constructPath(ops, args) {\r\n      var ctx = this.ctx;\r\n      var current = this.current;\r\n      var x = current.x,\r\n          y = current.y;\r\n      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {\r\n        switch (ops[i] | 0) {\r\n          case _util.OPS.rectangle:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            var width = args[j++];\r\n            var height = args[j++];\r\n            if (width === 0) {\r\n              width = this.getSinglePixelWidth();\r\n            }\r\n            if (height === 0) {\r\n              height = this.getSinglePixelWidth();\r\n            }\r\n            var xw = x + width;\r\n            var yh = y + height;\r\n            this.ctx.moveTo(x, y);\r\n            this.ctx.lineTo(xw, y);\r\n            this.ctx.lineTo(xw, yh);\r\n            this.ctx.lineTo(x, yh);\r\n            this.ctx.lineTo(x, y);\r\n            this.ctx.closePath();\r\n            break;\r\n          case _util.OPS.moveTo:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            ctx.moveTo(x, y);\r\n            break;\r\n          case _util.OPS.lineTo:\r\n            x = args[j++];\r\n            y = args[j++];\r\n            ctx.lineTo(x, y);\r\n            break;\r\n          case _util.OPS.curveTo:\r\n            x = args[j + 4];\r\n            y = args[j + 5];\r\n            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\r\n            j += 6;\r\n            break;\r\n          case _util.OPS.curveTo2:\r\n            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\r\n            x = args[j + 2];\r\n            y = args[j + 3];\r\n            j += 4;\r\n            break;\r\n          case _util.OPS.curveTo3:\r\n            x = args[j + 2];\r\n            y = args[j + 3];\r\n            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\r\n            j += 4;\r\n            break;\r\n          case _util.OPS.closePath:\r\n            ctx.closePath();\r\n            break;\r\n        }\r\n      }\r\n      current.setCurrentPoint(x, y);\r\n    },\r\n    closePath: function CanvasGraphics_closePath() {\r\n      this.ctx.closePath();\r\n    },\r\n    stroke: function CanvasGraphics_stroke(consumePath) {\r\n      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;\r\n      var ctx = this.ctx;\r\n      var strokeColor = this.current.strokeColor;\r\n      ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);\r\n      ctx.globalAlpha = this.current.strokeAlpha;\r\n      if (strokeColor && strokeColor.hasOwnProperty('type') && strokeColor.type === 'Pattern') {\r\n        ctx.save();\r\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this);\r\n        ctx.stroke();\r\n        ctx.restore();\r\n      } else {\r\n        ctx.stroke();\r\n      }\r\n      if (consumePath) {\r\n        this.consumePath();\r\n      }\r\n      ctx.globalAlpha = this.current.fillAlpha;\r\n    },\r\n    closeStroke: function CanvasGraphics_closeStroke() {\r\n      this.closePath();\r\n      this.stroke();\r\n    },\r\n    fill: function CanvasGraphics_fill(consumePath) {\r\n      consumePath = typeof consumePath !== 'undefined' ? consumePath : true;\r\n      var ctx = this.ctx;\r\n      var fillColor = this.current.fillColor;\r\n      var isPatternFill = this.current.patternFill;\r\n      var needRestore = false;\r\n      if (isPatternFill) {\r\n        ctx.save();\r\n        if (this.baseTransform) {\r\n          ctx.setTransform.apply(ctx, this.baseTransform);\r\n        }\r\n        ctx.fillStyle = fillColor.getPattern(ctx, this);\r\n        needRestore = true;\r\n      }\r\n      if (this.pendingEOFill) {\r\n        ctx.fill('evenodd');\r\n        this.pendingEOFill = false;\r\n      } else {\r\n        ctx.fill();\r\n      }\r\n      if (needRestore) {\r\n        ctx.restore();\r\n      }\r\n      if (consumePath) {\r\n        this.consumePath();\r\n      }\r\n    },\r\n    eoFill: function CanvasGraphics_eoFill() {\r\n      this.pendingEOFill = true;\r\n      this.fill();\r\n    },\r\n    fillStroke: function CanvasGraphics_fillStroke() {\r\n      this.fill(false);\r\n      this.stroke(false);\r\n      this.consumePath();\r\n    },\r\n    eoFillStroke: function CanvasGraphics_eoFillStroke() {\r\n      this.pendingEOFill = true;\r\n      this.fillStroke();\r\n    },\r\n    closeFillStroke: function CanvasGraphics_closeFillStroke() {\r\n      this.closePath();\r\n      this.fillStroke();\r\n    },\r\n    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\r\n      this.pendingEOFill = true;\r\n      this.closePath();\r\n      this.fillStroke();\r\n    },\r\n    endPath: function CanvasGraphics_endPath() {\r\n      this.consumePath();\r\n    },\r\n    clip: function CanvasGraphics_clip() {\r\n      this.pendingClip = NORMAL_CLIP;\r\n    },\r\n    eoClip: function CanvasGraphics_eoClip() {\r\n      this.pendingClip = EO_CLIP;\r\n    },\r\n    beginText: function CanvasGraphics_beginText() {\r\n      this.current.textMatrix = _util.IDENTITY_MATRIX;\r\n      this.current.textMatrixScale = 1;\r\n      this.current.x = this.current.lineX = 0;\r\n      this.current.y = this.current.lineY = 0;\r\n    },\r\n    endText: function CanvasGraphics_endText() {\r\n      var paths = this.pendingTextPaths;\r\n      var ctx = this.ctx;\r\n      if (paths === undefined) {\r\n        ctx.beginPath();\r\n        return;\r\n      }\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      for (var i = 0; i < paths.length; i++) {\r\n        var path = paths[i];\r\n        ctx.setTransform.apply(ctx, path.transform);\r\n        ctx.translate(path.x, path.y);\r\n        path.addToPath(ctx, path.fontSize);\r\n      }\r\n      ctx.restore();\r\n      ctx.clip();\r\n      ctx.beginPath();\r\n      delete this.pendingTextPaths;\r\n    },\r\n    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\r\n      this.current.charSpacing = spacing;\r\n    },\r\n    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\r\n      this.current.wordSpacing = spacing;\r\n    },\r\n    setHScale: function CanvasGraphics_setHScale(scale) {\r\n      this.current.textHScale = scale / 100;\r\n    },\r\n    setLeading: function CanvasGraphics_setLeading(leading) {\r\n      this.current.leading = -leading;\r\n    },\r\n    setFont: function CanvasGraphics_setFont(fontRefName, size) {\r\n      var fontObj = this.commonObjs.get(fontRefName);\r\n      var current = this.current;\r\n      if (!fontObj) {\r\n        throw new Error('Can\\'t find font for ' + fontRefName);\r\n      }\r\n      current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;\r\n      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\r\n        (0, _util.warn)('Invalid font matrix for font ' + fontRefName);\r\n      }\r\n      if (size < 0) {\r\n        size = -size;\r\n        current.fontDirection = -1;\r\n      } else {\r\n        current.fontDirection = 1;\r\n      }\r\n      this.current.font = fontObj;\r\n      this.current.fontSize = size;\r\n      if (fontObj.isType3Font) {\r\n        return;\r\n      }\r\n      var name = fontObj.loadedName || 'sans-serif';\r\n      var bold = fontObj.black ? '900' : fontObj.bold ? 'bold' : 'normal';\r\n      var italic = fontObj.italic ? 'italic' : 'normal';\r\n      var typeface = '\"' + name + '\", ' + fontObj.fallbackName;\r\n      var browserFontSize = size < MIN_FONT_SIZE ? MIN_FONT_SIZE : size > MAX_FONT_SIZE ? MAX_FONT_SIZE : size;\r\n      this.current.fontSizeScale = size / browserFontSize;\r\n      var rule = italic + ' ' + bold + ' ' + browserFontSize + 'px ' + typeface;\r\n      this.ctx.font = rule;\r\n    },\r\n    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\r\n      this.current.textRenderingMode = mode;\r\n    },\r\n    setTextRise: function CanvasGraphics_setTextRise(rise) {\r\n      this.current.textRise = rise;\r\n    },\r\n    moveText: function CanvasGraphics_moveText(x, y) {\r\n      this.current.x = this.current.lineX += x;\r\n      this.current.y = this.current.lineY += y;\r\n    },\r\n    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\r\n      this.setLeading(-y);\r\n      this.moveText(x, y);\r\n    },\r\n    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\r\n      this.current.textMatrix = [a, b, c, d, e, f];\r\n      this.current.textMatrixScale = Math.sqrt(a * a + b * b);\r\n      this.current.x = this.current.lineX = 0;\r\n      this.current.y = this.current.lineY = 0;\r\n    },\r\n    nextLine: function CanvasGraphics_nextLine() {\r\n      this.moveText(0, this.current.leading);\r\n    },\r\n    paintChar: function paintChar(character, x, y, patternTransform) {\r\n      var ctx = this.ctx;\r\n      var current = this.current;\r\n      var font = current.font;\r\n      var textRenderingMode = current.textRenderingMode;\r\n      var fontSize = current.fontSize / current.fontSizeScale;\r\n      var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\r\n      var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\r\n      var patternFill = current.patternFill && font.data;\r\n      var addToPath;\r\n      if (font.disableFontFace || isAddToPathSet || patternFill) {\r\n        addToPath = font.getPathGenerator(this.commonObjs, character);\r\n      }\r\n      if (font.disableFontFace || patternFill) {\r\n        ctx.save();\r\n        ctx.translate(x, y);\r\n        ctx.beginPath();\r\n        addToPath(ctx, fontSize);\r\n        if (patternTransform) {\r\n          ctx.setTransform.apply(ctx, patternTransform);\r\n        }\r\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          ctx.fill();\r\n        }\r\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          ctx.stroke();\r\n        }\r\n        ctx.restore();\r\n      } else {\r\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          ctx.fillText(character, x, y);\r\n        }\r\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          ctx.strokeText(character, x, y);\r\n        }\r\n      }\r\n      if (isAddToPathSet) {\r\n        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);\r\n        paths.push({\r\n          transform: ctx.mozCurrentTransform,\r\n          x: x,\r\n          y: y,\r\n          fontSize: fontSize,\r\n          addToPath: addToPath\r\n        });\r\n      }\r\n    },\r\n\r\n    get isFontSubpixelAAEnabled() {\r\n      var ctx = this.canvasFactory.create(10, 10).context;\r\n      ctx.scale(1.5, 1);\r\n      ctx.fillText('I', 0, 10);\r\n      var data = ctx.getImageData(0, 0, 10, 10).data;\r\n      var enabled = false;\r\n      for (var i = 3; i < data.length; i += 4) {\r\n        if (data[i] > 0 && data[i] < 255) {\r\n          enabled = true;\r\n          break;\r\n        }\r\n      }\r\n      return (0, _util.shadow)(this, 'isFontSubpixelAAEnabled', enabled);\r\n    },\r\n    showText: function CanvasGraphics_showText(glyphs) {\r\n      var current = this.current;\r\n      var font = current.font;\r\n      if (font.isType3Font) {\r\n        return this.showType3Text(glyphs);\r\n      }\r\n      var fontSize = current.fontSize;\r\n      if (fontSize === 0) {\r\n        return;\r\n      }\r\n      var ctx = this.ctx;\r\n      var fontSizeScale = current.fontSizeScale;\r\n      var charSpacing = current.charSpacing;\r\n      var wordSpacing = current.wordSpacing;\r\n      var fontDirection = current.fontDirection;\r\n      var textHScale = current.textHScale * fontDirection;\r\n      var glyphsLength = glyphs.length;\r\n      var vertical = font.vertical;\r\n      var spacingDir = vertical ? 1 : -1;\r\n      var defaultVMetrics = font.defaultVMetrics;\r\n      var widthAdvanceScale = fontSize * current.fontMatrix[0];\r\n      var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\r\n      ctx.save();\r\n      var patternTransform = void 0;\r\n      if (current.patternFill) {\r\n        ctx.save();\r\n        var pattern = current.fillColor.getPattern(ctx, this);\r\n        patternTransform = ctx.mozCurrentTransform;\r\n        ctx.restore();\r\n        ctx.fillStyle = pattern;\r\n      }\r\n      ctx.transform.apply(ctx, current.textMatrix);\r\n      ctx.translate(current.x, current.y + current.textRise);\r\n      if (fontDirection > 0) {\r\n        ctx.scale(textHScale, -1);\r\n      } else {\r\n        ctx.scale(textHScale, 1);\r\n      }\r\n      var lineWidth = current.lineWidth;\r\n      var scale = current.textMatrixScale;\r\n      if (scale === 0 || lineWidth === 0) {\r\n        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\r\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\r\n          this.cachedGetSinglePixelWidth = null;\r\n          lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;\r\n        }\r\n      } else {\r\n        lineWidth /= scale;\r\n      }\r\n      if (fontSizeScale !== 1.0) {\r\n        ctx.scale(fontSizeScale, fontSizeScale);\r\n        lineWidth /= fontSizeScale;\r\n      }\r\n      ctx.lineWidth = lineWidth;\r\n      var x = 0,\r\n          i;\r\n      for (i = 0; i < glyphsLength; ++i) {\r\n        var glyph = glyphs[i];\r\n        if ((0, _util.isNum)(glyph)) {\r\n          x += spacingDir * glyph * fontSize / 1000;\r\n          continue;\r\n        }\r\n        var restoreNeeded = false;\r\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\r\n        var character = glyph.fontChar;\r\n        var accent = glyph.accent;\r\n        var scaledX, scaledY, scaledAccentX, scaledAccentY;\r\n        var width = glyph.width;\r\n        if (vertical) {\r\n          var vmetric, vx, vy;\r\n          vmetric = glyph.vmetric || defaultVMetrics;\r\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\r\n          vx = -vx * widthAdvanceScale;\r\n          vy = vmetric[2] * widthAdvanceScale;\r\n          width = vmetric ? -vmetric[0] : width;\r\n          scaledX = vx / fontSizeScale;\r\n          scaledY = (x + vy) / fontSizeScale;\r\n        } else {\r\n          scaledX = x / fontSizeScale;\r\n          scaledY = 0;\r\n        }\r\n        if (font.remeasure && width > 0) {\r\n          var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\r\n          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\r\n            var characterScaleX = width / measuredWidth;\r\n            restoreNeeded = true;\r\n            ctx.save();\r\n            ctx.scale(characterScaleX, 1);\r\n            scaledX /= characterScaleX;\r\n          } else if (width !== measuredWidth) {\r\n            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\r\n          }\r\n        }\r\n        if (glyph.isInFont || font.missingFile) {\r\n          if (simpleFillText && !accent) {\r\n            ctx.fillText(character, scaledX, scaledY);\r\n          } else {\r\n            this.paintChar(character, scaledX, scaledY, patternTransform);\r\n            if (accent) {\r\n              scaledAccentX = scaledX + accent.offset.x / fontSizeScale;\r\n              scaledAccentY = scaledY - accent.offset.y / fontSizeScale;\r\n              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\r\n            }\r\n          }\r\n        }\r\n        var charWidth = width * widthAdvanceScale + spacing * fontDirection;\r\n        x += charWidth;\r\n        if (restoreNeeded) {\r\n          ctx.restore();\r\n        }\r\n      }\r\n      if (vertical) {\r\n        current.y -= x * textHScale;\r\n      } else {\r\n        current.x += x * textHScale;\r\n      }\r\n      ctx.restore();\r\n    },\r\n    showType3Text: function CanvasGraphics_showType3Text(glyphs) {\r\n      var ctx = this.ctx;\r\n      var current = this.current;\r\n      var font = current.font;\r\n      var fontSize = current.fontSize;\r\n      var fontDirection = current.fontDirection;\r\n      var spacingDir = font.vertical ? 1 : -1;\r\n      var charSpacing = current.charSpacing;\r\n      var wordSpacing = current.wordSpacing;\r\n      var textHScale = current.textHScale * fontDirection;\r\n      var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\r\n      var glyphsLength = glyphs.length;\r\n      var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\r\n      var i, glyph, width, spacingLength;\r\n      if (isTextInvisible || fontSize === 0) {\r\n        return;\r\n      }\r\n      this.cachedGetSinglePixelWidth = null;\r\n      ctx.save();\r\n      ctx.transform.apply(ctx, current.textMatrix);\r\n      ctx.translate(current.x, current.y);\r\n      ctx.scale(textHScale, fontDirection);\r\n      for (i = 0; i < glyphsLength; ++i) {\r\n        glyph = glyphs[i];\r\n        if ((0, _util.isNum)(glyph)) {\r\n          spacingLength = spacingDir * glyph * fontSize / 1000;\r\n          this.ctx.translate(spacingLength, 0);\r\n          current.x += spacingLength * textHScale;\r\n          continue;\r\n        }\r\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\r\n        var operatorList = font.charProcOperatorList[glyph.operatorListId];\r\n        if (!operatorList) {\r\n          (0, _util.warn)('Type3 character \"' + glyph.operatorListId + '\" is not available.');\r\n          continue;\r\n        }\r\n        this.processingType3 = glyph;\r\n        this.save();\r\n        ctx.scale(fontSize, fontSize);\r\n        ctx.transform.apply(ctx, fontMatrix);\r\n        this.executeOperatorList(operatorList);\r\n        this.restore();\r\n        var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\r\n        width = transformed[0] * fontSize + spacing;\r\n        ctx.translate(width, 0);\r\n        current.x += width * textHScale;\r\n      }\r\n      ctx.restore();\r\n      this.processingType3 = null;\r\n    },\r\n    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},\r\n    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\r\n      this.ctx.rect(llx, lly, urx - llx, ury - lly);\r\n      this.clip();\r\n      this.endPath();\r\n    },\r\n    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\r\n      var _this = this;\r\n\r\n      var pattern;\r\n      if (IR[0] === 'TilingPattern') {\r\n        var color = IR[1];\r\n        var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\r\n        var canvasGraphicsFactory = {\r\n          createCanvasGraphics: function createCanvasGraphics(ctx) {\r\n            return new CanvasGraphics(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext);\r\n          }\r\n        };\r\n        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\r\n      } else {\r\n        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);\r\n      }\r\n      return pattern;\r\n    },\r\n    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {\r\n      this.current.strokeColor = this.getColorN_Pattern(arguments);\r\n    },\r\n    setFillColorN: function CanvasGraphics_setFillColorN() {\r\n      this.current.fillColor = this.getColorN_Pattern(arguments);\r\n      this.current.patternFill = true;\r\n    },\r\n    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\r\n      var color = _util.Util.makeCssRgb(r, g, b);\r\n      this.ctx.strokeStyle = color;\r\n      this.current.strokeColor = color;\r\n    },\r\n    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\r\n      var color = _util.Util.makeCssRgb(r, g, b);\r\n      this.ctx.fillStyle = color;\r\n      this.current.fillColor = color;\r\n      this.current.patternFill = false;\r\n    },\r\n    shadingFill: function CanvasGraphics_shadingFill(patternIR) {\r\n      var ctx = this.ctx;\r\n      this.save();\r\n      var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);\r\n      ctx.fillStyle = pattern.getPattern(ctx, this, true);\r\n      var inv = ctx.mozCurrentTransformInverse;\r\n      if (inv) {\r\n        var canvas = ctx.canvas;\r\n        var width = canvas.width;\r\n        var height = canvas.height;\r\n        var bl = _util.Util.applyTransform([0, 0], inv);\r\n        var br = _util.Util.applyTransform([0, height], inv);\r\n        var ul = _util.Util.applyTransform([width, 0], inv);\r\n        var ur = _util.Util.applyTransform([width, height], inv);\r\n        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\r\n        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\r\n        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\r\n        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\r\n        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\r\n      } else {\r\n        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\r\n      }\r\n      this.restore();\r\n    },\r\n    beginInlineImage: function CanvasGraphics_beginInlineImage() {\r\n      (0, _util.unreachable)('Should not call beginInlineImage');\r\n    },\r\n    beginImageData: function CanvasGraphics_beginImageData() {\r\n      (0, _util.unreachable)('Should not call beginImageData');\r\n    },\r\n    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {\r\n      this.save();\r\n      this.baseTransformStack.push(this.baseTransform);\r\n      if (Array.isArray(matrix) && matrix.length === 6) {\r\n        this.transform.apply(this, matrix);\r\n      }\r\n      this.baseTransform = this.ctx.mozCurrentTransform;\r\n      if (Array.isArray(bbox) && bbox.length === 4) {\r\n        var width = bbox[2] - bbox[0];\r\n        var height = bbox[3] - bbox[1];\r\n        this.ctx.rect(bbox[0], bbox[1], width, height);\r\n        this.clip();\r\n        this.endPath();\r\n      }\r\n    },\r\n    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\r\n      this.restore();\r\n      this.baseTransform = this.baseTransformStack.pop();\r\n    },\r\n    beginGroup: function CanvasGraphics_beginGroup(group) {\r\n      this.save();\r\n      var currentCtx = this.ctx;\r\n      if (!group.isolated) {\r\n        (0, _util.info)('TODO: Support non-isolated groups.');\r\n      }\r\n      if (group.knockout) {\r\n        (0, _util.warn)('Knockout groups not supported.');\r\n      }\r\n      var currentTransform = currentCtx.mozCurrentTransform;\r\n      if (group.matrix) {\r\n        currentCtx.transform.apply(currentCtx, group.matrix);\r\n      }\r\n      if (!group.bbox) {\r\n        throw new Error('Bounding box is required.');\r\n      }\r\n      var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\r\n      var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\r\n      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\r\n      var offsetX = Math.floor(bounds[0]);\r\n      var offsetY = Math.floor(bounds[1]);\r\n      var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\r\n      var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\r\n      var scaleX = 1,\r\n          scaleY = 1;\r\n      if (drawnWidth > MAX_GROUP_SIZE) {\r\n        scaleX = drawnWidth / MAX_GROUP_SIZE;\r\n        drawnWidth = MAX_GROUP_SIZE;\r\n      }\r\n      if (drawnHeight > MAX_GROUP_SIZE) {\r\n        scaleY = drawnHeight / MAX_GROUP_SIZE;\r\n        drawnHeight = MAX_GROUP_SIZE;\r\n      }\r\n      var cacheId = 'groupAt' + this.groupLevel;\r\n      if (group.smask) {\r\n        cacheId += '_smask_' + this.smaskCounter++ % 2;\r\n      }\r\n      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\r\n      var groupCtx = scratchCanvas.context;\r\n      groupCtx.scale(1 / scaleX, 1 / scaleY);\r\n      groupCtx.translate(-offsetX, -offsetY);\r\n      groupCtx.transform.apply(groupCtx, currentTransform);\r\n      if (group.smask) {\r\n        this.smaskStack.push({\r\n          canvas: scratchCanvas.canvas,\r\n          context: groupCtx,\r\n          offsetX: offsetX,\r\n          offsetY: offsetY,\r\n          scaleX: scaleX,\r\n          scaleY: scaleY,\r\n          subtype: group.smask.subtype,\r\n          backdrop: group.smask.backdrop,\r\n          transferMap: group.smask.transferMap || null,\r\n          startTransformInverse: null\r\n        });\r\n      } else {\r\n        currentCtx.setTransform(1, 0, 0, 1, 0, 0);\r\n        currentCtx.translate(offsetX, offsetY);\r\n        currentCtx.scale(scaleX, scaleY);\r\n      }\r\n      copyCtxState(currentCtx, groupCtx);\r\n      this.ctx = groupCtx;\r\n      this.setGState([['BM', 'source-over'], ['ca', 1], ['CA', 1]]);\r\n      this.groupStack.push(currentCtx);\r\n      this.groupLevel++;\r\n      this.current.activeSMask = null;\r\n    },\r\n    endGroup: function CanvasGraphics_endGroup(group) {\r\n      this.groupLevel--;\r\n      var groupCtx = this.ctx;\r\n      this.ctx = this.groupStack.pop();\r\n      if (this.ctx.imageSmoothingEnabled !== undefined) {\r\n        this.ctx.imageSmoothingEnabled = false;\r\n      } else {\r\n        this.ctx.mozImageSmoothingEnabled = false;\r\n      }\r\n      if (group.smask) {\r\n        this.tempSMask = this.smaskStack.pop();\r\n      } else {\r\n        this.ctx.drawImage(groupCtx.canvas, 0, 0);\r\n      }\r\n      this.restore();\r\n    },\r\n    beginAnnotations: function CanvasGraphics_beginAnnotations() {\r\n      this.save();\r\n      if (this.baseTransform) {\r\n        this.ctx.setTransform.apply(this.ctx, this.baseTransform);\r\n      }\r\n    },\r\n    endAnnotations: function CanvasGraphics_endAnnotations() {\r\n      this.restore();\r\n    },\r\n    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {\r\n      this.save();\r\n      resetCtxToDefault(this.ctx);\r\n      this.current = new CanvasExtraState();\r\n      if (Array.isArray(rect) && rect.length === 4) {\r\n        var width = rect[2] - rect[0];\r\n        var height = rect[3] - rect[1];\r\n        this.ctx.rect(rect[0], rect[1], width, height);\r\n        this.clip();\r\n        this.endPath();\r\n      }\r\n      this.transform.apply(this, transform);\r\n      this.transform.apply(this, matrix);\r\n    },\r\n    endAnnotation: function CanvasGraphics_endAnnotation() {\r\n      this.restore();\r\n    },\r\n    paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {\r\n      var domImage = this.objs.get(objId);\r\n      if (!domImage) {\r\n        (0, _util.warn)('Dependent image isn\\'t ready yet');\r\n        return;\r\n      }\r\n      this.save();\r\n      var ctx = this.ctx;\r\n      ctx.scale(1 / w, -1 / h);\r\n      ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);\r\n      if (this.imageLayer) {\r\n        var currentTransform = ctx.mozCurrentTransformInverse;\r\n        var position = this.getCanvasPosition(0, 0);\r\n        this.imageLayer.appendImage({\r\n          objId: objId,\r\n          left: position[0],\r\n          top: position[1],\r\n          width: w / currentTransform[0],\r\n          height: h / currentTransform[3]\r\n        });\r\n      }\r\n      this.restore();\r\n    },\r\n    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\r\n      var ctx = this.ctx;\r\n      var width = img.width,\r\n          height = img.height;\r\n      var fillColor = this.current.fillColor;\r\n      var isPatternFill = this.current.patternFill;\r\n      var glyph = this.processingType3;\r\n      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\r\n        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\r\n          glyph.compiled = compileType3Glyph({\r\n            data: img.data,\r\n            width: width,\r\n            height: height\r\n          });\r\n        } else {\r\n          glyph.compiled = null;\r\n        }\r\n      }\r\n      if (glyph && glyph.compiled) {\r\n        glyph.compiled(ctx);\r\n        return;\r\n      }\r\n      var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);\r\n      var maskCtx = maskCanvas.context;\r\n      maskCtx.save();\r\n      putBinaryImageMask(maskCtx, img);\r\n      maskCtx.globalCompositeOperation = 'source-in';\r\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\r\n      maskCtx.fillRect(0, 0, width, height);\r\n      maskCtx.restore();\r\n      this.paintInlineImageXObject(maskCanvas.canvas);\r\n    },\r\n    paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) {\r\n      var width = imgData.width;\r\n      var height = imgData.height;\r\n      var fillColor = this.current.fillColor;\r\n      var isPatternFill = this.current.patternFill;\r\n      var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);\r\n      var maskCtx = maskCanvas.context;\r\n      maskCtx.save();\r\n      putBinaryImageMask(maskCtx, imgData);\r\n      maskCtx.globalCompositeOperation = 'source-in';\r\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\r\n      maskCtx.fillRect(0, 0, width, height);\r\n      maskCtx.restore();\r\n      var ctx = this.ctx;\r\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\r\n        ctx.save();\r\n        ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]);\r\n        ctx.scale(1, -1);\r\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\r\n        ctx.restore();\r\n      }\r\n    },\r\n    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {\r\n      var ctx = this.ctx;\r\n      var fillColor = this.current.fillColor;\r\n      var isPatternFill = this.current.patternFill;\r\n      for (var i = 0, ii = images.length; i < ii; i++) {\r\n        var image = images[i];\r\n        var width = image.width,\r\n            height = image.height;\r\n        var maskCanvas = this.cachedCanvases.getCanvas('maskCanvas', width, height);\r\n        var maskCtx = maskCanvas.context;\r\n        maskCtx.save();\r\n        putBinaryImageMask(maskCtx, image);\r\n        maskCtx.globalCompositeOperation = 'source-in';\r\n        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\r\n        maskCtx.fillRect(0, 0, width, height);\r\n        maskCtx.restore();\r\n        ctx.save();\r\n        ctx.transform.apply(ctx, image.transform);\r\n        ctx.scale(1, -1);\r\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\r\n        ctx.restore();\r\n      }\r\n    },\r\n    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\r\n      var imgData = this.objs.get(objId);\r\n      if (!imgData) {\r\n        (0, _util.warn)('Dependent image isn\\'t ready yet');\r\n        return;\r\n      }\r\n      this.paintInlineImageXObject(imgData);\r\n    },\r\n    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\r\n      var imgData = this.objs.get(objId);\r\n      if (!imgData) {\r\n        (0, _util.warn)('Dependent image isn\\'t ready yet');\r\n        return;\r\n      }\r\n      var width = imgData.width;\r\n      var height = imgData.height;\r\n      var map = [];\r\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\r\n        map.push({\r\n          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\r\n          x: 0,\r\n          y: 0,\r\n          w: width,\r\n          h: height\r\n        });\r\n      }\r\n      this.paintInlineImageXObjectGroup(imgData, map);\r\n    },\r\n    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {\r\n      var width = imgData.width;\r\n      var height = imgData.height;\r\n      var ctx = this.ctx;\r\n      this.save();\r\n      ctx.scale(1 / width, -1 / height);\r\n      var currentTransform = ctx.mozCurrentTransformInverse;\r\n      var a = currentTransform[0],\r\n          b = currentTransform[1];\r\n      var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);\r\n      var c = currentTransform[2],\r\n          d = currentTransform[3];\r\n      var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);\r\n      var imgToPaint, tmpCanvas;\r\n      if (typeof HTMLElement === 'function' && imgData instanceof HTMLElement || !imgData.data) {\r\n        imgToPaint = imgData;\r\n      } else {\r\n        tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', width, height);\r\n        var tmpCtx = tmpCanvas.context;\r\n        putBinaryImageData(tmpCtx, imgData);\r\n        imgToPaint = tmpCanvas.canvas;\r\n      }\r\n      var paintWidth = width,\r\n          paintHeight = height;\r\n      var tmpCanvasId = 'prescale1';\r\n      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\r\n        var newWidth = paintWidth,\r\n            newHeight = paintHeight;\r\n        if (widthScale > 2 && paintWidth > 1) {\r\n          newWidth = Math.ceil(paintWidth / 2);\r\n          widthScale /= paintWidth / newWidth;\r\n        }\r\n        if (heightScale > 2 && paintHeight > 1) {\r\n          newHeight = Math.ceil(paintHeight / 2);\r\n          heightScale /= paintHeight / newHeight;\r\n        }\r\n        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\r\n        tmpCtx = tmpCanvas.context;\r\n        tmpCtx.clearRect(0, 0, newWidth, newHeight);\r\n        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\r\n        imgToPaint = tmpCanvas.canvas;\r\n        paintWidth = newWidth;\r\n        paintHeight = newHeight;\r\n        tmpCanvasId = tmpCanvasId === 'prescale1' ? 'prescale2' : 'prescale1';\r\n      }\r\n      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);\r\n      if (this.imageLayer) {\r\n        var position = this.getCanvasPosition(0, -height);\r\n        this.imageLayer.appendImage({\r\n          imgData: imgData,\r\n          left: position[0],\r\n          top: position[1],\r\n          width: width / currentTransform[0],\r\n          height: height / currentTransform[3]\r\n        });\r\n      }\r\n      this.restore();\r\n    },\r\n    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\r\n      var ctx = this.ctx;\r\n      var w = imgData.width;\r\n      var h = imgData.height;\r\n      var tmpCanvas = this.cachedCanvases.getCanvas('inlineImage', w, h);\r\n      var tmpCtx = tmpCanvas.context;\r\n      putBinaryImageData(tmpCtx, imgData);\r\n      for (var i = 0, ii = map.length; i < ii; i++) {\r\n        var entry = map[i];\r\n        ctx.save();\r\n        ctx.transform.apply(ctx, entry.transform);\r\n        ctx.scale(1, -1);\r\n        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\r\n        if (this.imageLayer) {\r\n          var position = this.getCanvasPosition(entry.x, entry.y);\r\n          this.imageLayer.appendImage({\r\n            imgData: imgData,\r\n            left: position[0],\r\n            top: position[1],\r\n            width: w,\r\n            height: h\r\n          });\r\n        }\r\n        ctx.restore();\r\n      }\r\n    },\r\n    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {\r\n      this.ctx.fillRect(0, 0, 1, 1);\r\n    },\r\n    paintXObject: function CanvasGraphics_paintXObject() {\r\n      (0, _util.warn)('Unsupported \\'paintXObject\\' command.');\r\n    },\r\n    markPoint: function CanvasGraphics_markPoint(tag) {},\r\n    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},\r\n    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {},\r\n    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {},\r\n    endMarkedContent: function CanvasGraphics_endMarkedContent() {},\r\n    beginCompat: function CanvasGraphics_beginCompat() {},\r\n    endCompat: function CanvasGraphics_endCompat() {},\r\n    consumePath: function CanvasGraphics_consumePath() {\r\n      var ctx = this.ctx;\r\n      if (this.pendingClip) {\r\n        if (this.pendingClip === EO_CLIP) {\r\n          ctx.clip('evenodd');\r\n        } else {\r\n          ctx.clip();\r\n        }\r\n        this.pendingClip = null;\r\n      }\r\n      ctx.beginPath();\r\n    },\r\n    getSinglePixelWidth: function CanvasGraphics_getSinglePixelWidth(scale) {\r\n      if (this.cachedGetSinglePixelWidth === null) {\r\n        this.ctx.save();\r\n        var inverse = this.ctx.mozCurrentTransformInverse;\r\n        this.ctx.restore();\r\n        this.cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));\r\n      }\r\n      return this.cachedGetSinglePixelWidth;\r\n    },\r\n    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\r\n      var transform = this.ctx.mozCurrentTransform;\r\n      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\r\n    }\r\n  };\r\n  for (var op in _util.OPS) {\r\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\r\n  }\r\n  return CanvasGraphics;\r\n}();\r\nexports.CanvasGraphics = CanvasGraphics;\r\n\r\n/***/ }),\r\n/* 120 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.TilingPattern = exports.getShadingPatternFromIR = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar ShadingIRs = {};\r\nShadingIRs.RadialAxial = {\r\n  fromIR: function RadialAxial_fromIR(raw) {\r\n    var type = raw[1];\r\n    var colorStops = raw[2];\r\n    var p0 = raw[3];\r\n    var p1 = raw[4];\r\n    var r0 = raw[5];\r\n    var r1 = raw[6];\r\n    return {\r\n      type: 'Pattern',\r\n      getPattern: function RadialAxial_getPattern(ctx) {\r\n        var grad;\r\n        if (type === 'axial') {\r\n          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\r\n        } else if (type === 'radial') {\r\n          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\r\n        }\r\n        for (var i = 0, ii = colorStops.length; i < ii; ++i) {\r\n          var c = colorStops[i];\r\n          grad.addColorStop(c[0], c[1]);\r\n        }\r\n        return grad;\r\n      }\r\n    };\r\n  }\r\n};\r\nvar createMeshCanvas = function createMeshCanvasClosure() {\r\n  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\r\n    var coords = context.coords,\r\n        colors = context.colors;\r\n    var bytes = data.data,\r\n        rowSize = data.width * 4;\r\n    var tmp;\r\n    if (coords[p1 + 1] > coords[p2 + 1]) {\r\n      tmp = p1;\r\n      p1 = p2;\r\n      p2 = tmp;\r\n      tmp = c1;\r\n      c1 = c2;\r\n      c2 = tmp;\r\n    }\r\n    if (coords[p2 + 1] > coords[p3 + 1]) {\r\n      tmp = p2;\r\n      p2 = p3;\r\n      p3 = tmp;\r\n      tmp = c2;\r\n      c2 = c3;\r\n      c3 = tmp;\r\n    }\r\n    if (coords[p1 + 1] > coords[p2 + 1]) {\r\n      tmp = p1;\r\n      p1 = p2;\r\n      p2 = tmp;\r\n      tmp = c1;\r\n      c1 = c2;\r\n      c2 = tmp;\r\n    }\r\n    var x1 = (coords[p1] + context.offsetX) * context.scaleX;\r\n    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\r\n    var x2 = (coords[p2] + context.offsetX) * context.scaleX;\r\n    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\r\n    var x3 = (coords[p3] + context.offsetX) * context.scaleX;\r\n    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\r\n    if (y1 >= y3) {\r\n      return;\r\n    }\r\n    var c1r = colors[c1],\r\n        c1g = colors[c1 + 1],\r\n        c1b = colors[c1 + 2];\r\n    var c2r = colors[c2],\r\n        c2g = colors[c2 + 1],\r\n        c2b = colors[c2 + 2];\r\n    var c3r = colors[c3],\r\n        c3g = colors[c3 + 1],\r\n        c3b = colors[c3 + 2];\r\n    var minY = Math.round(y1),\r\n        maxY = Math.round(y3);\r\n    var xa, car, cag, cab;\r\n    var xb, cbr, cbg, cbb;\r\n    var k;\r\n    for (var y = minY; y <= maxY; y++) {\r\n      if (y < y2) {\r\n        k = y < y1 ? 0 : y1 === y2 ? 1 : (y1 - y) / (y1 - y2);\r\n        xa = x1 - (x1 - x2) * k;\r\n        car = c1r - (c1r - c2r) * k;\r\n        cag = c1g - (c1g - c2g) * k;\r\n        cab = c1b - (c1b - c2b) * k;\r\n      } else {\r\n        k = y > y3 ? 1 : y2 === y3 ? 0 : (y2 - y) / (y2 - y3);\r\n        xa = x2 - (x2 - x3) * k;\r\n        car = c2r - (c2r - c3r) * k;\r\n        cag = c2g - (c2g - c3g) * k;\r\n        cab = c2b - (c2b - c3b) * k;\r\n      }\r\n      k = y < y1 ? 0 : y > y3 ? 1 : (y1 - y) / (y1 - y3);\r\n      xb = x1 - (x1 - x3) * k;\r\n      cbr = c1r - (c1r - c3r) * k;\r\n      cbg = c1g - (c1g - c3g) * k;\r\n      cbb = c1b - (c1b - c3b) * k;\r\n      var x1_ = Math.round(Math.min(xa, xb));\r\n      var x2_ = Math.round(Math.max(xa, xb));\r\n      var j = rowSize * y + x1_ * 4;\r\n      for (var x = x1_; x <= x2_; x++) {\r\n        k = (xa - x) / (xa - xb);\r\n        k = k < 0 ? 0 : k > 1 ? 1 : k;\r\n        bytes[j++] = car - (car - cbr) * k | 0;\r\n        bytes[j++] = cag - (cag - cbg) * k | 0;\r\n        bytes[j++] = cab - (cab - cbb) * k | 0;\r\n        bytes[j++] = 255;\r\n      }\r\n    }\r\n  }\r\n  function drawFigure(data, figure, context) {\r\n    var ps = figure.coords;\r\n    var cs = figure.colors;\r\n    var i, ii;\r\n    switch (figure.type) {\r\n      case 'lattice':\r\n        var verticesPerRow = figure.verticesPerRow;\r\n        var rows = Math.floor(ps.length / verticesPerRow) - 1;\r\n        var cols = verticesPerRow - 1;\r\n        for (i = 0; i < rows; i++) {\r\n          var q = i * verticesPerRow;\r\n          for (var j = 0; j < cols; j++, q++) {\r\n            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\r\n            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\r\n          }\r\n        }\r\n        break;\r\n      case 'triangles':\r\n        for (i = 0, ii = ps.length; i < ii; i += 3) {\r\n          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('illegal figure');\r\n    }\r\n  }\r\n  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {\r\n    var EXPECTED_SCALE = 1.1;\r\n    var MAX_PATTERN_SIZE = 3000;\r\n    var BORDER_SIZE = 2;\r\n    var offsetX = Math.floor(bounds[0]);\r\n    var offsetY = Math.floor(bounds[1]);\r\n    var boundsWidth = Math.ceil(bounds[2]) - offsetX;\r\n    var boundsHeight = Math.ceil(bounds[3]) - offsetY;\r\n    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\r\n    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\r\n    var scaleX = boundsWidth / width;\r\n    var scaleY = boundsHeight / height;\r\n    var context = {\r\n      coords: coords,\r\n      colors: colors,\r\n      offsetX: -offsetX,\r\n      offsetY: -offsetY,\r\n      scaleX: 1 / scaleX,\r\n      scaleY: 1 / scaleY\r\n    };\r\n    var paddedWidth = width + BORDER_SIZE * 2;\r\n    var paddedHeight = height + BORDER_SIZE * 2;\r\n    var canvas, tmpCanvas, i, ii;\r\n    if (webGLContext.isEnabled) {\r\n      canvas = webGLContext.drawFigures({\r\n        width: width,\r\n        height: height,\r\n        backgroundColor: backgroundColor,\r\n        figures: figures,\r\n        context: context\r\n      });\r\n      tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);\r\n      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);\r\n      canvas = tmpCanvas.canvas;\r\n    } else {\r\n      tmpCanvas = cachedCanvases.getCanvas('mesh', paddedWidth, paddedHeight, false);\r\n      var tmpCtx = tmpCanvas.context;\r\n      var data = tmpCtx.createImageData(width, height);\r\n      if (backgroundColor) {\r\n        var bytes = data.data;\r\n        for (i = 0, ii = bytes.length; i < ii; i += 4) {\r\n          bytes[i] = backgroundColor[0];\r\n          bytes[i + 1] = backgroundColor[1];\r\n          bytes[i + 2] = backgroundColor[2];\r\n          bytes[i + 3] = 255;\r\n        }\r\n      }\r\n      for (i = 0; i < figures.length; i++) {\r\n        drawFigure(data, figures[i], context);\r\n      }\r\n      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\r\n      canvas = tmpCanvas.canvas;\r\n    }\r\n    return {\r\n      canvas: canvas,\r\n      offsetX: offsetX - BORDER_SIZE * scaleX,\r\n      offsetY: offsetY - BORDER_SIZE * scaleY,\r\n      scaleX: scaleX,\r\n      scaleY: scaleY\r\n    };\r\n  }\r\n  return createMeshCanvas;\r\n}();\r\nShadingIRs.Mesh = {\r\n  fromIR: function Mesh_fromIR(raw) {\r\n    var coords = raw[2];\r\n    var colors = raw[3];\r\n    var figures = raw[4];\r\n    var bounds = raw[5];\r\n    var matrix = raw[6];\r\n    var background = raw[8];\r\n    return {\r\n      type: 'Pattern',\r\n      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\r\n        var scale;\r\n        if (shadingFill) {\r\n          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\r\n        } else {\r\n          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\r\n          if (matrix) {\r\n            var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);\r\n            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\r\n          }\r\n        }\r\n        var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);\r\n        if (!shadingFill) {\r\n          ctx.setTransform.apply(ctx, owner.baseTransform);\r\n          if (matrix) {\r\n            ctx.transform.apply(ctx, matrix);\r\n          }\r\n        }\r\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\r\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\r\n        return ctx.createPattern(temporaryPatternCanvas.canvas, 'no-repeat');\r\n      }\r\n    };\r\n  }\r\n};\r\nShadingIRs.Dummy = {\r\n  fromIR: function Dummy_fromIR() {\r\n    return {\r\n      type: 'Pattern',\r\n      getPattern: function Dummy_fromIR_getPattern() {\r\n        return 'hotpink';\r\n      }\r\n    };\r\n  }\r\n};\r\nfunction getShadingPatternFromIR(raw) {\r\n  var shadingIR = ShadingIRs[raw[0]];\r\n  if (!shadingIR) {\r\n    throw new Error('Unknown IR type: ' + raw[0]);\r\n  }\r\n  return shadingIR.fromIR(raw);\r\n}\r\nvar TilingPattern = function TilingPatternClosure() {\r\n  var PaintType = {\r\n    COLORED: 1,\r\n    UNCOLORED: 2\r\n  };\r\n  var MAX_PATTERN_SIZE = 3000;\r\n  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\r\n    this.operatorList = IR[2];\r\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\r\n    this.bbox = IR[4];\r\n    this.xstep = IR[5];\r\n    this.ystep = IR[6];\r\n    this.paintType = IR[7];\r\n    this.tilingType = IR[8];\r\n    this.color = color;\r\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\r\n    this.baseTransform = baseTransform;\r\n    this.type = 'Pattern';\r\n    this.ctx = ctx;\r\n  }\r\n  TilingPattern.prototype = {\r\n    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\r\n      var operatorList = this.operatorList;\r\n      var bbox = this.bbox;\r\n      var xstep = this.xstep;\r\n      var ystep = this.ystep;\r\n      var paintType = this.paintType;\r\n      var tilingType = this.tilingType;\r\n      var color = this.color;\r\n      var canvasGraphicsFactory = this.canvasGraphicsFactory;\r\n      (0, _util.info)('TilingType: ' + tilingType);\r\n      var x0 = bbox[0],\r\n          y0 = bbox[1],\r\n          x1 = bbox[2],\r\n          y1 = bbox[3];\r\n      var topLeft = [x0, y0];\r\n      var botRight = [x0 + xstep, y0 + ystep];\r\n      var width = botRight[0] - topLeft[0];\r\n      var height = botRight[1] - topLeft[1];\r\n      var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\r\n      var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\r\n      var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\r\n      width = Math.min(Math.ceil(Math.abs(width * combinedScale[0])), MAX_PATTERN_SIZE);\r\n      height = Math.min(Math.ceil(Math.abs(height * combinedScale[1])), MAX_PATTERN_SIZE);\r\n      var tmpCanvas = owner.cachedCanvases.getCanvas('pattern', width, height, true);\r\n      var tmpCtx = tmpCanvas.context;\r\n      var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\r\n      graphics.groupLevel = owner.groupLevel;\r\n      this.setFillAndStrokeStyleToContext(graphics, paintType, color);\r\n      this.setScale(width, height, xstep, ystep);\r\n      this.transformToScale(graphics);\r\n      var tmpTranslate = [1, 0, 0, 1, -topLeft[0], -topLeft[1]];\r\n      graphics.transform.apply(graphics, tmpTranslate);\r\n      this.clipBbox(graphics, bbox, x0, y0, x1, y1);\r\n      graphics.executeOperatorList(operatorList);\r\n      return tmpCanvas.canvas;\r\n    },\r\n    setScale: function TilingPattern_setScale(width, height, xstep, ystep) {\r\n      this.scale = [width / xstep, height / ystep];\r\n    },\r\n    transformToScale: function TilingPattern_transformToScale(graphics) {\r\n      var scale = this.scale;\r\n      var tmpScale = [scale[0], 0, 0, scale[1], 0, 0];\r\n      graphics.transform.apply(graphics, tmpScale);\r\n    },\r\n    scaleToContext: function TilingPattern_scaleToContext() {\r\n      var scale = this.scale;\r\n      this.ctx.scale(1 / scale[0], 1 / scale[1]);\r\n    },\r\n    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\r\n      if (Array.isArray(bbox) && bbox.length === 4) {\r\n        var bboxWidth = x1 - x0;\r\n        var bboxHeight = y1 - y0;\r\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\r\n        graphics.clip();\r\n        graphics.endPath();\r\n      }\r\n    },\r\n    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {\r\n      var context = graphics.ctx,\r\n          current = graphics.current;\r\n      switch (paintType) {\r\n        case PaintType.COLORED:\r\n          var ctx = this.ctx;\r\n          context.fillStyle = ctx.fillStyle;\r\n          context.strokeStyle = ctx.strokeStyle;\r\n          current.fillColor = ctx.fillStyle;\r\n          current.strokeColor = ctx.strokeStyle;\r\n          break;\r\n        case PaintType.UNCOLORED:\r\n          var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);\r\n          context.fillStyle = cssColor;\r\n          context.strokeStyle = cssColor;\r\n          current.fillColor = cssColor;\r\n          current.strokeColor = cssColor;\r\n          break;\r\n        default:\r\n          throw new _util.FormatError('Unsupported paint type: ' + paintType);\r\n      }\r\n    },\r\n    getPattern: function TilingPattern_getPattern(ctx, owner) {\r\n      var temporaryPatternCanvas = this.createPatternCanvas(owner);\r\n      ctx = this.ctx;\r\n      ctx.setTransform.apply(ctx, this.baseTransform);\r\n      ctx.transform.apply(ctx, this.matrix);\r\n      this.scaleToContext();\r\n      return ctx.createPattern(temporaryPatternCanvas, 'repeat');\r\n    }\r\n  };\r\n  return TilingPattern;\r\n}();\r\nexports.getShadingPatternFromIR = getShadingPatternFromIR;\r\nexports.TilingPattern = TilingPattern;\r\n\r\n/***/ }),\r\n/* 121 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.Metadata = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _xml_parser = __w_pdfjs_require__(122);\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar Metadata = function () {\r\n  function Metadata(data) {\r\n    _classCallCheck(this, Metadata);\r\n\r\n    (0, _util.assert)(typeof data === 'string', 'Metadata: input is not a string');\r\n    data = this._repair(data);\r\n    var parser = new _xml_parser.SimpleXMLParser();\r\n    var xmlDocument = parser.parseFromString(data);\r\n    this._metadata = Object.create(null);\r\n    if (xmlDocument) {\r\n      this._parse(xmlDocument);\r\n    }\r\n  }\r\n\r\n  _createClass(Metadata, [{\r\n    key: '_repair',\r\n    value: function _repair(data) {\r\n      return data.replace(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\r\n        var bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\r\n          return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\r\n        }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {\r\n          switch (name) {\r\n            case 'amp':\r\n              return '&';\r\n            case 'apos':\r\n              return '\\'';\r\n            case 'gt':\r\n              return '>';\r\n            case 'lt':\r\n              return '<';\r\n            case 'quot':\r\n              return '\\\"';\r\n          }\r\n          throw new Error('_repair: ' + name + ' isn\\'t defined.');\r\n        });\r\n        var chars = '';\r\n        for (var i = 0, ii = bytes.length; i < ii; i += 2) {\r\n          var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\r\n          if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {\r\n            chars += String.fromCharCode(code);\r\n          } else {\r\n            chars += '&#x' + (0x10000 + code).toString(16).substring(1) + ';';\r\n          }\r\n        }\r\n        return '>' + chars;\r\n      });\r\n    }\r\n  }, {\r\n    key: '_parse',\r\n    value: function _parse(xmlDocument) {\r\n      var rdf = xmlDocument.documentElement;\r\n      if (rdf.nodeName.toLowerCase() !== 'rdf:rdf') {\r\n        rdf = rdf.firstChild;\r\n        while (rdf && rdf.nodeName.toLowerCase() !== 'rdf:rdf') {\r\n          rdf = rdf.nextSibling;\r\n        }\r\n      }\r\n      var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;\r\n      if (!rdf || nodeName !== 'rdf:rdf' || !rdf.hasChildNodes()) {\r\n        return;\r\n      }\r\n      var children = rdf.childNodes;\r\n      for (var i = 0, ii = children.length; i < ii; i++) {\r\n        var desc = children[i];\r\n        if (desc.nodeName.toLowerCase() !== 'rdf:description') {\r\n          continue;\r\n        }\r\n        for (var j = 0, jj = desc.childNodes.length; j < jj; j++) {\r\n          if (desc.childNodes[j].nodeName.toLowerCase() !== '#text') {\r\n            var entry = desc.childNodes[j];\r\n            var name = entry.nodeName.toLowerCase();\r\n            this._metadata[name] = entry.textContent.trim();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: 'get',\r\n    value: function get(name) {\r\n      return this._metadata[name] || null;\r\n    }\r\n  }, {\r\n    key: 'getAll',\r\n    value: function getAll() {\r\n      return this._metadata;\r\n    }\r\n  }, {\r\n    key: 'has',\r\n    value: function has(name) {\r\n      return typeof this._metadata[name] !== 'undefined';\r\n    }\r\n  }]);\r\n\r\n  return Metadata;\r\n}();\r\n\r\nexports.Metadata = Metadata;\r\n\r\n/***/ }),\r\n/* 122 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar XMLParserErrorCode = {\r\n  NoError: 0,\r\n  EndOfDocument: -1,\r\n  UnterminatedCdat: -2,\r\n  UnterminatedXmlDeclaration: -3,\r\n  UnterminatedDoctypeDeclaration: -4,\r\n  UnterminatedComment: -5,\r\n  MalformedElement: -6,\r\n  OutOfMemory: -7,\r\n  UnterminatedAttributeValue: -8,\r\n  UnterminatedElement: -9,\r\n  ElementNeverBegun: -10\r\n};\r\nfunction isWhitespace(s, index) {\r\n  var ch = s[index];\r\n  return ch === ' ' || ch === '\\n' || ch === '\\r' || ch === '\\t';\r\n}\r\nfunction isWhitespaceString(s) {\r\n  for (var i = 0, ii = s.length; i < ii; i++) {\r\n    if (!isWhitespace(s, i)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nvar XMLParserBase = function () {\r\n  function XMLParserBase() {\r\n    _classCallCheck(this, XMLParserBase);\r\n  }\r\n\r\n  _createClass(XMLParserBase, [{\r\n    key: '_resolveEntities',\r\n    value: function _resolveEntities(s) {\r\n      return s.replace(/&([^;]+);/g, function (all, entity) {\r\n        if (entity.substring(0, 2) === '#x') {\r\n          return String.fromCharCode(parseInt(entity.substring(2), 16));\r\n        } else if (entity.substring(0, 1) === '#') {\r\n          return String.fromCharCode(parseInt(entity.substring(1), 10));\r\n        }\r\n        switch (entity) {\r\n          case 'lt':\r\n            return '<';\r\n          case 'gt':\r\n            return '>';\r\n          case 'amp':\r\n            return '&';\r\n          case 'quot':\r\n            return '\\\"';\r\n        }\r\n        return this.onResolveEntity(entity);\r\n      });\r\n    }\r\n  }, {\r\n    key: '_parseContent',\r\n    value: function _parseContent(s, start) {\r\n      var pos = start,\r\n          name = void 0,\r\n          attributes = [];\r\n      function skipWs() {\r\n        while (pos < s.length && isWhitespace(s, pos)) {\r\n          ++pos;\r\n        }\r\n      }\r\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {\r\n        ++pos;\r\n      }\r\n      name = s.substring(start, pos);\r\n      skipWs();\r\n      while (pos < s.length && s[pos] !== '>' && s[pos] !== '/' && s[pos] !== '?') {\r\n        skipWs();\r\n        var attrName = '',\r\n            attrValue = '';\r\n        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '=') {\r\n          attrName += s[pos];\r\n          ++pos;\r\n        }\r\n        skipWs();\r\n        if (s[pos] !== '=') {\r\n          return null;\r\n        }\r\n        ++pos;\r\n        skipWs();\r\n        var attrEndChar = s[pos];\r\n        if (attrEndChar !== '\\\"' && attrEndChar !== '\\'') {\r\n          return null;\r\n        }\r\n        var attrEndIndex = s.indexOf(attrEndChar, ++pos);\r\n        if (attrEndIndex < 0) {\r\n          return null;\r\n        }\r\n        attrValue = s.substring(pos, attrEndIndex);\r\n        attributes.push({\r\n          name: attrName,\r\n          value: this._resolveEntities(attrValue)\r\n        });\r\n        pos = attrEndIndex + 1;\r\n        skipWs();\r\n      }\r\n      return {\r\n        name: name,\r\n        attributes: attributes,\r\n        parsed: pos - start\r\n      };\r\n    }\r\n  }, {\r\n    key: '_parseProcessingInstruction',\r\n    value: function _parseProcessingInstruction(s, start) {\r\n      var pos = start,\r\n          name = void 0,\r\n          value = void 0;\r\n      function skipWs() {\r\n        while (pos < s.length && isWhitespace(s, pos)) {\r\n          ++pos;\r\n        }\r\n      }\r\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {\r\n        ++pos;\r\n      }\r\n      name = s.substring(start, pos);\r\n      skipWs();\r\n      var attrStart = pos;\r\n      while (pos < s.length && (s[pos] !== '?' || s[pos + 1] !== '>')) {\r\n        ++pos;\r\n      }\r\n      value = s.substring(attrStart, pos);\r\n      return {\r\n        name: name,\r\n        value: value,\r\n        parsed: pos - start\r\n      };\r\n    }\r\n  }, {\r\n    key: 'parseXml',\r\n    value: function parseXml(s) {\r\n      var i = 0;\r\n      while (i < s.length) {\r\n        var ch = s[i];\r\n        var j = i;\r\n        if (ch === '<') {\r\n          ++j;\r\n          var ch2 = s[j];\r\n          var q = void 0;\r\n          switch (ch2) {\r\n            case '/':\r\n              ++j;\r\n              q = s.indexOf('>', j);\r\n              if (q < 0) {\r\n                this.onError(XMLParserErrorCode.UnterminatedElement);\r\n                return;\r\n              }\r\n              this.onEndElement(s.substring(j, q));\r\n              j = q + 1;\r\n              break;\r\n            case '?':\r\n              ++j;\r\n              var pi = this._parseProcessingInstruction(s, j);\r\n              if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== '?>') {\r\n                this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);\r\n                return;\r\n              }\r\n              this.onPi(pi.name, pi.value);\r\n              j += pi.parsed + 2;\r\n              break;\r\n            case '!':\r\n              if (s.substring(j + 1, j + 3) === '--') {\r\n                q = s.indexOf('-->', j + 3);\r\n                if (q < 0) {\r\n                  this.onError(XMLParserErrorCode.UnterminatedComment);\r\n                  return;\r\n                }\r\n                this.onComment(s.substring(j + 3, q));\r\n                j = q + 3;\r\n              } else if (s.substring(j + 1, j + 8) === '[CDATA[') {\r\n                q = s.indexOf(']]>', j + 8);\r\n                if (q < 0) {\r\n                  this.onError(XMLParserErrorCode.UnterminatedCdat);\r\n                  return;\r\n                }\r\n                this.onCdata(s.substring(j + 8, q));\r\n                j = q + 3;\r\n              } else if (s.substring(j + 1, j + 8) === 'DOCTYPE') {\r\n                var q2 = s.indexOf('[', j + 8);\r\n                var complexDoctype = false;\r\n                q = s.indexOf('>', j + 8);\r\n                if (q < 0) {\r\n                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\r\n                  return;\r\n                }\r\n                if (q2 > 0 && q > q2) {\r\n                  q = s.indexOf(']>', j + 8);\r\n                  if (q < 0) {\r\n                    this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\r\n                    return;\r\n                  }\r\n                  complexDoctype = true;\r\n                }\r\n                var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));\r\n                this.onDoctype(doctypeContent);\r\n                j = q + (complexDoctype ? 2 : 1);\r\n              } else {\r\n                this.onError(XMLParserErrorCode.MalformedElement);\r\n                return;\r\n              }\r\n              break;\r\n            default:\r\n              var content = this._parseContent(s, j);\r\n              if (content === null) {\r\n                this.onError(XMLParserErrorCode.MalformedElement);\r\n                return;\r\n              }\r\n              var isClosed = false;\r\n              if (s.substring(j + content.parsed, j + content.parsed + 2) === '/>') {\r\n                isClosed = true;\r\n              } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== '>') {\r\n                this.onError(XMLParserErrorCode.UnterminatedElement);\r\n                return;\r\n              }\r\n              this.onBeginElement(content.name, content.attributes, isClosed);\r\n              j += content.parsed + (isClosed ? 2 : 1);\r\n              break;\r\n          }\r\n        } else {\r\n          while (j < s.length && s[j] !== '<') {\r\n            j++;\r\n          }\r\n          var text = s.substring(i, j);\r\n          this.onText(this._resolveEntities(text));\r\n        }\r\n        i = j;\r\n      }\r\n    }\r\n  }, {\r\n    key: 'onResolveEntity',\r\n    value: function onResolveEntity(name) {\r\n      return '&' + name + ';';\r\n    }\r\n  }, {\r\n    key: 'onPi',\r\n    value: function onPi(name, value) {}\r\n  }, {\r\n    key: 'onComment',\r\n    value: function onComment(text) {}\r\n  }, {\r\n    key: 'onCdata',\r\n    value: function onCdata(text) {}\r\n  }, {\r\n    key: 'onDoctype',\r\n    value: function onDoctype(doctypeContent) {}\r\n  }, {\r\n    key: 'onText',\r\n    value: function onText(text) {}\r\n  }, {\r\n    key: 'onBeginElement',\r\n    value: function onBeginElement(name, attributes, isEmpty) {}\r\n  }, {\r\n    key: 'onEndElement',\r\n    value: function onEndElement(name) {}\r\n  }, {\r\n    key: 'onError',\r\n    value: function onError(code) {}\r\n  }]);\r\n\r\n  return XMLParserBase;\r\n}();\r\n\r\nvar SimpleDOMNode = function () {\r\n  function SimpleDOMNode(nodeName, nodeValue) {\r\n    _classCallCheck(this, SimpleDOMNode);\r\n\r\n    this.nodeName = nodeName;\r\n    this.nodeValue = nodeValue;\r\n    Object.defineProperty(this, 'parentNode', {\r\n      value: null,\r\n      writable: true\r\n    });\r\n  }\r\n\r\n  _createClass(SimpleDOMNode, [{\r\n    key: 'hasChildNodes',\r\n    value: function hasChildNodes() {\r\n      return this.childNodes && this.childNodes.length > 0;\r\n    }\r\n  }, {\r\n    key: 'firstChild',\r\n    get: function get() {\r\n      return this.childNodes[0];\r\n    }\r\n  }, {\r\n    key: 'nextSibling',\r\n    get: function get() {\r\n      var index = this.parentNode.childNodes.indexOf(this);\r\n      return this.parentNode.childNodes[index + 1];\r\n    }\r\n  }, {\r\n    key: 'textContent',\r\n    get: function get() {\r\n      if (!this.childNodes) {\r\n        return this.nodeValue || '';\r\n      }\r\n      return this.childNodes.map(function (child) {\r\n        return child.textContent;\r\n      }).join('');\r\n    }\r\n  }]);\r\n\r\n  return SimpleDOMNode;\r\n}();\r\n\r\nvar SimpleXMLParser = function (_XMLParserBase) {\r\n  _inherits(SimpleXMLParser, _XMLParserBase);\r\n\r\n  function SimpleXMLParser() {\r\n    _classCallCheck(this, SimpleXMLParser);\r\n\r\n    var _this = _possibleConstructorReturn(this, (SimpleXMLParser.__proto__ || Object.getPrototypeOf(SimpleXMLParser)).call(this));\r\n\r\n    _this._currentFragment = null;\r\n    _this._stack = null;\r\n    _this._errorCode = XMLParserErrorCode.NoError;\r\n    return _this;\r\n  }\r\n\r\n  _createClass(SimpleXMLParser, [{\r\n    key: 'parseFromString',\r\n    value: function parseFromString(data) {\r\n      this._currentFragment = [];\r\n      this._stack = [];\r\n      this._errorCode = XMLParserErrorCode.NoError;\r\n      this.parseXml(data);\r\n      if (this._errorCode !== XMLParserErrorCode.NoError) {\r\n        return undefined;\r\n      }\r\n\r\n      var _currentFragment = _slicedToArray(this._currentFragment, 1),\r\n          documentElement = _currentFragment[0];\r\n\r\n      return { documentElement: documentElement };\r\n    }\r\n  }, {\r\n    key: 'onResolveEntity',\r\n    value: function onResolveEntity(name) {\r\n      switch (name) {\r\n        case 'apos':\r\n          return '\\'';\r\n      }\r\n      return _get(SimpleXMLParser.prototype.__proto__ || Object.getPrototypeOf(SimpleXMLParser.prototype), 'onResolveEntity', this).call(this, name);\r\n    }\r\n  }, {\r\n    key: 'onText',\r\n    value: function onText(text) {\r\n      if (isWhitespaceString(text)) {\r\n        return;\r\n      }\r\n      var node = new SimpleDOMNode('#text', text);\r\n      this._currentFragment.push(node);\r\n    }\r\n  }, {\r\n    key: 'onCdata',\r\n    value: function onCdata(text) {\r\n      var node = new SimpleDOMNode('#text', text);\r\n      this._currentFragment.push(node);\r\n    }\r\n  }, {\r\n    key: 'onBeginElement',\r\n    value: function onBeginElement(name, attributes, isEmpty) {\r\n      var node = new SimpleDOMNode(name);\r\n      node.childNodes = [];\r\n      this._currentFragment.push(node);\r\n      if (isEmpty) {\r\n        return;\r\n      }\r\n      this._stack.push(this._currentFragment);\r\n      this._currentFragment = node.childNodes;\r\n    }\r\n  }, {\r\n    key: 'onEndElement',\r\n    value: function onEndElement(name) {\r\n      this._currentFragment = this._stack.pop();\r\n      var lastElement = this._currentFragment[this._currentFragment.length - 1];\r\n      for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {\r\n        lastElement.childNodes[i].parentNode = lastElement;\r\n      }\r\n    }\r\n  }, {\r\n    key: 'onError',\r\n    value: function onError(code) {\r\n      this._errorCode = code;\r\n    }\r\n  }]);\r\n\r\n  return SimpleXMLParser;\r\n}(XMLParserBase);\r\n\r\nexports.SimpleXMLParser = SimpleXMLParser;\r\n\r\n/***/ }),\r\n/* 123 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.PDFDataTransportStream = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar PDFDataTransportStream = function PDFDataTransportStreamClosure() {\r\n  function PDFDataTransportStream(params, pdfDataRangeTransport) {\r\n    var _this = this;\r\n\r\n    (0, _util.assert)(pdfDataRangeTransport);\r\n    this._queuedChunks = [];\r\n    var initialData = params.initialData;\r\n    if (initialData && initialData.length > 0) {\r\n      var buffer = new Uint8Array(initialData).buffer;\r\n      this._queuedChunks.push(buffer);\r\n    }\r\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\r\n    this._isStreamingSupported = !params.disableStream;\r\n    this._isRangeSupported = !params.disableRange;\r\n    this._contentLength = params.length;\r\n    this._fullRequestReader = null;\r\n    this._rangeReaders = [];\r\n    this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {\r\n      _this._onReceiveData({\r\n        begin: begin,\r\n        chunk: chunk\r\n      });\r\n    });\r\n    this._pdfDataRangeTransport.addProgressListener(function (loaded) {\r\n      _this._onProgress({ loaded: loaded });\r\n    });\r\n    this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {\r\n      _this._onReceiveData({ chunk: chunk });\r\n    });\r\n    this._pdfDataRangeTransport.transportReady();\r\n  }\r\n  PDFDataTransportStream.prototype = {\r\n    _onReceiveData: function PDFDataTransportStream_onReceiveData(args) {\r\n      var buffer = new Uint8Array(args.chunk).buffer;\r\n      if (args.begin === undefined) {\r\n        if (this._fullRequestReader) {\r\n          this._fullRequestReader._enqueue(buffer);\r\n        } else {\r\n          this._queuedChunks.push(buffer);\r\n        }\r\n      } else {\r\n        var found = this._rangeReaders.some(function (rangeReader) {\r\n          if (rangeReader._begin !== args.begin) {\r\n            return false;\r\n          }\r\n          rangeReader._enqueue(buffer);\r\n          return true;\r\n        });\r\n        (0, _util.assert)(found);\r\n      }\r\n    },\r\n    _onProgress: function PDFDataTransportStream_onDataProgress(evt) {\r\n      if (this._rangeReaders.length > 0) {\r\n        var firstReader = this._rangeReaders[0];\r\n        if (firstReader.onProgress) {\r\n          firstReader.onProgress({ loaded: evt.loaded });\r\n        }\r\n      }\r\n    },\r\n    _removeRangeReader: function PDFDataTransportStream_removeRangeReader(reader) {\r\n      var i = this._rangeReaders.indexOf(reader);\r\n      if (i >= 0) {\r\n        this._rangeReaders.splice(i, 1);\r\n      }\r\n    },\r\n    getFullReader: function PDFDataTransportStream_getFullReader() {\r\n      (0, _util.assert)(!this._fullRequestReader);\r\n      var queuedChunks = this._queuedChunks;\r\n      this._queuedChunks = null;\r\n      return new PDFDataTransportStreamReader(this, queuedChunks);\r\n    },\r\n    getRangeReader: function PDFDataTransportStream_getRangeReader(begin, end) {\r\n      var reader = new PDFDataTransportStreamRangeReader(this, begin, end);\r\n      this._pdfDataRangeTransport.requestDataRange(begin, end);\r\n      this._rangeReaders.push(reader);\r\n      return reader;\r\n    },\r\n    cancelAllRequests: function PDFDataTransportStream_cancelAllRequests(reason) {\r\n      if (this._fullRequestReader) {\r\n        this._fullRequestReader.cancel(reason);\r\n      }\r\n      var readers = this._rangeReaders.slice(0);\r\n      readers.forEach(function (rangeReader) {\r\n        rangeReader.cancel(reason);\r\n      });\r\n      this._pdfDataRangeTransport.abort();\r\n    }\r\n  };\r\n  function PDFDataTransportStreamReader(stream, queuedChunks) {\r\n    this._stream = stream;\r\n    this._done = false;\r\n    this._filename = null;\r\n    this._queuedChunks = queuedChunks || [];\r\n    this._requests = [];\r\n    this._headersReady = Promise.resolve();\r\n    stream._fullRequestReader = this;\r\n    this.onProgress = null;\r\n  }\r\n  PDFDataTransportStreamReader.prototype = {\r\n    _enqueue: function PDFDataTransportStreamReader_enqueue(chunk) {\r\n      if (this._done) {\r\n        return;\r\n      }\r\n      if (this._requests.length > 0) {\r\n        var requestCapability = this._requests.shift();\r\n        requestCapability.resolve({\r\n          value: chunk,\r\n          done: false\r\n        });\r\n        return;\r\n      }\r\n      this._queuedChunks.push(chunk);\r\n    },\r\n    get headersReady() {\r\n      return this._headersReady;\r\n    },\r\n    get filename() {\r\n      return this._filename;\r\n    },\r\n    get isRangeSupported() {\r\n      return this._stream._isRangeSupported;\r\n    },\r\n    get isStreamingSupported() {\r\n      return this._stream._isStreamingSupported;\r\n    },\r\n    get contentLength() {\r\n      return this._stream._contentLength;\r\n    },\r\n    read: function PDFDataTransportStreamReader_read() {\r\n      if (this._queuedChunks.length > 0) {\r\n        var chunk = this._queuedChunks.shift();\r\n        return Promise.resolve({\r\n          value: chunk,\r\n          done: false\r\n        });\r\n      }\r\n      if (this._done) {\r\n        return Promise.resolve({\r\n          value: undefined,\r\n          done: true\r\n        });\r\n      }\r\n      var requestCapability = (0, _util.createPromiseCapability)();\r\n      this._requests.push(requestCapability);\r\n      return requestCapability.promise;\r\n    },\r\n    cancel: function PDFDataTransportStreamReader_cancel(reason) {\r\n      this._done = true;\r\n      this._requests.forEach(function (requestCapability) {\r\n        requestCapability.resolve({\r\n          value: undefined,\r\n          done: true\r\n        });\r\n      });\r\n      this._requests = [];\r\n    }\r\n  };\r\n  function PDFDataTransportStreamRangeReader(stream, begin, end) {\r\n    this._stream = stream;\r\n    this._begin = begin;\r\n    this._end = end;\r\n    this._queuedChunk = null;\r\n    this._requests = [];\r\n    this._done = false;\r\n    this.onProgress = null;\r\n  }\r\n  PDFDataTransportStreamRangeReader.prototype = {\r\n    _enqueue: function PDFDataTransportStreamRangeReader_enqueue(chunk) {\r\n      if (this._done) {\r\n        return;\r\n      }\r\n      if (this._requests.length === 0) {\r\n        this._queuedChunk = chunk;\r\n      } else {\r\n        var requestsCapability = this._requests.shift();\r\n        requestsCapability.resolve({\r\n          value: chunk,\r\n          done: false\r\n        });\r\n        this._requests.forEach(function (requestCapability) {\r\n          requestCapability.resolve({\r\n            value: undefined,\r\n            done: true\r\n          });\r\n        });\r\n        this._requests = [];\r\n      }\r\n      this._done = true;\r\n      this._stream._removeRangeReader(this);\r\n    },\r\n    get isStreamingSupported() {\r\n      return false;\r\n    },\r\n    read: function PDFDataTransportStreamRangeReader_read() {\r\n      if (this._queuedChunk) {\r\n        var chunk = this._queuedChunk;\r\n        this._queuedChunk = null;\r\n        return Promise.resolve({\r\n          value: chunk,\r\n          done: false\r\n        });\r\n      }\r\n      if (this._done) {\r\n        return Promise.resolve({\r\n          value: undefined,\r\n          done: true\r\n        });\r\n      }\r\n      var requestCapability = (0, _util.createPromiseCapability)();\r\n      this._requests.push(requestCapability);\r\n      return requestCapability.promise;\r\n    },\r\n    cancel: function PDFDataTransportStreamRangeReader_cancel(reason) {\r\n      this._done = true;\r\n      this._requests.forEach(function (requestCapability) {\r\n        requestCapability.resolve({\r\n          value: undefined,\r\n          done: true\r\n        });\r\n      });\r\n      this._requests = [];\r\n      this._stream._removeRangeReader(this);\r\n    }\r\n  };\r\n  return PDFDataTransportStream;\r\n}();\r\nexports.PDFDataTransportStream = PDFDataTransportStream;\r\n\r\n/***/ }),\r\n/* 124 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.WebGLContext = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar WebGLContext = function () {\r\n  function WebGLContext(_ref) {\r\n    var _ref$enable = _ref.enable,\r\n        enable = _ref$enable === undefined ? false : _ref$enable;\r\n\r\n    _classCallCheck(this, WebGLContext);\r\n\r\n    this._enabled = enable === true;\r\n  }\r\n\r\n  _createClass(WebGLContext, [{\r\n    key: 'composeSMask',\r\n    value: function composeSMask(_ref2) {\r\n      var layer = _ref2.layer,\r\n          mask = _ref2.mask,\r\n          properties = _ref2.properties;\r\n\r\n      return WebGLUtils.composeSMask(layer, mask, properties);\r\n    }\r\n  }, {\r\n    key: 'drawFigures',\r\n    value: function drawFigures(_ref3) {\r\n      var width = _ref3.width,\r\n          height = _ref3.height,\r\n          backgroundColor = _ref3.backgroundColor,\r\n          figures = _ref3.figures,\r\n          context = _ref3.context;\r\n\r\n      return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);\r\n    }\r\n  }, {\r\n    key: 'clear',\r\n    value: function clear() {\r\n      WebGLUtils.cleanup();\r\n    }\r\n  }, {\r\n    key: 'isEnabled',\r\n    get: function get() {\r\n      var enabled = this._enabled;\r\n      if (enabled) {\r\n        enabled = WebGLUtils.tryInitGL();\r\n      }\r\n      return (0, _util.shadow)(this, 'isEnabled', enabled);\r\n    }\r\n  }]);\r\n\r\n  return WebGLContext;\r\n}();\r\n\r\nvar WebGLUtils = function WebGLUtilsClosure() {\r\n  function loadShader(gl, code, shaderType) {\r\n    var shader = gl.createShader(shaderType);\r\n    gl.shaderSource(shader, code);\r\n    gl.compileShader(shader);\r\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!compiled) {\r\n      var errorMsg = gl.getShaderInfoLog(shader);\r\n      throw new Error('Error during shader compilation: ' + errorMsg);\r\n    }\r\n    return shader;\r\n  }\r\n  function createVertexShader(gl, code) {\r\n    return loadShader(gl, code, gl.VERTEX_SHADER);\r\n  }\r\n  function createFragmentShader(gl, code) {\r\n    return loadShader(gl, code, gl.FRAGMENT_SHADER);\r\n  }\r\n  function createProgram(gl, shaders) {\r\n    var program = gl.createProgram();\r\n    for (var i = 0, ii = shaders.length; i < ii; ++i) {\r\n      gl.attachShader(program, shaders[i]);\r\n    }\r\n    gl.linkProgram(program);\r\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!linked) {\r\n      var errorMsg = gl.getProgramInfoLog(program);\r\n      throw new Error('Error during program linking: ' + errorMsg);\r\n    }\r\n    return program;\r\n  }\r\n  function createTexture(gl, image, textureId) {\r\n    gl.activeTexture(textureId);\r\n    var texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n    return texture;\r\n  }\r\n  var currentGL, currentCanvas;\r\n  function generateGL() {\r\n    if (currentGL) {\r\n      return;\r\n    }\r\n    currentCanvas = document.createElement('canvas');\r\n    currentGL = currentCanvas.getContext('webgl', { premultipliedalpha: false });\r\n  }\r\n  var smaskVertexShaderCode = '\\\r\n  attribute vec2 a_position;                                    \\\r\n  attribute vec2 a_texCoord;                                    \\\r\n                                                                \\\r\n  uniform vec2 u_resolution;                                    \\\r\n                                                                \\\r\n  varying vec2 v_texCoord;                                      \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\r\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\r\n                                                                \\\r\n    v_texCoord = a_texCoord;                                    \\\r\n  }                                                             ';\r\n  var smaskFragmentShaderCode = '\\\r\n  precision mediump float;                                      \\\r\n                                                                \\\r\n  uniform vec4 u_backdrop;                                      \\\r\n  uniform int u_subtype;                                        \\\r\n  uniform sampler2D u_image;                                    \\\r\n  uniform sampler2D u_mask;                                     \\\r\n                                                                \\\r\n  varying vec2 v_texCoord;                                      \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec4 imageColor = texture2D(u_image, v_texCoord);           \\\r\n    vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\r\n    if (u_backdrop.a > 0.0) {                                   \\\r\n      maskColor.rgb = maskColor.rgb * maskColor.a +             \\\r\n                      u_backdrop.rgb * (1.0 - maskColor.a);     \\\r\n    }                                                           \\\r\n    float lum;                                                  \\\r\n    if (u_subtype == 0) {                                       \\\r\n      lum = maskColor.a;                                        \\\r\n    } else {                                                    \\\r\n      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\r\n            maskColor.b * 0.11;                                 \\\r\n    }                                                           \\\r\n    imageColor.a *= lum;                                        \\\r\n    imageColor.rgb *= imageColor.a;                             \\\r\n    gl_FragColor = imageColor;                                  \\\r\n  }                                                             ';\r\n  var smaskCache = null;\r\n  function initSmaskGL() {\r\n    var canvas, gl;\r\n    generateGL();\r\n    canvas = currentCanvas;\r\n    currentCanvas = null;\r\n    gl = currentGL;\r\n    currentGL = null;\r\n    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);\r\n    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\r\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\r\n    gl.useProgram(program);\r\n    var cache = {};\r\n    cache.gl = gl;\r\n    cache.canvas = canvas;\r\n    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\r\n    cache.positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    cache.backdropLocation = gl.getUniformLocation(program, 'u_backdrop');\r\n    cache.subtypeLocation = gl.getUniformLocation(program, 'u_subtype');\r\n    var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');\r\n    var texLayerLocation = gl.getUniformLocation(program, 'u_image');\r\n    var texMaskLocation = gl.getUniformLocation(program, 'u_mask');\r\n    var texCoordBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(texCoordLocation);\r\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.uniform1i(texLayerLocation, 0);\r\n    gl.uniform1i(texMaskLocation, 1);\r\n    smaskCache = cache;\r\n  }\r\n  function composeSMask(layer, mask, properties) {\r\n    var width = layer.width,\r\n        height = layer.height;\r\n    if (!smaskCache) {\r\n      initSmaskGL();\r\n    }\r\n    var cache = smaskCache,\r\n        canvas = cache.canvas,\r\n        gl = cache.gl;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    gl.uniform2f(cache.resolutionLocation, width, height);\r\n    if (properties.backdrop) {\r\n      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);\r\n    } else {\r\n      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\r\n    }\r\n    gl.uniform1i(cache.subtypeLocation, properties.subtype === 'Luminosity' ? 1 : 0);\r\n    var texture = createTexture(gl, layer, gl.TEXTURE0);\r\n    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);\r\n    var buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(cache.positionLocation);\r\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    gl.flush();\r\n    gl.deleteTexture(texture);\r\n    gl.deleteTexture(maskTexture);\r\n    gl.deleteBuffer(buffer);\r\n    return canvas;\r\n  }\r\n  var figuresVertexShaderCode = '\\\r\n  attribute vec2 a_position;                                    \\\r\n  attribute vec3 a_color;                                       \\\r\n                                                                \\\r\n  uniform vec2 u_resolution;                                    \\\r\n  uniform vec2 u_scale;                                         \\\r\n  uniform vec2 u_offset;                                        \\\r\n                                                                \\\r\n  varying vec4 v_color;                                         \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    vec2 position = (a_position + u_offset) * u_scale;          \\\r\n    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\r\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\r\n                                                                \\\r\n    v_color = vec4(a_color / 255.0, 1.0);                       \\\r\n  }                                                             ';\r\n  var figuresFragmentShaderCode = '\\\r\n  precision mediump float;                                      \\\r\n                                                                \\\r\n  varying vec4 v_color;                                         \\\r\n                                                                \\\r\n  void main() {                                                 \\\r\n    gl_FragColor = v_color;                                     \\\r\n  }                                                             ';\r\n  var figuresCache = null;\r\n  function initFiguresGL() {\r\n    var canvas, gl;\r\n    generateGL();\r\n    canvas = currentCanvas;\r\n    currentCanvas = null;\r\n    gl = currentGL;\r\n    currentGL = null;\r\n    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);\r\n    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\r\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\r\n    gl.useProgram(program);\r\n    var cache = {};\r\n    cache.gl = gl;\r\n    cache.canvas = canvas;\r\n    cache.resolutionLocation = gl.getUniformLocation(program, 'u_resolution');\r\n    cache.scaleLocation = gl.getUniformLocation(program, 'u_scale');\r\n    cache.offsetLocation = gl.getUniformLocation(program, 'u_offset');\r\n    cache.positionLocation = gl.getAttribLocation(program, 'a_position');\r\n    cache.colorLocation = gl.getAttribLocation(program, 'a_color');\r\n    figuresCache = cache;\r\n  }\r\n  function drawFigures(width, height, backgroundColor, figures, context) {\r\n    if (!figuresCache) {\r\n      initFiguresGL();\r\n    }\r\n    var cache = figuresCache,\r\n        canvas = cache.canvas,\r\n        gl = cache.gl;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n    gl.uniform2f(cache.resolutionLocation, width, height);\r\n    var count = 0;\r\n    var i, ii, rows;\r\n    for (i = 0, ii = figures.length; i < ii; i++) {\r\n      switch (figures[i].type) {\r\n        case 'lattice':\r\n          rows = figures[i].coords.length / figures[i].verticesPerRow | 0;\r\n          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\r\n          break;\r\n        case 'triangles':\r\n          count += figures[i].coords.length;\r\n          break;\r\n      }\r\n    }\r\n    var coords = new Float32Array(count * 2);\r\n    var colors = new Uint8Array(count * 3);\r\n    var coordsMap = context.coords,\r\n        colorsMap = context.colors;\r\n    var pIndex = 0,\r\n        cIndex = 0;\r\n    for (i = 0, ii = figures.length; i < ii; i++) {\r\n      var figure = figures[i],\r\n          ps = figure.coords,\r\n          cs = figure.colors;\r\n      switch (figure.type) {\r\n        case 'lattice':\r\n          var cols = figure.verticesPerRow;\r\n          rows = ps.length / cols | 0;\r\n          for (var row = 1; row < rows; row++) {\r\n            var offset = row * cols + 1;\r\n            for (var col = 1; col < cols; col++, offset++) {\r\n              coords[pIndex] = coordsMap[ps[offset - cols - 1]];\r\n              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\r\n              coords[pIndex + 2] = coordsMap[ps[offset - cols]];\r\n              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\r\n              coords[pIndex + 4] = coordsMap[ps[offset - 1]];\r\n              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\r\n              colors[cIndex] = colorsMap[cs[offset - cols - 1]];\r\n              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\r\n              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\r\n              colors[cIndex + 3] = colorsMap[cs[offset - cols]];\r\n              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\r\n              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\r\n              colors[cIndex + 6] = colorsMap[cs[offset - 1]];\r\n              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\r\n              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\r\n              coords[pIndex + 6] = coords[pIndex + 2];\r\n              coords[pIndex + 7] = coords[pIndex + 3];\r\n              coords[pIndex + 8] = coords[pIndex + 4];\r\n              coords[pIndex + 9] = coords[pIndex + 5];\r\n              coords[pIndex + 10] = coordsMap[ps[offset]];\r\n              coords[pIndex + 11] = coordsMap[ps[offset] + 1];\r\n              colors[cIndex + 9] = colors[cIndex + 3];\r\n              colors[cIndex + 10] = colors[cIndex + 4];\r\n              colors[cIndex + 11] = colors[cIndex + 5];\r\n              colors[cIndex + 12] = colors[cIndex + 6];\r\n              colors[cIndex + 13] = colors[cIndex + 7];\r\n              colors[cIndex + 14] = colors[cIndex + 8];\r\n              colors[cIndex + 15] = colorsMap[cs[offset]];\r\n              colors[cIndex + 16] = colorsMap[cs[offset] + 1];\r\n              colors[cIndex + 17] = colorsMap[cs[offset] + 2];\r\n              pIndex += 12;\r\n              cIndex += 18;\r\n            }\r\n          }\r\n          break;\r\n        case 'triangles':\r\n          for (var j = 0, jj = ps.length; j < jj; j++) {\r\n            coords[pIndex] = coordsMap[ps[j]];\r\n            coords[pIndex + 1] = coordsMap[ps[j] + 1];\r\n            colors[cIndex] = colorsMap[cs[j]];\r\n            colors[cIndex + 1] = colorsMap[cs[j] + 1];\r\n            colors[cIndex + 2] = colorsMap[cs[j] + 2];\r\n            pIndex += 2;\r\n            cIndex += 3;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    if (backgroundColor) {\r\n      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);\r\n    } else {\r\n      gl.clearColor(0, 0, 0, 0);\r\n    }\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    var coordsBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(cache.positionLocation);\r\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n    var colorsBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(cache.colorLocation);\r\n    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);\r\n    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\r\n    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\r\n    gl.drawArrays(gl.TRIANGLES, 0, count);\r\n    gl.flush();\r\n    gl.deleteBuffer(coordsBuffer);\r\n    gl.deleteBuffer(colorsBuffer);\r\n    return canvas;\r\n  }\r\n  return {\r\n    tryInitGL: function tryInitGL() {\r\n      try {\r\n        generateGL();\r\n        return !!currentGL;\r\n      } catch (ex) {}\r\n      return false;\r\n    },\r\n\r\n    composeSMask: composeSMask,\r\n    drawFigures: drawFigures,\r\n    cleanup: function cleanup() {\r\n      if (smaskCache && smaskCache.canvas) {\r\n        smaskCache.canvas.width = 0;\r\n        smaskCache.canvas.height = 0;\r\n      }\r\n      if (figuresCache && figuresCache.canvas) {\r\n        figuresCache.canvas.width = 0;\r\n        figuresCache.canvas.height = 0;\r\n      }\r\n      smaskCache = null;\r\n      figuresCache = null;\r\n    }\r\n  };\r\n}();\r\nexports.WebGLContext = WebGLContext;\r\n\r\n/***/ }),\r\n/* 125 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.renderTextLayer = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _global_scope = __w_pdfjs_require__(18);\r\n\r\nvar _global_scope2 = _interopRequireDefault(_global_scope);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar renderTextLayer = function renderTextLayerClosure() {\r\n  var MAX_TEXT_DIVS_TO_RENDER = 100000;\r\n  var NonWhitespaceRegexp = /\\S/;\r\n  function isAllWhitespace(str) {\r\n    return !NonWhitespaceRegexp.test(str);\r\n  }\r\n  var styleBuf = ['left: ', 0, 'px; top: ', 0, 'px; font-size: ', 0, 'px; font-family: ', '', ';'];\r\n  function appendText(task, geom, styles) {\r\n    var textDiv = document.createElement('div');\r\n    var textDivProperties = {\r\n      style: null,\r\n      angle: 0,\r\n      canvasWidth: 0,\r\n      isWhitespace: false,\r\n      originalTransform: null,\r\n      paddingBottom: 0,\r\n      paddingLeft: 0,\r\n      paddingRight: 0,\r\n      paddingTop: 0,\r\n      scale: 1\r\n    };\r\n    task._textDivs.push(textDiv);\r\n    if (isAllWhitespace(geom.str)) {\r\n      textDivProperties.isWhitespace = true;\r\n      task._textDivProperties.set(textDiv, textDivProperties);\r\n      return;\r\n    }\r\n    var tx = _util.Util.transform(task._viewport.transform, geom.transform);\r\n    var angle = Math.atan2(tx[1], tx[0]);\r\n    var style = styles[geom.fontName];\r\n    if (style.vertical) {\r\n      angle += Math.PI / 2;\r\n    }\r\n    var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);\r\n    var fontAscent = fontHeight;\r\n    if (style.ascent) {\r\n      fontAscent = style.ascent * fontAscent;\r\n    } else if (style.descent) {\r\n      fontAscent = (1 + style.descent) * fontAscent;\r\n    }\r\n    var left;\r\n    var top;\r\n    if (angle === 0) {\r\n      left = tx[4];\r\n      top = tx[5] - fontAscent;\r\n    } else {\r\n      left = tx[4] + fontAscent * Math.sin(angle);\r\n      top = tx[5] - fontAscent * Math.cos(angle);\r\n    }\r\n    styleBuf[1] = left;\r\n    styleBuf[3] = top;\r\n    styleBuf[5] = fontHeight;\r\n    styleBuf[7] = style.fontFamily;\r\n    textDivProperties.style = styleBuf.join('');\r\n    textDiv.setAttribute('style', textDivProperties.style);\r\n    textDiv.textContent = geom.str;\r\n    if (task._fontInspectorEnabled) {\r\n      textDiv.dataset.fontName = geom.fontName;\r\n    }\r\n    if (angle !== 0) {\r\n      textDivProperties.angle = angle * (180 / Math.PI);\r\n    }\r\n    if (geom.str.length > 1) {\r\n      if (style.vertical) {\r\n        textDivProperties.canvasWidth = geom.height * task._viewport.scale;\r\n      } else {\r\n        textDivProperties.canvasWidth = geom.width * task._viewport.scale;\r\n      }\r\n    }\r\n    task._textDivProperties.set(textDiv, textDivProperties);\r\n    if (task._textContentStream) {\r\n      task._layoutText(textDiv);\r\n    }\r\n    if (task._enhanceTextSelection) {\r\n      var angleCos = 1,\r\n          angleSin = 0;\r\n      if (angle !== 0) {\r\n        angleCos = Math.cos(angle);\r\n        angleSin = Math.sin(angle);\r\n      }\r\n      var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\r\n      var divHeight = fontHeight;\r\n      var m, b;\r\n      if (angle !== 0) {\r\n        m = [angleCos, angleSin, -angleSin, angleCos, left, top];\r\n        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\r\n      } else {\r\n        b = [left, top, left + divWidth, top + divHeight];\r\n      }\r\n      task._bounds.push({\r\n        left: b[0],\r\n        top: b[1],\r\n        right: b[2],\r\n        bottom: b[3],\r\n        div: textDiv,\r\n        size: [divWidth, divHeight],\r\n        m: m\r\n      });\r\n    }\r\n  }\r\n  function render(task) {\r\n    if (task._canceled) {\r\n      return;\r\n    }\r\n    var textDivs = task._textDivs;\r\n    var capability = task._capability;\r\n    var textDivsLength = textDivs.length;\r\n    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\r\n      task._renderingDone = true;\r\n      capability.resolve();\r\n      return;\r\n    }\r\n    if (!task._textContentStream) {\r\n      for (var i = 0; i < textDivsLength; i++) {\r\n        task._layoutText(textDivs[i]);\r\n      }\r\n    }\r\n    task._renderingDone = true;\r\n    capability.resolve();\r\n  }\r\n  function expand(task) {\r\n    var bounds = task._bounds;\r\n    var viewport = task._viewport;\r\n    var expanded = expandBounds(viewport.width, viewport.height, bounds);\r\n    for (var i = 0; i < expanded.length; i++) {\r\n      var div = bounds[i].div;\r\n      var divProperties = task._textDivProperties.get(div);\r\n      if (divProperties.angle === 0) {\r\n        divProperties.paddingLeft = bounds[i].left - expanded[i].left;\r\n        divProperties.paddingTop = bounds[i].top - expanded[i].top;\r\n        divProperties.paddingRight = expanded[i].right - bounds[i].right;\r\n        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\r\n        task._textDivProperties.set(div, divProperties);\r\n        continue;\r\n      }\r\n      var e = expanded[i],\r\n          b = bounds[i];\r\n      var m = b.m,\r\n          c = m[0],\r\n          s = m[1];\r\n      var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\r\n      var ts = new Float64Array(64);\r\n      points.forEach(function (p, i) {\r\n        var t = _util.Util.applyTransform(p, m);\r\n        ts[i + 0] = c && (e.left - t[0]) / c;\r\n        ts[i + 4] = s && (e.top - t[1]) / s;\r\n        ts[i + 8] = c && (e.right - t[0]) / c;\r\n        ts[i + 12] = s && (e.bottom - t[1]) / s;\r\n        ts[i + 16] = s && (e.left - t[0]) / -s;\r\n        ts[i + 20] = c && (e.top - t[1]) / c;\r\n        ts[i + 24] = s && (e.right - t[0]) / -s;\r\n        ts[i + 28] = c && (e.bottom - t[1]) / c;\r\n        ts[i + 32] = c && (e.left - t[0]) / -c;\r\n        ts[i + 36] = s && (e.top - t[1]) / -s;\r\n        ts[i + 40] = c && (e.right - t[0]) / -c;\r\n        ts[i + 44] = s && (e.bottom - t[1]) / -s;\r\n        ts[i + 48] = s && (e.left - t[0]) / s;\r\n        ts[i + 52] = c && (e.top - t[1]) / -c;\r\n        ts[i + 56] = s && (e.right - t[0]) / s;\r\n        ts[i + 60] = c && (e.bottom - t[1]) / -c;\r\n      });\r\n      var findPositiveMin = function findPositiveMin(ts, offset, count) {\r\n        var result = 0;\r\n        for (var i = 0; i < count; i++) {\r\n          var t = ts[offset++];\r\n          if (t > 0) {\r\n            result = result ? Math.min(t, result) : t;\r\n          }\r\n        }\r\n        return result;\r\n      };\r\n      var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\r\n      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\r\n      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\r\n      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\r\n      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\r\n      task._textDivProperties.set(div, divProperties);\r\n    }\r\n  }\r\n  function expandBounds(width, height, boxes) {\r\n    var bounds = boxes.map(function (box, i) {\r\n      return {\r\n        x1: box.left,\r\n        y1: box.top,\r\n        x2: box.right,\r\n        y2: box.bottom,\r\n        index: i,\r\n        x1New: undefined,\r\n        x2New: undefined\r\n      };\r\n    });\r\n    expandBoundsLTR(width, bounds);\r\n    var expanded = new Array(boxes.length);\r\n    bounds.forEach(function (b) {\r\n      var i = b.index;\r\n      expanded[i] = {\r\n        left: b.x1New,\r\n        top: 0,\r\n        right: b.x2New,\r\n        bottom: 0\r\n      };\r\n    });\r\n    boxes.map(function (box, i) {\r\n      var e = expanded[i],\r\n          b = bounds[i];\r\n      b.x1 = box.top;\r\n      b.y1 = width - e.right;\r\n      b.x2 = box.bottom;\r\n      b.y2 = width - e.left;\r\n      b.index = i;\r\n      b.x1New = undefined;\r\n      b.x2New = undefined;\r\n    });\r\n    expandBoundsLTR(height, bounds);\r\n    bounds.forEach(function (b) {\r\n      var i = b.index;\r\n      expanded[i].top = b.x1New;\r\n      expanded[i].bottom = b.x2New;\r\n    });\r\n    return expanded;\r\n  }\r\n  function expandBoundsLTR(width, bounds) {\r\n    bounds.sort(function (a, b) {\r\n      return a.x1 - b.x1 || a.index - b.index;\r\n    });\r\n    var fakeBoundary = {\r\n      x1: -Infinity,\r\n      y1: -Infinity,\r\n      x2: 0,\r\n      y2: Infinity,\r\n      index: -1,\r\n      x1New: 0,\r\n      x2New: 0\r\n    };\r\n    var horizon = [{\r\n      start: -Infinity,\r\n      end: Infinity,\r\n      boundary: fakeBoundary\r\n    }];\r\n    bounds.forEach(function (boundary) {\r\n      var i = 0;\r\n      while (i < horizon.length && horizon[i].end <= boundary.y1) {\r\n        i++;\r\n      }\r\n      var j = horizon.length - 1;\r\n      while (j >= 0 && horizon[j].start >= boundary.y2) {\r\n        j--;\r\n      }\r\n      var horizonPart, affectedBoundary;\r\n      var q,\r\n          k,\r\n          maxXNew = -Infinity;\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n        var xNew;\r\n        if (affectedBoundary.x2 > boundary.x1) {\r\n          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\r\n        } else if (affectedBoundary.x2New === undefined) {\r\n          xNew = (affectedBoundary.x2 + boundary.x1) / 2;\r\n        } else {\r\n          xNew = affectedBoundary.x2New;\r\n        }\r\n        if (xNew > maxXNew) {\r\n          maxXNew = xNew;\r\n        }\r\n      }\r\n      boundary.x1New = maxXNew;\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n        if (affectedBoundary.x2New === undefined) {\r\n          if (affectedBoundary.x2 > boundary.x1) {\r\n            if (affectedBoundary.index > boundary.index) {\r\n              affectedBoundary.x2New = affectedBoundary.x2;\r\n            }\r\n          } else {\r\n            affectedBoundary.x2New = maxXNew;\r\n          }\r\n        } else if (affectedBoundary.x2New > maxXNew) {\r\n          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\r\n        }\r\n      }\r\n      var changedHorizon = [],\r\n          lastBoundary = null;\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n        var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\r\n        if (lastBoundary === useBoundary) {\r\n          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\r\n        } else {\r\n          changedHorizon.push({\r\n            start: horizonPart.start,\r\n            end: horizonPart.end,\r\n            boundary: useBoundary\r\n          });\r\n          lastBoundary = useBoundary;\r\n        }\r\n      }\r\n      if (horizon[i].start < boundary.y1) {\r\n        changedHorizon[0].start = boundary.y1;\r\n        changedHorizon.unshift({\r\n          start: horizon[i].start,\r\n          end: boundary.y1,\r\n          boundary: horizon[i].boundary\r\n        });\r\n      }\r\n      if (boundary.y2 < horizon[j].end) {\r\n        changedHorizon[changedHorizon.length - 1].end = boundary.y2;\r\n        changedHorizon.push({\r\n          start: boundary.y2,\r\n          end: horizon[j].end,\r\n          boundary: horizon[j].boundary\r\n        });\r\n      }\r\n      for (q = i; q <= j; q++) {\r\n        horizonPart = horizon[q];\r\n        affectedBoundary = horizonPart.boundary;\r\n        if (affectedBoundary.x2New !== undefined) {\r\n          continue;\r\n        }\r\n        var used = false;\r\n        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\r\n          used = horizon[k].boundary === affectedBoundary;\r\n        }\r\n        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\r\n          used = horizon[k].boundary === affectedBoundary;\r\n        }\r\n        for (k = 0; !used && k < changedHorizon.length; k++) {\r\n          used = changedHorizon[k].boundary === affectedBoundary;\r\n        }\r\n        if (!used) {\r\n          affectedBoundary.x2New = maxXNew;\r\n        }\r\n      }\r\n      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\r\n    });\r\n    horizon.forEach(function (horizonPart) {\r\n      var affectedBoundary = horizonPart.boundary;\r\n      if (affectedBoundary.x2New === undefined) {\r\n        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\r\n      }\r\n    });\r\n  }\r\n  function TextLayerRenderTask(_ref) {\r\n    var textContent = _ref.textContent,\r\n        textContentStream = _ref.textContentStream,\r\n        container = _ref.container,\r\n        viewport = _ref.viewport,\r\n        textDivs = _ref.textDivs,\r\n        textContentItemsStr = _ref.textContentItemsStr,\r\n        enhanceTextSelection = _ref.enhanceTextSelection;\r\n\r\n    this._textContent = textContent;\r\n    this._textContentStream = textContentStream;\r\n    this._container = container;\r\n    this._viewport = viewport;\r\n    this._textDivs = textDivs || [];\r\n    this._textContentItemsStr = textContentItemsStr || [];\r\n    this._enhanceTextSelection = !!enhanceTextSelection;\r\n    this._fontInspectorEnabled = !!(_global_scope2.default.FontInspector && _global_scope2.default.FontInspector.enabled);\r\n    this._reader = null;\r\n    this._layoutTextLastFontSize = null;\r\n    this._layoutTextLastFontFamily = null;\r\n    this._layoutTextCtx = null;\r\n    this._textDivProperties = new WeakMap();\r\n    this._renderingDone = false;\r\n    this._canceled = false;\r\n    this._capability = (0, _util.createPromiseCapability)();\r\n    this._renderTimer = null;\r\n    this._bounds = [];\r\n  }\r\n  TextLayerRenderTask.prototype = {\r\n    get promise() {\r\n      return this._capability.promise;\r\n    },\r\n    cancel: function TextLayer_cancel() {\r\n      if (this._reader) {\r\n        this._reader.cancel(new _util.AbortException('text layer task cancelled'));\r\n        this._reader = null;\r\n      }\r\n      this._canceled = true;\r\n      if (this._renderTimer !== null) {\r\n        clearTimeout(this._renderTimer);\r\n        this._renderTimer = null;\r\n      }\r\n      this._capability.reject('canceled');\r\n    },\r\n    _processItems: function _processItems(items, styleCache) {\r\n      for (var i = 0, len = items.length; i < len; i++) {\r\n        this._textContentItemsStr.push(items[i].str);\r\n        appendText(this, items[i], styleCache);\r\n      }\r\n    },\r\n    _layoutText: function _layoutText(textDiv) {\r\n      var textLayerFrag = this._container;\r\n      var textDivProperties = this._textDivProperties.get(textDiv);\r\n      if (textDivProperties.isWhitespace) {\r\n        return;\r\n      }\r\n      var fontSize = textDiv.style.fontSize;\r\n      var fontFamily = textDiv.style.fontFamily;\r\n      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\r\n        this._layoutTextCtx.font = fontSize + ' ' + fontFamily;\r\n        this._lastFontSize = fontSize;\r\n        this._lastFontFamily = fontFamily;\r\n      }\r\n      var width = this._layoutTextCtx.measureText(textDiv.textContent).width;\r\n      var transform = '';\r\n      if (textDivProperties.canvasWidth !== 0 && width > 0) {\r\n        textDivProperties.scale = textDivProperties.canvasWidth / width;\r\n        transform = 'scaleX(' + textDivProperties.scale + ')';\r\n      }\r\n      if (textDivProperties.angle !== 0) {\r\n        transform = 'rotate(' + textDivProperties.angle + 'deg) ' + transform;\r\n      }\r\n      if (transform !== '') {\r\n        textDivProperties.originalTransform = transform;\r\n        textDiv.style.transform = transform;\r\n      }\r\n      this._textDivProperties.set(textDiv, textDivProperties);\r\n      textLayerFrag.appendChild(textDiv);\r\n    },\r\n\r\n    _render: function TextLayer_render(timeout) {\r\n      var _this = this;\r\n\r\n      var capability = (0, _util.createPromiseCapability)();\r\n      var styleCache = Object.create(null);\r\n      var canvas = document.createElement('canvas');\r\n      canvas.mozOpaque = true;\r\n      this._layoutTextCtx = canvas.getContext('2d', { alpha: false });\r\n      if (this._textContent) {\r\n        var textItems = this._textContent.items;\r\n        var textStyles = this._textContent.styles;\r\n        this._processItems(textItems, textStyles);\r\n        capability.resolve();\r\n      } else if (this._textContentStream) {\r\n        var pump = function pump() {\r\n          _this._reader.read().then(function (_ref2) {\r\n            var value = _ref2.value,\r\n                done = _ref2.done;\r\n\r\n            if (done) {\r\n              capability.resolve();\r\n              return;\r\n            }\r\n            _util.Util.extendObj(styleCache, value.styles);\r\n            _this._processItems(value.items, styleCache);\r\n            pump();\r\n          }, capability.reject);\r\n        };\r\n        this._reader = this._textContentStream.getReader();\r\n        pump();\r\n      } else {\r\n        throw new Error('Neither \"textContent\" nor \"textContentStream\"' + ' parameters specified.');\r\n      }\r\n      capability.promise.then(function () {\r\n        styleCache = null;\r\n        if (!timeout) {\r\n          render(_this);\r\n        } else {\r\n          _this._renderTimer = setTimeout(function () {\r\n            render(_this);\r\n            _this._renderTimer = null;\r\n          }, timeout);\r\n        }\r\n      }, this._capability.reject);\r\n    },\r\n    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {\r\n      if (!this._enhanceTextSelection || !this._renderingDone) {\r\n        return;\r\n      }\r\n      if (this._bounds !== null) {\r\n        expand(this);\r\n        this._bounds = null;\r\n      }\r\n      for (var i = 0, ii = this._textDivs.length; i < ii; i++) {\r\n        var div = this._textDivs[i];\r\n        var divProperties = this._textDivProperties.get(div);\r\n        if (divProperties.isWhitespace) {\r\n          continue;\r\n        }\r\n        if (expandDivs) {\r\n          var transform = '',\r\n              padding = '';\r\n          if (divProperties.scale !== 1) {\r\n            transform = 'scaleX(' + divProperties.scale + ')';\r\n          }\r\n          if (divProperties.angle !== 0) {\r\n            transform = 'rotate(' + divProperties.angle + 'deg) ' + transform;\r\n          }\r\n          if (divProperties.paddingLeft !== 0) {\r\n            padding += ' padding-left: ' + divProperties.paddingLeft / divProperties.scale + 'px;';\r\n            transform += ' translateX(' + -divProperties.paddingLeft / divProperties.scale + 'px)';\r\n          }\r\n          if (divProperties.paddingTop !== 0) {\r\n            padding += ' padding-top: ' + divProperties.paddingTop + 'px;';\r\n            transform += ' translateY(' + -divProperties.paddingTop + 'px)';\r\n          }\r\n          if (divProperties.paddingRight !== 0) {\r\n            padding += ' padding-right: ' + divProperties.paddingRight / divProperties.scale + 'px;';\r\n          }\r\n          if (divProperties.paddingBottom !== 0) {\r\n            padding += ' padding-bottom: ' + divProperties.paddingBottom + 'px;';\r\n          }\r\n          if (padding !== '') {\r\n            div.setAttribute('style', divProperties.style + padding);\r\n          }\r\n          if (transform !== '') {\r\n            div.style.transform = transform;\r\n          }\r\n        } else {\r\n          div.style.padding = 0;\r\n          div.style.transform = divProperties.originalTransform || '';\r\n        }\r\n      }\r\n    }\r\n  };\r\n  function renderTextLayer(renderParameters) {\r\n    var task = new TextLayerRenderTask({\r\n      textContent: renderParameters.textContent,\r\n      textContentStream: renderParameters.textContentStream,\r\n      container: renderParameters.container,\r\n      viewport: renderParameters.viewport,\r\n      textDivs: renderParameters.textDivs,\r\n      textContentItemsStr: renderParameters.textContentItemsStr,\r\n      enhanceTextSelection: renderParameters.enhanceTextSelection\r\n    });\r\n    task._render(renderParameters.timeout);\r\n    return task;\r\n  }\r\n  return renderTextLayer;\r\n}();\r\nexports.renderTextLayer = renderTextLayer;\r\n\r\n/***/ }),\r\n/* 126 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.AnnotationLayer = undefined;\r\n\r\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _dom_utils = __w_pdfjs_require__(24);\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar AnnotationElementFactory = function () {\r\n  function AnnotationElementFactory() {\r\n    _classCallCheck(this, AnnotationElementFactory);\r\n  }\r\n\r\n  _createClass(AnnotationElementFactory, null, [{\r\n    key: 'create',\r\n    value: function create(parameters) {\r\n      var subtype = parameters.data.annotationType;\r\n      switch (subtype) {\r\n        case _util.AnnotationType.LINK:\r\n          return new LinkAnnotationElement(parameters);\r\n        case _util.AnnotationType.TEXT:\r\n          return new TextAnnotationElement(parameters);\r\n        case _util.AnnotationType.WIDGET:\r\n          var fieldType = parameters.data.fieldType;\r\n          switch (fieldType) {\r\n            case 'Tx':\r\n              return new TextWidgetAnnotationElement(parameters);\r\n            case 'Btn':\r\n              if (parameters.data.radioButton) {\r\n                return new RadioButtonWidgetAnnotationElement(parameters);\r\n              } else if (parameters.data.checkBox) {\r\n                return new CheckboxWidgetAnnotationElement(parameters);\r\n              }\r\n              return new PushButtonWidgetAnnotationElement(parameters);\r\n            case 'Ch':\r\n              return new ChoiceWidgetAnnotationElement(parameters);\r\n          }\r\n          return new WidgetAnnotationElement(parameters);\r\n        case _util.AnnotationType.POPUP:\r\n          return new PopupAnnotationElement(parameters);\r\n        case _util.AnnotationType.LINE:\r\n          return new LineAnnotationElement(parameters);\r\n        case _util.AnnotationType.SQUARE:\r\n          return new SquareAnnotationElement(parameters);\r\n        case _util.AnnotationType.CIRCLE:\r\n          return new CircleAnnotationElement(parameters);\r\n        case _util.AnnotationType.POLYLINE:\r\n          return new PolylineAnnotationElement(parameters);\r\n        case _util.AnnotationType.POLYGON:\r\n          return new PolygonAnnotationElement(parameters);\r\n        case _util.AnnotationType.HIGHLIGHT:\r\n          return new HighlightAnnotationElement(parameters);\r\n        case _util.AnnotationType.UNDERLINE:\r\n          return new UnderlineAnnotationElement(parameters);\r\n        case _util.AnnotationType.SQUIGGLY:\r\n          return new SquigglyAnnotationElement(parameters);\r\n        case _util.AnnotationType.STRIKEOUT:\r\n          return new StrikeOutAnnotationElement(parameters);\r\n        case _util.AnnotationType.STAMP:\r\n          return new StampAnnotationElement(parameters);\r\n        case _util.AnnotationType.FILEATTACHMENT:\r\n          return new FileAttachmentAnnotationElement(parameters);\r\n        default:\r\n          return new AnnotationElement(parameters);\r\n      }\r\n    }\r\n  }]);\r\n\r\n  return AnnotationElementFactory;\r\n}();\r\n\r\nvar AnnotationElement = function () {\r\n  function AnnotationElement(parameters) {\r\n    var isRenderable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n    var ignoreBorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n\r\n    _classCallCheck(this, AnnotationElement);\r\n\r\n    this.isRenderable = isRenderable;\r\n    this.data = parameters.data;\r\n    this.layer = parameters.layer;\r\n    this.page = parameters.page;\r\n    this.viewport = parameters.viewport;\r\n    this.linkService = parameters.linkService;\r\n    this.downloadManager = parameters.downloadManager;\r\n    this.imageResourcesPath = parameters.imageResourcesPath;\r\n    this.renderInteractiveForms = parameters.renderInteractiveForms;\r\n    this.svgFactory = parameters.svgFactory;\r\n    if (isRenderable) {\r\n      this.container = this._createContainer(ignoreBorder);\r\n    }\r\n  }\r\n\r\n  _createClass(AnnotationElement, [{\r\n    key: '_createContainer',\r\n    value: function _createContainer() {\r\n      var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n\r\n      var data = this.data,\r\n          page = this.page,\r\n          viewport = this.viewport;\r\n      var container = document.createElement('section');\r\n      var width = data.rect[2] - data.rect[0];\r\n      var height = data.rect[3] - data.rect[1];\r\n      container.setAttribute('data-annotation-id', data.id);\r\n      var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\r\n      container.style.transform = 'matrix(' + viewport.transform.join(',') + ')';\r\n      container.style.transformOrigin = -rect[0] + 'px ' + -rect[1] + 'px';\r\n      if (!ignoreBorder && data.borderStyle.width > 0) {\r\n        container.style.borderWidth = data.borderStyle.width + 'px';\r\n        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\r\n          width = width - 2 * data.borderStyle.width;\r\n          height = height - 2 * data.borderStyle.width;\r\n        }\r\n        var horizontalRadius = data.borderStyle.horizontalCornerRadius;\r\n        var verticalRadius = data.borderStyle.verticalCornerRadius;\r\n        if (horizontalRadius > 0 || verticalRadius > 0) {\r\n          var radius = horizontalRadius + 'px / ' + verticalRadius + 'px';\r\n          container.style.borderRadius = radius;\r\n        }\r\n        switch (data.borderStyle.style) {\r\n          case _util.AnnotationBorderStyleType.SOLID:\r\n            container.style.borderStyle = 'solid';\r\n            break;\r\n          case _util.AnnotationBorderStyleType.DASHED:\r\n            container.style.borderStyle = 'dashed';\r\n            break;\r\n          case _util.AnnotationBorderStyleType.BEVELED:\r\n            (0, _util.warn)('Unimplemented border style: beveled');\r\n            break;\r\n          case _util.AnnotationBorderStyleType.INSET:\r\n            (0, _util.warn)('Unimplemented border style: inset');\r\n            break;\r\n          case _util.AnnotationBorderStyleType.UNDERLINE:\r\n            container.style.borderBottomStyle = 'solid';\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n        if (data.color) {\r\n          container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\r\n        } else {\r\n          container.style.borderWidth = 0;\r\n        }\r\n      }\r\n      container.style.left = rect[0] + 'px';\r\n      container.style.top = rect[1] + 'px';\r\n      container.style.width = width + 'px';\r\n      container.style.height = height + 'px';\r\n      return container;\r\n    }\r\n  }, {\r\n    key: '_createPopup',\r\n    value: function _createPopup(container, trigger, data) {\r\n      if (!trigger) {\r\n        trigger = document.createElement('div');\r\n        trigger.style.height = container.style.height;\r\n        trigger.style.width = container.style.width;\r\n        container.appendChild(trigger);\r\n      }\r\n      var popupElement = new PopupElement({\r\n        container: container,\r\n        trigger: trigger,\r\n        color: data.color,\r\n        title: data.title,\r\n        contents: data.contents,\r\n        hideWrapper: true\r\n      });\r\n      var popup = popupElement.render();\r\n      popup.style.left = container.style.width;\r\n      container.appendChild(popup);\r\n    }\r\n  }, {\r\n    key: 'render',\r\n    value: function render() {\r\n      (0, _util.unreachable)('Abstract method `AnnotationElement.render` called');\r\n    }\r\n  }]);\r\n\r\n  return AnnotationElement;\r\n}();\r\n\r\nvar LinkAnnotationElement = function (_AnnotationElement) {\r\n  _inherits(LinkAnnotationElement, _AnnotationElement);\r\n\r\n  function LinkAnnotationElement(parameters) {\r\n    _classCallCheck(this, LinkAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);\r\n    return _possibleConstructorReturn(this, (LinkAnnotationElement.__proto__ || Object.getPrototypeOf(LinkAnnotationElement)).call(this, parameters, isRenderable));\r\n  }\r\n\r\n  _createClass(LinkAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'linkAnnotation';\r\n      var data = this.data,\r\n          linkService = this.linkService;\r\n\r\n      var link = document.createElement('a');\r\n      (0, _dom_utils.addLinkAttributes)(link, {\r\n        url: data.url,\r\n        target: data.newWindow ? _dom_utils.LinkTarget.BLANK : linkService.externalLinkTarget,\r\n        rel: linkService.externalLinkRel\r\n      });\r\n      if (!data.url) {\r\n        if (data.action) {\r\n          this._bindNamedAction(link, data.action);\r\n        } else {\r\n          this._bindLink(link, data.dest);\r\n        }\r\n      }\r\n      this.container.appendChild(link);\r\n      return this.container;\r\n    }\r\n  }, {\r\n    key: '_bindLink',\r\n    value: function _bindLink(link, destination) {\r\n      var _this2 = this;\r\n\r\n      link.href = this.linkService.getDestinationHash(destination);\r\n      link.onclick = function () {\r\n        if (destination) {\r\n          _this2.linkService.navigateTo(destination);\r\n        }\r\n        return false;\r\n      };\r\n      if (destination) {\r\n        link.className = 'internalLink';\r\n      }\r\n    }\r\n  }, {\r\n    key: '_bindNamedAction',\r\n    value: function _bindNamedAction(link, action) {\r\n      var _this3 = this;\r\n\r\n      link.href = this.linkService.getAnchorUrl('');\r\n      link.onclick = function () {\r\n        _this3.linkService.executeNamedAction(action);\r\n        return false;\r\n      };\r\n      link.className = 'internalLink';\r\n    }\r\n  }]);\r\n\r\n  return LinkAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar TextAnnotationElement = function (_AnnotationElement2) {\r\n  _inherits(TextAnnotationElement, _AnnotationElement2);\r\n\r\n  function TextAnnotationElement(parameters) {\r\n    _classCallCheck(this, TextAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (TextAnnotationElement.__proto__ || Object.getPrototypeOf(TextAnnotationElement)).call(this, parameters, isRenderable));\r\n  }\r\n\r\n  _createClass(TextAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'textAnnotation';\r\n      var image = document.createElement('img');\r\n      image.style.height = this.container.style.height;\r\n      image.style.width = this.container.style.width;\r\n      image.src = this.imageResourcesPath + 'annotation-' + this.data.name.toLowerCase() + '.svg';\r\n      image.alt = '[{{type}} Annotation]';\r\n      image.dataset.l10nId = 'text_annotation_type';\r\n      image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });\r\n      if (!this.data.hasPopup) {\r\n        this._createPopup(this.container, image, this.data);\r\n      }\r\n      this.container.appendChild(image);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return TextAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar WidgetAnnotationElement = function (_AnnotationElement3) {\r\n  _inherits(WidgetAnnotationElement, _AnnotationElement3);\r\n\r\n  function WidgetAnnotationElement() {\r\n    _classCallCheck(this, WidgetAnnotationElement);\r\n\r\n    return _possibleConstructorReturn(this, (WidgetAnnotationElement.__proto__ || Object.getPrototypeOf(WidgetAnnotationElement)).apply(this, arguments));\r\n  }\r\n\r\n  _createClass(WidgetAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return WidgetAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar TextWidgetAnnotationElement = function (_WidgetAnnotationElem) {\r\n  _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);\r\n\r\n  function TextWidgetAnnotationElement(parameters) {\r\n    _classCallCheck(this, TextWidgetAnnotationElement);\r\n\r\n    var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\r\n    return _possibleConstructorReturn(this, (TextWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(TextWidgetAnnotationElement)).call(this, parameters, isRenderable));\r\n  }\r\n\r\n  _createClass(TextWidgetAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      var TEXT_ALIGNMENT = ['left', 'center', 'right'];\r\n      this.container.className = 'textWidgetAnnotation';\r\n      var element = null;\r\n      if (this.renderInteractiveForms) {\r\n        if (this.data.multiLine) {\r\n          element = document.createElement('textarea');\r\n          element.textContent = this.data.fieldValue;\r\n        } else {\r\n          element = document.createElement('input');\r\n          element.type = 'text';\r\n          element.setAttribute('value', this.data.fieldValue);\r\n        }\r\n        element.disabled = this.data.readOnly;\r\n        if (this.data.maxLen !== null) {\r\n          element.maxLength = this.data.maxLen;\r\n        }\r\n        if (this.data.comb) {\r\n          var fieldWidth = this.data.rect[2] - this.data.rect[0];\r\n          var combWidth = fieldWidth / this.data.maxLen;\r\n          element.classList.add('comb');\r\n          element.style.letterSpacing = 'calc(' + combWidth + 'px - 1ch)';\r\n        }\r\n      } else {\r\n        element = document.createElement('div');\r\n        element.textContent = this.data.fieldValue;\r\n        element.style.verticalAlign = 'middle';\r\n        element.style.display = 'table-cell';\r\n        var font = null;\r\n        if (this.data.fontRefName) {\r\n          font = this.page.commonObjs.getData(this.data.fontRefName);\r\n        }\r\n        this._setTextStyle(element, font);\r\n      }\r\n      if (this.data.textAlignment !== null) {\r\n        element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\r\n      }\r\n      this.container.appendChild(element);\r\n      return this.container;\r\n    }\r\n  }, {\r\n    key: '_setTextStyle',\r\n    value: function _setTextStyle(element, font) {\r\n      var style = element.style;\r\n      style.fontSize = this.data.fontSize + 'px';\r\n      style.direction = this.data.fontDirection < 0 ? 'rtl' : 'ltr';\r\n      if (!font) {\r\n        return;\r\n      }\r\n      style.fontWeight = font.black ? font.bold ? '900' : 'bold' : font.bold ? 'bold' : 'normal';\r\n      style.fontStyle = font.italic ? 'italic' : 'normal';\r\n      var fontFamily = font.loadedName ? '\"' + font.loadedName + '\", ' : '';\r\n      var fallbackName = font.fallbackName || 'Helvetica, sans-serif';\r\n      style.fontFamily = fontFamily + fallbackName;\r\n    }\r\n  }]);\r\n\r\n  return TextWidgetAnnotationElement;\r\n}(WidgetAnnotationElement);\r\n\r\nvar CheckboxWidgetAnnotationElement = function (_WidgetAnnotationElem2) {\r\n  _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);\r\n\r\n  function CheckboxWidgetAnnotationElement(parameters) {\r\n    _classCallCheck(this, CheckboxWidgetAnnotationElement);\r\n\r\n    return _possibleConstructorReturn(this, (CheckboxWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(CheckboxWidgetAnnotationElement)).call(this, parameters, parameters.renderInteractiveForms));\r\n  }\r\n\r\n  _createClass(CheckboxWidgetAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'buttonWidgetAnnotation checkBox';\r\n      var element = document.createElement('input');\r\n      element.disabled = this.data.readOnly;\r\n      element.type = 'checkbox';\r\n      if (this.data.fieldValue && this.data.fieldValue !== 'Off') {\r\n        element.setAttribute('checked', true);\r\n      }\r\n      this.container.appendChild(element);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return CheckboxWidgetAnnotationElement;\r\n}(WidgetAnnotationElement);\r\n\r\nvar RadioButtonWidgetAnnotationElement = function (_WidgetAnnotationElem3) {\r\n  _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);\r\n\r\n  function RadioButtonWidgetAnnotationElement(parameters) {\r\n    _classCallCheck(this, RadioButtonWidgetAnnotationElement);\r\n\r\n    return _possibleConstructorReturn(this, (RadioButtonWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(RadioButtonWidgetAnnotationElement)).call(this, parameters, parameters.renderInteractiveForms));\r\n  }\r\n\r\n  _createClass(RadioButtonWidgetAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'buttonWidgetAnnotation radioButton';\r\n      var element = document.createElement('input');\r\n      element.disabled = this.data.readOnly;\r\n      element.type = 'radio';\r\n      element.name = this.data.fieldName;\r\n      if (this.data.fieldValue === this.data.buttonValue) {\r\n        element.setAttribute('checked', true);\r\n      }\r\n      this.container.appendChild(element);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return RadioButtonWidgetAnnotationElement;\r\n}(WidgetAnnotationElement);\r\n\r\nvar PushButtonWidgetAnnotationElement = function (_LinkAnnotationElemen) {\r\n  _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);\r\n\r\n  function PushButtonWidgetAnnotationElement() {\r\n    _classCallCheck(this, PushButtonWidgetAnnotationElement);\r\n\r\n    return _possibleConstructorReturn(this, (PushButtonWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(PushButtonWidgetAnnotationElement)).apply(this, arguments));\r\n  }\r\n\r\n  _createClass(PushButtonWidgetAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      var container = _get(PushButtonWidgetAnnotationElement.prototype.__proto__ || Object.getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), 'render', this).call(this);\r\n      container.className = 'buttonWidgetAnnotation pushButton';\r\n      return container;\r\n    }\r\n  }]);\r\n\r\n  return PushButtonWidgetAnnotationElement;\r\n}(LinkAnnotationElement);\r\n\r\nvar ChoiceWidgetAnnotationElement = function (_WidgetAnnotationElem4) {\r\n  _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);\r\n\r\n  function ChoiceWidgetAnnotationElement(parameters) {\r\n    _classCallCheck(this, ChoiceWidgetAnnotationElement);\r\n\r\n    return _possibleConstructorReturn(this, (ChoiceWidgetAnnotationElement.__proto__ || Object.getPrototypeOf(ChoiceWidgetAnnotationElement)).call(this, parameters, parameters.renderInteractiveForms));\r\n  }\r\n\r\n  _createClass(ChoiceWidgetAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'choiceWidgetAnnotation';\r\n      var selectElement = document.createElement('select');\r\n      selectElement.disabled = this.data.readOnly;\r\n      if (!this.data.combo) {\r\n        selectElement.size = this.data.options.length;\r\n        if (this.data.multiSelect) {\r\n          selectElement.multiple = true;\r\n        }\r\n      }\r\n      for (var i = 0, ii = this.data.options.length; i < ii; i++) {\r\n        var option = this.data.options[i];\r\n        var optionElement = document.createElement('option');\r\n        optionElement.textContent = option.displayValue;\r\n        optionElement.value = option.exportValue;\r\n        if (this.data.fieldValue.includes(option.displayValue)) {\r\n          optionElement.setAttribute('selected', true);\r\n        }\r\n        selectElement.appendChild(optionElement);\r\n      }\r\n      this.container.appendChild(selectElement);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return ChoiceWidgetAnnotationElement;\r\n}(WidgetAnnotationElement);\r\n\r\nvar PopupAnnotationElement = function (_AnnotationElement4) {\r\n  _inherits(PopupAnnotationElement, _AnnotationElement4);\r\n\r\n  function PopupAnnotationElement(parameters) {\r\n    _classCallCheck(this, PopupAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (PopupAnnotationElement.__proto__ || Object.getPrototypeOf(PopupAnnotationElement)).call(this, parameters, isRenderable));\r\n  }\r\n\r\n  _createClass(PopupAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      var IGNORE_TYPES = ['Line', 'Square', 'Circle', 'PolyLine', 'Polygon'];\r\n      this.container.className = 'popupAnnotation';\r\n      if (IGNORE_TYPES.includes(this.data.parentType)) {\r\n        return this.container;\r\n      }\r\n      var selector = '[data-annotation-id=\"' + this.data.parentId + '\"]';\r\n      var parentElement = this.layer.querySelector(selector);\r\n      if (!parentElement) {\r\n        return this.container;\r\n      }\r\n      var popup = new PopupElement({\r\n        container: this.container,\r\n        trigger: parentElement,\r\n        color: this.data.color,\r\n        title: this.data.title,\r\n        contents: this.data.contents\r\n      });\r\n      var parentLeft = parseFloat(parentElement.style.left);\r\n      var parentWidth = parseFloat(parentElement.style.width);\r\n      this.container.style.transformOrigin = -(parentLeft + parentWidth) + 'px -' + parentElement.style.top;\r\n      this.container.style.left = parentLeft + parentWidth + 'px';\r\n      this.container.appendChild(popup.render());\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return PopupAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar PopupElement = function () {\r\n  function PopupElement(parameters) {\r\n    _classCallCheck(this, PopupElement);\r\n\r\n    this.container = parameters.container;\r\n    this.trigger = parameters.trigger;\r\n    this.color = parameters.color;\r\n    this.title = parameters.title;\r\n    this.contents = parameters.contents;\r\n    this.hideWrapper = parameters.hideWrapper || false;\r\n    this.pinned = false;\r\n  }\r\n\r\n  _createClass(PopupElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      var BACKGROUND_ENLIGHT = 0.7;\r\n      var wrapper = document.createElement('div');\r\n      wrapper.className = 'popupWrapper';\r\n      this.hideElement = this.hideWrapper ? wrapper : this.container;\r\n      this.hideElement.setAttribute('hidden', true);\r\n      var popup = document.createElement('div');\r\n      popup.className = 'popup';\r\n      var color = this.color;\r\n      if (color) {\r\n        var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\r\n        var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\r\n        var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\r\n        popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);\r\n      }\r\n      var contents = this._formatContents(this.contents);\r\n      var title = document.createElement('h1');\r\n      title.textContent = this.title;\r\n      this.trigger.addEventListener('click', this._toggle.bind(this));\r\n      this.trigger.addEventListener('mouseover', this._show.bind(this, false));\r\n      this.trigger.addEventListener('mouseout', this._hide.bind(this, false));\r\n      popup.addEventListener('click', this._hide.bind(this, true));\r\n      popup.appendChild(title);\r\n      popup.appendChild(contents);\r\n      wrapper.appendChild(popup);\r\n      return wrapper;\r\n    }\r\n  }, {\r\n    key: '_formatContents',\r\n    value: function _formatContents(contents) {\r\n      var p = document.createElement('p');\r\n      var lines = contents.split(/(?:\\r\\n?|\\n)/);\r\n      for (var i = 0, ii = lines.length; i < ii; ++i) {\r\n        var line = lines[i];\r\n        p.appendChild(document.createTextNode(line));\r\n        if (i < ii - 1) {\r\n          p.appendChild(document.createElement('br'));\r\n        }\r\n      }\r\n      return p;\r\n    }\r\n  }, {\r\n    key: '_toggle',\r\n    value: function _toggle() {\r\n      if (this.pinned) {\r\n        this._hide(true);\r\n      } else {\r\n        this._show(true);\r\n      }\r\n    }\r\n  }, {\r\n    key: '_show',\r\n    value: function _show() {\r\n      var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n\r\n      if (pin) {\r\n        this.pinned = true;\r\n      }\r\n      if (this.hideElement.hasAttribute('hidden')) {\r\n        this.hideElement.removeAttribute('hidden');\r\n        this.container.style.zIndex += 1;\r\n      }\r\n    }\r\n  }, {\r\n    key: '_hide',\r\n    value: function _hide() {\r\n      var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n\r\n      if (unpin) {\r\n        this.pinned = false;\r\n      }\r\n      if (!this.hideElement.hasAttribute('hidden') && !this.pinned) {\r\n        this.hideElement.setAttribute('hidden', true);\r\n        this.container.style.zIndex -= 1;\r\n      }\r\n    }\r\n  }]);\r\n\r\n  return PopupElement;\r\n}();\r\n\r\nvar LineAnnotationElement = function (_AnnotationElement5) {\r\n  _inherits(LineAnnotationElement, _AnnotationElement5);\r\n\r\n  function LineAnnotationElement(parameters) {\r\n    _classCallCheck(this, LineAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (LineAnnotationElement.__proto__ || Object.getPrototypeOf(LineAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(LineAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'lineAnnotation';\r\n      var data = this.data;\r\n      var width = data.rect[2] - data.rect[0];\r\n      var height = data.rect[3] - data.rect[1];\r\n      var svg = this.svgFactory.create(width, height);\r\n      var line = this.svgFactory.createElement('svg:line');\r\n      line.setAttribute('x1', data.rect[2] - data.lineCoordinates[0]);\r\n      line.setAttribute('y1', data.rect[3] - data.lineCoordinates[1]);\r\n      line.setAttribute('x2', data.rect[2] - data.lineCoordinates[2]);\r\n      line.setAttribute('y2', data.rect[3] - data.lineCoordinates[3]);\r\n      line.setAttribute('stroke-width', data.borderStyle.width);\r\n      line.setAttribute('stroke', 'transparent');\r\n      svg.appendChild(line);\r\n      this.container.append(svg);\r\n      this._createPopup(this.container, line, data);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return LineAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar SquareAnnotationElement = function (_AnnotationElement6) {\r\n  _inherits(SquareAnnotationElement, _AnnotationElement6);\r\n\r\n  function SquareAnnotationElement(parameters) {\r\n    _classCallCheck(this, SquareAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (SquareAnnotationElement.__proto__ || Object.getPrototypeOf(SquareAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(SquareAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'squareAnnotation';\r\n      var data = this.data;\r\n      var width = data.rect[2] - data.rect[0];\r\n      var height = data.rect[3] - data.rect[1];\r\n      var svg = this.svgFactory.create(width, height);\r\n      var borderWidth = data.borderStyle.width;\r\n      var square = this.svgFactory.createElement('svg:rect');\r\n      square.setAttribute('x', borderWidth / 2);\r\n      square.setAttribute('y', borderWidth / 2);\r\n      square.setAttribute('width', width - borderWidth);\r\n      square.setAttribute('height', height - borderWidth);\r\n      square.setAttribute('stroke-width', borderWidth);\r\n      square.setAttribute('stroke', 'transparent');\r\n      square.setAttribute('fill', 'none');\r\n      svg.appendChild(square);\r\n      this.container.append(svg);\r\n      this._createPopup(this.container, square, data);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return SquareAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar CircleAnnotationElement = function (_AnnotationElement7) {\r\n  _inherits(CircleAnnotationElement, _AnnotationElement7);\r\n\r\n  function CircleAnnotationElement(parameters) {\r\n    _classCallCheck(this, CircleAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (CircleAnnotationElement.__proto__ || Object.getPrototypeOf(CircleAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(CircleAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'circleAnnotation';\r\n      var data = this.data;\r\n      var width = data.rect[2] - data.rect[0];\r\n      var height = data.rect[3] - data.rect[1];\r\n      var svg = this.svgFactory.create(width, height);\r\n      var borderWidth = data.borderStyle.width;\r\n      var circle = this.svgFactory.createElement('svg:ellipse');\r\n      circle.setAttribute('cx', width / 2);\r\n      circle.setAttribute('cy', height / 2);\r\n      circle.setAttribute('rx', width / 2 - borderWidth / 2);\r\n      circle.setAttribute('ry', height / 2 - borderWidth / 2);\r\n      circle.setAttribute('stroke-width', borderWidth);\r\n      circle.setAttribute('stroke', 'transparent');\r\n      circle.setAttribute('fill', 'none');\r\n      svg.appendChild(circle);\r\n      this.container.append(svg);\r\n      this._createPopup(this.container, circle, data);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return CircleAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar PolylineAnnotationElement = function (_AnnotationElement8) {\r\n  _inherits(PolylineAnnotationElement, _AnnotationElement8);\r\n\r\n  function PolylineAnnotationElement(parameters) {\r\n    _classCallCheck(this, PolylineAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n\r\n    var _this15 = _possibleConstructorReturn(this, (PolylineAnnotationElement.__proto__ || Object.getPrototypeOf(PolylineAnnotationElement)).call(this, parameters, isRenderable, true));\r\n\r\n    _this15.containerClassName = 'polylineAnnotation';\r\n    _this15.svgElementName = 'svg:polyline';\r\n    return _this15;\r\n  }\r\n\r\n  _createClass(PolylineAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = this.containerClassName;\r\n      var data = this.data;\r\n      var width = data.rect[2] - data.rect[0];\r\n      var height = data.rect[3] - data.rect[1];\r\n      var svg = this.svgFactory.create(width, height);\r\n      var vertices = data.vertices;\r\n      var points = [];\r\n      for (var i = 0, ii = vertices.length; i < ii; i++) {\r\n        var x = vertices[i].x - data.rect[0];\r\n        var y = data.rect[3] - vertices[i].y;\r\n        points.push(x + ',' + y);\r\n      }\r\n      points = points.join(' ');\r\n      var borderWidth = data.borderStyle.width;\r\n      var polyline = this.svgFactory.createElement(this.svgElementName);\r\n      polyline.setAttribute('points', points);\r\n      polyline.setAttribute('stroke-width', borderWidth);\r\n      polyline.setAttribute('stroke', 'transparent');\r\n      polyline.setAttribute('fill', 'none');\r\n      svg.appendChild(polyline);\r\n      this.container.append(svg);\r\n      this._createPopup(this.container, polyline, data);\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return PolylineAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar PolygonAnnotationElement = function (_PolylineAnnotationEl) {\r\n  _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);\r\n\r\n  function PolygonAnnotationElement(parameters) {\r\n    _classCallCheck(this, PolygonAnnotationElement);\r\n\r\n    var _this16 = _possibleConstructorReturn(this, (PolygonAnnotationElement.__proto__ || Object.getPrototypeOf(PolygonAnnotationElement)).call(this, parameters));\r\n\r\n    _this16.containerClassName = 'polygonAnnotation';\r\n    _this16.svgElementName = 'svg:polygon';\r\n    return _this16;\r\n  }\r\n\r\n  return PolygonAnnotationElement;\r\n}(PolylineAnnotationElement);\r\n\r\nvar HighlightAnnotationElement = function (_AnnotationElement9) {\r\n  _inherits(HighlightAnnotationElement, _AnnotationElement9);\r\n\r\n  function HighlightAnnotationElement(parameters) {\r\n    _classCallCheck(this, HighlightAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (HighlightAnnotationElement.__proto__ || Object.getPrototypeOf(HighlightAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(HighlightAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'highlightAnnotation';\r\n      if (!this.data.hasPopup) {\r\n        this._createPopup(this.container, null, this.data);\r\n      }\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return HighlightAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar UnderlineAnnotationElement = function (_AnnotationElement10) {\r\n  _inherits(UnderlineAnnotationElement, _AnnotationElement10);\r\n\r\n  function UnderlineAnnotationElement(parameters) {\r\n    _classCallCheck(this, UnderlineAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (UnderlineAnnotationElement.__proto__ || Object.getPrototypeOf(UnderlineAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(UnderlineAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'underlineAnnotation';\r\n      if (!this.data.hasPopup) {\r\n        this._createPopup(this.container, null, this.data);\r\n      }\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return UnderlineAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar SquigglyAnnotationElement = function (_AnnotationElement11) {\r\n  _inherits(SquigglyAnnotationElement, _AnnotationElement11);\r\n\r\n  function SquigglyAnnotationElement(parameters) {\r\n    _classCallCheck(this, SquigglyAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (SquigglyAnnotationElement.__proto__ || Object.getPrototypeOf(SquigglyAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(SquigglyAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'squigglyAnnotation';\r\n      if (!this.data.hasPopup) {\r\n        this._createPopup(this.container, null, this.data);\r\n      }\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return SquigglyAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar StrikeOutAnnotationElement = function (_AnnotationElement12) {\r\n  _inherits(StrikeOutAnnotationElement, _AnnotationElement12);\r\n\r\n  function StrikeOutAnnotationElement(parameters) {\r\n    _classCallCheck(this, StrikeOutAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (StrikeOutAnnotationElement.__proto__ || Object.getPrototypeOf(StrikeOutAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(StrikeOutAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'strikeoutAnnotation';\r\n      if (!this.data.hasPopup) {\r\n        this._createPopup(this.container, null, this.data);\r\n      }\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return StrikeOutAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar StampAnnotationElement = function (_AnnotationElement13) {\r\n  _inherits(StampAnnotationElement, _AnnotationElement13);\r\n\r\n  function StampAnnotationElement(parameters) {\r\n    _classCallCheck(this, StampAnnotationElement);\r\n\r\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\r\n    return _possibleConstructorReturn(this, (StampAnnotationElement.__proto__ || Object.getPrototypeOf(StampAnnotationElement)).call(this, parameters, isRenderable, true));\r\n  }\r\n\r\n  _createClass(StampAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'stampAnnotation';\r\n      if (!this.data.hasPopup) {\r\n        this._createPopup(this.container, null, this.data);\r\n      }\r\n      return this.container;\r\n    }\r\n  }]);\r\n\r\n  return StampAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar FileAttachmentAnnotationElement = function (_AnnotationElement14) {\r\n  _inherits(FileAttachmentAnnotationElement, _AnnotationElement14);\r\n\r\n  function FileAttachmentAnnotationElement(parameters) {\r\n    _classCallCheck(this, FileAttachmentAnnotationElement);\r\n\r\n    var _this22 = _possibleConstructorReturn(this, (FileAttachmentAnnotationElement.__proto__ || Object.getPrototypeOf(FileAttachmentAnnotationElement)).call(this, parameters, true));\r\n\r\n    var file = _this22.data.file;\r\n    _this22.filename = (0, _dom_utils.getFilenameFromUrl)(file.filename);\r\n    _this22.content = file.content;\r\n    _this22.linkService.onFileAttachmentAnnotation({\r\n      id: (0, _util.stringToPDFString)(file.filename),\r\n      filename: file.filename,\r\n      content: file.content\r\n    });\r\n    return _this22;\r\n  }\r\n\r\n  _createClass(FileAttachmentAnnotationElement, [{\r\n    key: 'render',\r\n    value: function render() {\r\n      this.container.className = 'fileAttachmentAnnotation';\r\n      var trigger = document.createElement('div');\r\n      trigger.style.height = this.container.style.height;\r\n      trigger.style.width = this.container.style.width;\r\n      trigger.addEventListener('dblclick', this._download.bind(this));\r\n      if (!this.data.hasPopup && (this.data.title || this.data.contents)) {\r\n        this._createPopup(this.container, trigger, this.data);\r\n      }\r\n      this.container.appendChild(trigger);\r\n      return this.container;\r\n    }\r\n  }, {\r\n    key: '_download',\r\n    value: function _download() {\r\n      if (!this.downloadManager) {\r\n        (0, _util.warn)('Download cannot be started due to unavailable download manager');\r\n        return;\r\n      }\r\n      this.downloadManager.downloadData(this.content, this.filename, '');\r\n    }\r\n  }]);\r\n\r\n  return FileAttachmentAnnotationElement;\r\n}(AnnotationElement);\r\n\r\nvar AnnotationLayer = function () {\r\n  function AnnotationLayer() {\r\n    _classCallCheck(this, AnnotationLayer);\r\n  }\r\n\r\n  _createClass(AnnotationLayer, null, [{\r\n    key: 'render',\r\n    value: function render(parameters) {\r\n      for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {\r\n        var data = parameters.annotations[i];\r\n        if (!data) {\r\n          continue;\r\n        }\r\n        var element = AnnotationElementFactory.create({\r\n          data: data,\r\n          layer: parameters.div,\r\n          page: parameters.page,\r\n          viewport: parameters.viewport,\r\n          linkService: parameters.linkService,\r\n          downloadManager: parameters.downloadManager,\r\n          imageResourcesPath: parameters.imageResourcesPath || '',\r\n          renderInteractiveForms: parameters.renderInteractiveForms || false,\r\n          svgFactory: new _dom_utils.DOMSVGFactory()\r\n        });\r\n        if (element.isRenderable) {\r\n          parameters.div.appendChild(element.render());\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: 'update',\r\n    value: function update(parameters) {\r\n      for (var i = 0, ii = parameters.annotations.length; i < ii; i++) {\r\n        var data = parameters.annotations[i];\r\n        var element = parameters.div.querySelector('[data-annotation-id=\"' + data.id + '\"]');\r\n        if (element) {\r\n          element.style.transform = 'matrix(' + parameters.viewport.transform.join(',') + ')';\r\n        }\r\n      }\r\n      parameters.div.removeAttribute('hidden');\r\n    }\r\n  }]);\r\n\r\n  return AnnotationLayer;\r\n}();\r\n\r\nexports.AnnotationLayer = AnnotationLayer;\r\n\r\n/***/ }),\r\n/* 127 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.SVGGraphics = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _dom_utils = __w_pdfjs_require__(24);\r\n\r\nvar _is_node = __w_pdfjs_require__(25);\r\n\r\nvar _is_node2 = _interopRequireDefault(_is_node);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar SVGGraphics = function SVGGraphics() {\r\n  throw new Error('Not implemented: SVGGraphics');\r\n};\r\n{\r\n  var SVG_DEFAULTS = {\r\n    fontStyle: 'normal',\r\n    fontWeight: 'normal',\r\n    fillColor: '#000000'\r\n  };\r\n  var convertImgDataToPng = function convertImgDataToPngClosure() {\r\n    var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\r\n    var CHUNK_WRAPPER_SIZE = 12;\r\n    var crcTable = new Int32Array(256);\r\n    for (var i = 0; i < 256; i++) {\r\n      var c = i;\r\n      for (var h = 0; h < 8; h++) {\r\n        if (c & 1) {\r\n          c = 0xedB88320 ^ c >> 1 & 0x7fffffff;\r\n        } else {\r\n          c = c >> 1 & 0x7fffffff;\r\n        }\r\n      }\r\n      crcTable[i] = c;\r\n    }\r\n    function crc32(data, start, end) {\r\n      var crc = -1;\r\n      for (var i = start; i < end; i++) {\r\n        var a = (crc ^ data[i]) & 0xff;\r\n        var b = crcTable[a];\r\n        crc = crc >>> 8 ^ b;\r\n      }\r\n      return crc ^ -1;\r\n    }\r\n    function writePngChunk(type, body, data, offset) {\r\n      var p = offset;\r\n      var len = body.length;\r\n      data[p] = len >> 24 & 0xff;\r\n      data[p + 1] = len >> 16 & 0xff;\r\n      data[p + 2] = len >> 8 & 0xff;\r\n      data[p + 3] = len & 0xff;\r\n      p += 4;\r\n      data[p] = type.charCodeAt(0) & 0xff;\r\n      data[p + 1] = type.charCodeAt(1) & 0xff;\r\n      data[p + 2] = type.charCodeAt(2) & 0xff;\r\n      data[p + 3] = type.charCodeAt(3) & 0xff;\r\n      p += 4;\r\n      data.set(body, p);\r\n      p += body.length;\r\n      var crc = crc32(data, offset + 4, p);\r\n      data[p] = crc >> 24 & 0xff;\r\n      data[p + 1] = crc >> 16 & 0xff;\r\n      data[p + 2] = crc >> 8 & 0xff;\r\n      data[p + 3] = crc & 0xff;\r\n    }\r\n    function adler32(data, start, end) {\r\n      var a = 1;\r\n      var b = 0;\r\n      for (var i = start; i < end; ++i) {\r\n        a = (a + (data[i] & 0xff)) % 65521;\r\n        b = (b + a) % 65521;\r\n      }\r\n      return b << 16 | a;\r\n    }\r\n    function deflateSync(literals) {\r\n      if (!(0, _is_node2.default)()) {\r\n        return deflateSyncUncompressed(literals);\r\n      }\r\n      try {\r\n        var input;\r\n        if (parseInt(process.versions.node) >= 8) {\r\n          input = literals;\r\n        } else {\r\n          input = new Buffer(literals);\r\n        }\r\n        var output = require('zlib').deflateSync(input, { level: 9 });\r\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\r\n      } catch (e) {\r\n        (0, _util.warn)('Not compressing PNG because zlib.deflateSync is unavailable: ' + e);\r\n      }\r\n      return deflateSyncUncompressed(literals);\r\n    }\r\n    function deflateSyncUncompressed(literals) {\r\n      var len = literals.length;\r\n      var maxBlockLength = 0xFFFF;\r\n      var deflateBlocks = Math.ceil(len / maxBlockLength);\r\n      var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\r\n      var pi = 0;\r\n      idat[pi++] = 0x78;\r\n      idat[pi++] = 0x9c;\r\n      var pos = 0;\r\n      while (len > maxBlockLength) {\r\n        idat[pi++] = 0x00;\r\n        idat[pi++] = 0xff;\r\n        idat[pi++] = 0xff;\r\n        idat[pi++] = 0x00;\r\n        idat[pi++] = 0x00;\r\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\r\n        pi += maxBlockLength;\r\n        pos += maxBlockLength;\r\n        len -= maxBlockLength;\r\n      }\r\n      idat[pi++] = 0x01;\r\n      idat[pi++] = len & 0xff;\r\n      idat[pi++] = len >> 8 & 0xff;\r\n      idat[pi++] = ~len & 0xffff & 0xff;\r\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\r\n      idat.set(literals.subarray(pos), pi);\r\n      pi += literals.length - pos;\r\n      var adler = adler32(literals, 0, literals.length);\r\n      idat[pi++] = adler >> 24 & 0xff;\r\n      idat[pi++] = adler >> 16 & 0xff;\r\n      idat[pi++] = adler >> 8 & 0xff;\r\n      idat[pi++] = adler & 0xff;\r\n      return idat;\r\n    }\r\n    function encode(imgData, kind, forceDataSchema, isMask) {\r\n      var width = imgData.width;\r\n      var height = imgData.height;\r\n      var bitDepth, colorType, lineSize;\r\n      var bytes = imgData.data;\r\n      switch (kind) {\r\n        case _util.ImageKind.GRAYSCALE_1BPP:\r\n          colorType = 0;\r\n          bitDepth = 1;\r\n          lineSize = width + 7 >> 3;\r\n          break;\r\n        case _util.ImageKind.RGB_24BPP:\r\n          colorType = 2;\r\n          bitDepth = 8;\r\n          lineSize = width * 3;\r\n          break;\r\n        case _util.ImageKind.RGBA_32BPP:\r\n          colorType = 6;\r\n          bitDepth = 8;\r\n          lineSize = width * 4;\r\n          break;\r\n        default:\r\n          throw new Error('invalid format');\r\n      }\r\n      var literals = new Uint8Array((1 + lineSize) * height);\r\n      var offsetLiterals = 0,\r\n          offsetBytes = 0;\r\n      var y, i;\r\n      for (y = 0; y < height; ++y) {\r\n        literals[offsetLiterals++] = 0;\r\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\r\n        offsetBytes += lineSize;\r\n        offsetLiterals += lineSize;\r\n      }\r\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\r\n        offsetLiterals = 0;\r\n        for (y = 0; y < height; y++) {\r\n          offsetLiterals++;\r\n          for (i = 0; i < lineSize; i++) {\r\n            literals[offsetLiterals++] ^= 0xFF;\r\n          }\r\n        }\r\n      }\r\n      var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\r\n      var idat = deflateSync(literals);\r\n      var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\r\n      var data = new Uint8Array(pngLength);\r\n      var offset = 0;\r\n      data.set(PNG_HEADER, offset);\r\n      offset += PNG_HEADER.length;\r\n      writePngChunk('IHDR', ihdr, data, offset);\r\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\r\n      writePngChunk('IDATA', idat, data, offset);\r\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\r\n      writePngChunk('IEND', new Uint8Array(0), data, offset);\r\n      return (0, _util.createObjectURL)(data, 'image/png', forceDataSchema);\r\n    }\r\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\r\n      var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\r\n      return encode(imgData, kind, forceDataSchema, isMask);\r\n    };\r\n  }();\r\n  var SVGExtraState = function SVGExtraStateClosure() {\r\n    function SVGExtraState() {\r\n      this.fontSizeScale = 1;\r\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\r\n      this.fontSize = 0;\r\n      this.textMatrix = _util.IDENTITY_MATRIX;\r\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\r\n      this.leading = 0;\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.lineX = 0;\r\n      this.lineY = 0;\r\n      this.charSpacing = 0;\r\n      this.wordSpacing = 0;\r\n      this.textHScale = 1;\r\n      this.textRise = 0;\r\n      this.fillColor = SVG_DEFAULTS.fillColor;\r\n      this.strokeColor = '#000000';\r\n      this.fillAlpha = 1;\r\n      this.strokeAlpha = 1;\r\n      this.lineWidth = 1;\r\n      this.lineJoin = '';\r\n      this.lineCap = '';\r\n      this.miterLimit = 0;\r\n      this.dashArray = [];\r\n      this.dashPhase = 0;\r\n      this.dependencies = [];\r\n      this.activeClipUrl = null;\r\n      this.clipGroup = null;\r\n      this.maskId = '';\r\n    }\r\n    SVGExtraState.prototype = {\r\n      clone: function SVGExtraState_clone() {\r\n        return Object.create(this);\r\n      },\r\n      setCurrentPoint: function SVGExtraState_setCurrentPoint(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n      }\r\n    };\r\n    return SVGExtraState;\r\n  }();\r\n  exports.SVGGraphics = SVGGraphics = function SVGGraphicsClosure() {\r\n    function opListToTree(opList) {\r\n      var opTree = [];\r\n      var tmp = [];\r\n      var opListLen = opList.length;\r\n      for (var x = 0; x < opListLen; x++) {\r\n        if (opList[x].fn === 'save') {\r\n          opTree.push({\r\n            'fnId': 92,\r\n            'fn': 'group',\r\n            'items': []\r\n          });\r\n          tmp.push(opTree);\r\n          opTree = opTree[opTree.length - 1].items;\r\n          continue;\r\n        }\r\n        if (opList[x].fn === 'restore') {\r\n          opTree = tmp.pop();\r\n        } else {\r\n          opTree.push(opList[x]);\r\n        }\r\n      }\r\n      return opTree;\r\n    }\r\n    function pf(value) {\r\n      if (Number.isInteger(value)) {\r\n        return value.toString();\r\n      }\r\n      var s = value.toFixed(10);\r\n      var i = s.length - 1;\r\n      if (s[i] !== '0') {\r\n        return s;\r\n      }\r\n      do {\r\n        i--;\r\n      } while (s[i] === '0');\r\n      return s.substr(0, s[i] === '.' ? i : i + 1);\r\n    }\r\n    function pm(m) {\r\n      if (m[4] === 0 && m[5] === 0) {\r\n        if (m[1] === 0 && m[2] === 0) {\r\n          if (m[0] === 1 && m[3] === 1) {\r\n            return '';\r\n          }\r\n          return 'scale(' + pf(m[0]) + ' ' + pf(m[3]) + ')';\r\n        }\r\n        if (m[0] === m[3] && m[1] === -m[2]) {\r\n          var a = Math.acos(m[0]) * 180 / Math.PI;\r\n          return 'rotate(' + pf(a) + ')';\r\n        }\r\n      } else {\r\n        if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\r\n          return 'translate(' + pf(m[4]) + ' ' + pf(m[5]) + ')';\r\n        }\r\n      }\r\n      return 'matrix(' + pf(m[0]) + ' ' + pf(m[1]) + ' ' + pf(m[2]) + ' ' + pf(m[3]) + ' ' + pf(m[4]) + ' ' + pf(m[5]) + ')';\r\n    }\r\n    function SVGGraphics(commonObjs, objs, forceDataSchema) {\r\n      this.svgFactory = new _dom_utils.DOMSVGFactory();\r\n      this.current = new SVGExtraState();\r\n      this.transformMatrix = _util.IDENTITY_MATRIX;\r\n      this.transformStack = [];\r\n      this.extraStack = [];\r\n      this.commonObjs = commonObjs;\r\n      this.objs = objs;\r\n      this.pendingClip = null;\r\n      this.pendingEOFill = false;\r\n      this.embedFonts = false;\r\n      this.embeddedFonts = Object.create(null);\r\n      this.cssStyle = null;\r\n      this.forceDataSchema = !!forceDataSchema;\r\n    }\r\n    var XML_NS = 'http://www.w3.org/XML/1998/namespace';\r\n    var XLINK_NS = 'http://www.w3.org/1999/xlink';\r\n    var LINE_CAP_STYLES = ['butt', 'round', 'square'];\r\n    var LINE_JOIN_STYLES = ['miter', 'round', 'bevel'];\r\n    var clipCount = 0;\r\n    var maskCount = 0;\r\n    SVGGraphics.prototype = {\r\n      save: function SVGGraphics_save() {\r\n        this.transformStack.push(this.transformMatrix);\r\n        var old = this.current;\r\n        this.extraStack.push(old);\r\n        this.current = old.clone();\r\n      },\r\n      restore: function SVGGraphics_restore() {\r\n        this.transformMatrix = this.transformStack.pop();\r\n        this.current = this.extraStack.pop();\r\n        this.pendingClip = null;\r\n        this.tgrp = null;\r\n      },\r\n      group: function SVGGraphics_group(items) {\r\n        this.save();\r\n        this.executeOpTree(items);\r\n        this.restore();\r\n      },\r\n      loadDependencies: function SVGGraphics_loadDependencies(operatorList) {\r\n        var _this = this;\r\n\r\n        var fnArray = operatorList.fnArray;\r\n        var fnArrayLen = fnArray.length;\r\n        var argsArray = operatorList.argsArray;\r\n        for (var i = 0; i < fnArrayLen; i++) {\r\n          if (_util.OPS.dependency === fnArray[i]) {\r\n            var deps = argsArray[i];\r\n            for (var n = 0, nn = deps.length; n < nn; n++) {\r\n              var obj = deps[n];\r\n              var common = obj.substring(0, 2) === 'g_';\r\n              var promise;\r\n              if (common) {\r\n                promise = new Promise(function (resolve) {\r\n                  _this.commonObjs.get(obj, resolve);\r\n                });\r\n              } else {\r\n                promise = new Promise(function (resolve) {\r\n                  _this.objs.get(obj, resolve);\r\n                });\r\n              }\r\n              this.current.dependencies.push(promise);\r\n            }\r\n          }\r\n        }\r\n        return Promise.all(this.current.dependencies);\r\n      },\r\n      transform: function SVGGraphics_transform(a, b, c, d, e, f) {\r\n        var transformMatrix = [a, b, c, d, e, f];\r\n        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\r\n        this.tgrp = null;\r\n      },\r\n      getSVG: function SVGGraphics_getSVG(operatorList, viewport) {\r\n        var _this2 = this;\r\n\r\n        this.viewport = viewport;\r\n        var svgElement = this._initialize(viewport);\r\n        return this.loadDependencies(operatorList).then(function () {\r\n          _this2.transformMatrix = _util.IDENTITY_MATRIX;\r\n          var opTree = _this2.convertOpList(operatorList);\r\n          _this2.executeOpTree(opTree);\r\n          return svgElement;\r\n        });\r\n      },\r\n      convertOpList: function SVGGraphics_convertOpList(operatorList) {\r\n        var argsArray = operatorList.argsArray;\r\n        var fnArray = operatorList.fnArray;\r\n        var fnArrayLen = fnArray.length;\r\n        var REVOPS = [];\r\n        var opList = [];\r\n        for (var op in _util.OPS) {\r\n          REVOPS[_util.OPS[op]] = op;\r\n        }\r\n        for (var x = 0; x < fnArrayLen; x++) {\r\n          var fnId = fnArray[x];\r\n          opList.push({\r\n            'fnId': fnId,\r\n            'fn': REVOPS[fnId],\r\n            'args': argsArray[x]\r\n          });\r\n        }\r\n        return opListToTree(opList);\r\n      },\r\n      executeOpTree: function SVGGraphics_executeOpTree(opTree) {\r\n        var opTreeLen = opTree.length;\r\n        for (var x = 0; x < opTreeLen; x++) {\r\n          var fn = opTree[x].fn;\r\n          var fnId = opTree[x].fnId;\r\n          var args = opTree[x].args;\r\n          switch (fnId | 0) {\r\n            case _util.OPS.beginText:\r\n              this.beginText();\r\n              break;\r\n            case _util.OPS.dependency:\r\n              break;\r\n            case _util.OPS.setLeading:\r\n              this.setLeading(args);\r\n              break;\r\n            case _util.OPS.setLeadingMoveText:\r\n              this.setLeadingMoveText(args[0], args[1]);\r\n              break;\r\n            case _util.OPS.setFont:\r\n              this.setFont(args);\r\n              break;\r\n            case _util.OPS.showText:\r\n              this.showText(args[0]);\r\n              break;\r\n            case _util.OPS.showSpacedText:\r\n              this.showText(args[0]);\r\n              break;\r\n            case _util.OPS.endText:\r\n              this.endText();\r\n              break;\r\n            case _util.OPS.moveText:\r\n              this.moveText(args[0], args[1]);\r\n              break;\r\n            case _util.OPS.setCharSpacing:\r\n              this.setCharSpacing(args[0]);\r\n              break;\r\n            case _util.OPS.setWordSpacing:\r\n              this.setWordSpacing(args[0]);\r\n              break;\r\n            case _util.OPS.setHScale:\r\n              this.setHScale(args[0]);\r\n              break;\r\n            case _util.OPS.setTextMatrix:\r\n              this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n              break;\r\n            case _util.OPS.setTextRise:\r\n              this.setTextRise(args[0]);\r\n              break;\r\n            case _util.OPS.setLineWidth:\r\n              this.setLineWidth(args[0]);\r\n              break;\r\n            case _util.OPS.setLineJoin:\r\n              this.setLineJoin(args[0]);\r\n              break;\r\n            case _util.OPS.setLineCap:\r\n              this.setLineCap(args[0]);\r\n              break;\r\n            case _util.OPS.setMiterLimit:\r\n              this.setMiterLimit(args[0]);\r\n              break;\r\n            case _util.OPS.setFillRGBColor:\r\n              this.setFillRGBColor(args[0], args[1], args[2]);\r\n              break;\r\n            case _util.OPS.setStrokeRGBColor:\r\n              this.setStrokeRGBColor(args[0], args[1], args[2]);\r\n              break;\r\n            case _util.OPS.setDash:\r\n              this.setDash(args[0], args[1]);\r\n              break;\r\n            case _util.OPS.setGState:\r\n              this.setGState(args[0]);\r\n              break;\r\n            case _util.OPS.fill:\r\n              this.fill();\r\n              break;\r\n            case _util.OPS.eoFill:\r\n              this.eoFill();\r\n              break;\r\n            case _util.OPS.stroke:\r\n              this.stroke();\r\n              break;\r\n            case _util.OPS.fillStroke:\r\n              this.fillStroke();\r\n              break;\r\n            case _util.OPS.eoFillStroke:\r\n              this.eoFillStroke();\r\n              break;\r\n            case _util.OPS.clip:\r\n              this.clip('nonzero');\r\n              break;\r\n            case _util.OPS.eoClip:\r\n              this.clip('evenodd');\r\n              break;\r\n            case _util.OPS.paintSolidColorImageMask:\r\n              this.paintSolidColorImageMask();\r\n              break;\r\n            case _util.OPS.paintJpegXObject:\r\n              this.paintJpegXObject(args[0], args[1], args[2]);\r\n              break;\r\n            case _util.OPS.paintImageXObject:\r\n              this.paintImageXObject(args[0]);\r\n              break;\r\n            case _util.OPS.paintInlineImageXObject:\r\n              this.paintInlineImageXObject(args[0]);\r\n              break;\r\n            case _util.OPS.paintImageMaskXObject:\r\n              this.paintImageMaskXObject(args[0]);\r\n              break;\r\n            case _util.OPS.paintFormXObjectBegin:\r\n              this.paintFormXObjectBegin(args[0], args[1]);\r\n              break;\r\n            case _util.OPS.paintFormXObjectEnd:\r\n              this.paintFormXObjectEnd();\r\n              break;\r\n            case _util.OPS.closePath:\r\n              this.closePath();\r\n              break;\r\n            case _util.OPS.closeStroke:\r\n              this.closeStroke();\r\n              break;\r\n            case _util.OPS.closeFillStroke:\r\n              this.closeFillStroke();\r\n              break;\r\n            case _util.OPS.closeEOFillStroke:\r\n              this.closeEOFillStroke();\r\n              break;\r\n            case _util.OPS.nextLine:\r\n              this.nextLine();\r\n              break;\r\n            case _util.OPS.transform:\r\n              this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\r\n              break;\r\n            case _util.OPS.constructPath:\r\n              this.constructPath(args[0], args[1]);\r\n              break;\r\n            case _util.OPS.endPath:\r\n              this.endPath();\r\n              break;\r\n            case 92:\r\n              this.group(opTree[x].items);\r\n              break;\r\n            default:\r\n              (0, _util.warn)('Unimplemented operator ' + fn);\r\n              break;\r\n          }\r\n        }\r\n      },\r\n      setWordSpacing: function SVGGraphics_setWordSpacing(wordSpacing) {\r\n        this.current.wordSpacing = wordSpacing;\r\n      },\r\n      setCharSpacing: function SVGGraphics_setCharSpacing(charSpacing) {\r\n        this.current.charSpacing = charSpacing;\r\n      },\r\n      nextLine: function SVGGraphics_nextLine() {\r\n        this.moveText(0, this.current.leading);\r\n      },\r\n      setTextMatrix: function SVGGraphics_setTextMatrix(a, b, c, d, e, f) {\r\n        var current = this.current;\r\n        this.current.textMatrix = this.current.lineMatrix = [a, b, c, d, e, f];\r\n        this.current.x = this.current.lineX = 0;\r\n        this.current.y = this.current.lineY = 0;\r\n        current.xcoords = [];\r\n        current.tspan = this.svgFactory.createElement('svg:tspan');\r\n        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\r\n        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');\r\n        current.tspan.setAttributeNS(null, 'y', pf(-current.y));\r\n        current.txtElement = this.svgFactory.createElement('svg:text');\r\n        current.txtElement.appendChild(current.tspan);\r\n      },\r\n      beginText: function SVGGraphics_beginText() {\r\n        this.current.x = this.current.lineX = 0;\r\n        this.current.y = this.current.lineY = 0;\r\n        this.current.textMatrix = _util.IDENTITY_MATRIX;\r\n        this.current.lineMatrix = _util.IDENTITY_MATRIX;\r\n        this.current.tspan = this.svgFactory.createElement('svg:tspan');\r\n        this.current.txtElement = this.svgFactory.createElement('svg:text');\r\n        this.current.txtgrp = this.svgFactory.createElement('svg:g');\r\n        this.current.xcoords = [];\r\n      },\r\n      moveText: function SVGGraphics_moveText(x, y) {\r\n        var current = this.current;\r\n        this.current.x = this.current.lineX += x;\r\n        this.current.y = this.current.lineY += y;\r\n        current.xcoords = [];\r\n        current.tspan = this.svgFactory.createElement('svg:tspan');\r\n        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\r\n        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');\r\n        current.tspan.setAttributeNS(null, 'y', pf(-current.y));\r\n      },\r\n      showText: function SVGGraphics_showText(glyphs) {\r\n        var current = this.current;\r\n        var font = current.font;\r\n        var fontSize = current.fontSize;\r\n        if (fontSize === 0) {\r\n          return;\r\n        }\r\n        var charSpacing = current.charSpacing;\r\n        var wordSpacing = current.wordSpacing;\r\n        var fontDirection = current.fontDirection;\r\n        var textHScale = current.textHScale * fontDirection;\r\n        var glyphsLength = glyphs.length;\r\n        var vertical = font.vertical;\r\n        var widthAdvanceScale = fontSize * current.fontMatrix[0];\r\n        var x = 0,\r\n            i;\r\n        for (i = 0; i < glyphsLength; ++i) {\r\n          var glyph = glyphs[i];\r\n          if (glyph === null) {\r\n            x += fontDirection * wordSpacing;\r\n            continue;\r\n          } else if ((0, _util.isNum)(glyph)) {\r\n            x += -glyph * fontSize * 0.001;\r\n            continue;\r\n          }\r\n          var width = glyph.width;\r\n          var character = glyph.fontChar;\r\n          var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\r\n          var charWidth = width * widthAdvanceScale + spacing * fontDirection;\r\n          if (!glyph.isInFont && !font.missingFile) {\r\n            x += charWidth;\r\n            continue;\r\n          }\r\n          current.xcoords.push(current.x + x * textHScale);\r\n          current.tspan.textContent += character;\r\n          x += charWidth;\r\n        }\r\n        if (vertical) {\r\n          current.y -= x * textHScale;\r\n        } else {\r\n          current.x += x * textHScale;\r\n        }\r\n        current.tspan.setAttributeNS(null, 'x', current.xcoords.map(pf).join(' '));\r\n        current.tspan.setAttributeNS(null, 'y', pf(-current.y));\r\n        current.tspan.setAttributeNS(null, 'font-family', current.fontFamily);\r\n        current.tspan.setAttributeNS(null, 'font-size', pf(current.fontSize) + 'px');\r\n        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\r\n          current.tspan.setAttributeNS(null, 'font-style', current.fontStyle);\r\n        }\r\n        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\r\n          current.tspan.setAttributeNS(null, 'font-weight', current.fontWeight);\r\n        }\r\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\r\n          current.tspan.setAttributeNS(null, 'fill', current.fillColor);\r\n        }\r\n        var textMatrix = current.textMatrix;\r\n        if (current.textRise !== 0) {\r\n          textMatrix = textMatrix.slice();\r\n          textMatrix[5] += current.textRise;\r\n        }\r\n        current.txtElement.setAttributeNS(null, 'transform', pm(textMatrix) + ' scale(1, -1)');\r\n        current.txtElement.setAttributeNS(XML_NS, 'xml:space', 'preserve');\r\n        current.txtElement.appendChild(current.tspan);\r\n        current.txtgrp.appendChild(current.txtElement);\r\n        this._ensureTransformGroup().appendChild(current.txtElement);\r\n      },\r\n      setLeadingMoveText: function SVGGraphics_setLeadingMoveText(x, y) {\r\n        this.setLeading(-y);\r\n        this.moveText(x, y);\r\n      },\r\n      addFontStyle: function SVGGraphics_addFontStyle(fontObj) {\r\n        if (!this.cssStyle) {\r\n          this.cssStyle = this.svgFactory.createElement('svg:style');\r\n          this.cssStyle.setAttributeNS(null, 'type', 'text/css');\r\n          this.defs.appendChild(this.cssStyle);\r\n        }\r\n        var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\r\n        this.cssStyle.textContent += '@font-face { font-family: \"' + fontObj.loadedName + '\";' + ' src: url(' + url + '); }\\n';\r\n      },\r\n      setFont: function SVGGraphics_setFont(details) {\r\n        var current = this.current;\r\n        var fontObj = this.commonObjs.get(details[0]);\r\n        var size = details[1];\r\n        this.current.font = fontObj;\r\n        if (this.embedFonts && fontObj.data && !this.embeddedFonts[fontObj.loadedName]) {\r\n          this.addFontStyle(fontObj);\r\n          this.embeddedFonts[fontObj.loadedName] = fontObj;\r\n        }\r\n        current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;\r\n        var bold = fontObj.black ? fontObj.bold ? 'bolder' : 'bold' : fontObj.bold ? 'bold' : 'normal';\r\n        var italic = fontObj.italic ? 'italic' : 'normal';\r\n        if (size < 0) {\r\n          size = -size;\r\n          current.fontDirection = -1;\r\n        } else {\r\n          current.fontDirection = 1;\r\n        }\r\n        current.fontSize = size;\r\n        current.fontFamily = fontObj.loadedName;\r\n        current.fontWeight = bold;\r\n        current.fontStyle = italic;\r\n        current.tspan = this.svgFactory.createElement('svg:tspan');\r\n        current.tspan.setAttributeNS(null, 'y', pf(-current.y));\r\n        current.xcoords = [];\r\n      },\r\n      endText: function SVGGraphics_endText() {},\r\n      setLineWidth: function SVGGraphics_setLineWidth(width) {\r\n        this.current.lineWidth = width;\r\n      },\r\n      setLineCap: function SVGGraphics_setLineCap(style) {\r\n        this.current.lineCap = LINE_CAP_STYLES[style];\r\n      },\r\n      setLineJoin: function SVGGraphics_setLineJoin(style) {\r\n        this.current.lineJoin = LINE_JOIN_STYLES[style];\r\n      },\r\n      setMiterLimit: function SVGGraphics_setMiterLimit(limit) {\r\n        this.current.miterLimit = limit;\r\n      },\r\n      setStrokeAlpha: function SVGGraphics_setStrokeAlpha(strokeAlpha) {\r\n        this.current.strokeAlpha = strokeAlpha;\r\n      },\r\n      setStrokeRGBColor: function SVGGraphics_setStrokeRGBColor(r, g, b) {\r\n        var color = _util.Util.makeCssRgb(r, g, b);\r\n        this.current.strokeColor = color;\r\n      },\r\n      setFillAlpha: function SVGGraphics_setFillAlpha(fillAlpha) {\r\n        this.current.fillAlpha = fillAlpha;\r\n      },\r\n      setFillRGBColor: function SVGGraphics_setFillRGBColor(r, g, b) {\r\n        var color = _util.Util.makeCssRgb(r, g, b);\r\n        this.current.fillColor = color;\r\n        this.current.tspan = this.svgFactory.createElement('svg:tspan');\r\n        this.current.xcoords = [];\r\n      },\r\n      setDash: function SVGGraphics_setDash(dashArray, dashPhase) {\r\n        this.current.dashArray = dashArray;\r\n        this.current.dashPhase = dashPhase;\r\n      },\r\n      constructPath: function SVGGraphics_constructPath(ops, args) {\r\n        var current = this.current;\r\n        var x = current.x,\r\n            y = current.y;\r\n        current.path = this.svgFactory.createElement('svg:path');\r\n        var d = [];\r\n        var opLength = ops.length;\r\n        for (var i = 0, j = 0; i < opLength; i++) {\r\n          switch (ops[i] | 0) {\r\n            case _util.OPS.rectangle:\r\n              x = args[j++];\r\n              y = args[j++];\r\n              var width = args[j++];\r\n              var height = args[j++];\r\n              var xw = x + width;\r\n              var yh = y + height;\r\n              d.push('M', pf(x), pf(y), 'L', pf(xw), pf(y), 'L', pf(xw), pf(yh), 'L', pf(x), pf(yh), 'Z');\r\n              break;\r\n            case _util.OPS.moveTo:\r\n              x = args[j++];\r\n              y = args[j++];\r\n              d.push('M', pf(x), pf(y));\r\n              break;\r\n            case _util.OPS.lineTo:\r\n              x = args[j++];\r\n              y = args[j++];\r\n              d.push('L', pf(x), pf(y));\r\n              break;\r\n            case _util.OPS.curveTo:\r\n              x = args[j + 4];\r\n              y = args[j + 5];\r\n              d.push('C', pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\r\n              j += 6;\r\n              break;\r\n            case _util.OPS.curveTo2:\r\n              x = args[j + 2];\r\n              y = args[j + 3];\r\n              d.push('C', pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\r\n              j += 4;\r\n              break;\r\n            case _util.OPS.curveTo3:\r\n              x = args[j + 2];\r\n              y = args[j + 3];\r\n              d.push('C', pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\r\n              j += 4;\r\n              break;\r\n            case _util.OPS.closePath:\r\n              d.push('Z');\r\n              break;\r\n          }\r\n        }\r\n        current.path.setAttributeNS(null, 'd', d.join(' '));\r\n        current.path.setAttributeNS(null, 'fill', 'none');\r\n        this._ensureTransformGroup().appendChild(current.path);\r\n        current.element = current.path;\r\n        current.setCurrentPoint(x, y);\r\n      },\r\n      endPath: function SVGGraphics_endPath() {\r\n        if (!this.pendingClip) {\r\n          return;\r\n        }\r\n        var current = this.current;\r\n        var clipId = 'clippath' + clipCount;\r\n        clipCount++;\r\n        var clipPath = this.svgFactory.createElement('svg:clipPath');\r\n        clipPath.setAttributeNS(null, 'id', clipId);\r\n        clipPath.setAttributeNS(null, 'transform', pm(this.transformMatrix));\r\n        var clipElement = current.element.cloneNode();\r\n        if (this.pendingClip === 'evenodd') {\r\n          clipElement.setAttributeNS(null, 'clip-rule', 'evenodd');\r\n        } else {\r\n          clipElement.setAttributeNS(null, 'clip-rule', 'nonzero');\r\n        }\r\n        this.pendingClip = null;\r\n        clipPath.appendChild(clipElement);\r\n        this.defs.appendChild(clipPath);\r\n        if (current.activeClipUrl) {\r\n          current.clipGroup = null;\r\n          this.extraStack.forEach(function (prev) {\r\n            prev.clipGroup = null;\r\n          });\r\n        }\r\n        current.activeClipUrl = 'url(#' + clipId + ')';\r\n        this.tgrp = null;\r\n      },\r\n      clip: function SVGGraphics_clip(type) {\r\n        this.pendingClip = type;\r\n      },\r\n      closePath: function SVGGraphics_closePath() {\r\n        var current = this.current;\r\n        if (current.path) {\r\n          var d = current.path.getAttributeNS(null, 'd');\r\n          d += 'Z';\r\n          current.path.setAttributeNS(null, 'd', d);\r\n        }\r\n      },\r\n      setLeading: function SVGGraphics_setLeading(leading) {\r\n        this.current.leading = -leading;\r\n      },\r\n      setTextRise: function SVGGraphics_setTextRise(textRise) {\r\n        this.current.textRise = textRise;\r\n      },\r\n      setHScale: function SVGGraphics_setHScale(scale) {\r\n        this.current.textHScale = scale / 100;\r\n      },\r\n      setGState: function SVGGraphics_setGState(states) {\r\n        for (var i = 0, ii = states.length; i < ii; i++) {\r\n          var state = states[i];\r\n          var key = state[0];\r\n          var value = state[1];\r\n          switch (key) {\r\n            case 'LW':\r\n              this.setLineWidth(value);\r\n              break;\r\n            case 'LC':\r\n              this.setLineCap(value);\r\n              break;\r\n            case 'LJ':\r\n              this.setLineJoin(value);\r\n              break;\r\n            case 'ML':\r\n              this.setMiterLimit(value);\r\n              break;\r\n            case 'D':\r\n              this.setDash(value[0], value[1]);\r\n              break;\r\n            case 'Font':\r\n              this.setFont(value);\r\n              break;\r\n            case 'CA':\r\n              this.setStrokeAlpha(value);\r\n              break;\r\n            case 'ca':\r\n              this.setFillAlpha(value);\r\n              break;\r\n            default:\r\n              (0, _util.warn)('Unimplemented graphic state ' + key);\r\n              break;\r\n          }\r\n        }\r\n      },\r\n      fill: function SVGGraphics_fill() {\r\n        var current = this.current;\r\n        if (current.element) {\r\n          current.element.setAttributeNS(null, 'fill', current.fillColor);\r\n          current.element.setAttributeNS(null, 'fill-opacity', current.fillAlpha);\r\n        }\r\n      },\r\n      stroke: function SVGGraphics_stroke() {\r\n        var current = this.current;\r\n        if (current.element) {\r\n          current.element.setAttributeNS(null, 'stroke', current.strokeColor);\r\n          current.element.setAttributeNS(null, 'stroke-opacity', current.strokeAlpha);\r\n          current.element.setAttributeNS(null, 'stroke-miterlimit', pf(current.miterLimit));\r\n          current.element.setAttributeNS(null, 'stroke-linecap', current.lineCap);\r\n          current.element.setAttributeNS(null, 'stroke-linejoin', current.lineJoin);\r\n          current.element.setAttributeNS(null, 'stroke-width', pf(current.lineWidth) + 'px');\r\n          current.element.setAttributeNS(null, 'stroke-dasharray', current.dashArray.map(pf).join(' '));\r\n          current.element.setAttributeNS(null, 'stroke-dashoffset', pf(current.dashPhase) + 'px');\r\n          current.element.setAttributeNS(null, 'fill', 'none');\r\n        }\r\n      },\r\n      eoFill: function SVGGraphics_eoFill() {\r\n        if (this.current.element) {\r\n          this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');\r\n        }\r\n        this.fill();\r\n      },\r\n      fillStroke: function SVGGraphics_fillStroke() {\r\n        this.stroke();\r\n        this.fill();\r\n      },\r\n      eoFillStroke: function SVGGraphics_eoFillStroke() {\r\n        if (this.current.element) {\r\n          this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd');\r\n        }\r\n        this.fillStroke();\r\n      },\r\n      closeStroke: function SVGGraphics_closeStroke() {\r\n        this.closePath();\r\n        this.stroke();\r\n      },\r\n      closeFillStroke: function SVGGraphics_closeFillStroke() {\r\n        this.closePath();\r\n        this.fillStroke();\r\n      },\r\n      closeEOFillStroke: function closeEOFillStroke() {\r\n        this.closePath();\r\n        this.eoFillStroke();\r\n      },\r\n\r\n      paintSolidColorImageMask: function SVGGraphics_paintSolidColorImageMask() {\r\n        var current = this.current;\r\n        var rect = this.svgFactory.createElement('svg:rect');\r\n        rect.setAttributeNS(null, 'x', '0');\r\n        rect.setAttributeNS(null, 'y', '0');\r\n        rect.setAttributeNS(null, 'width', '1px');\r\n        rect.setAttributeNS(null, 'height', '1px');\r\n        rect.setAttributeNS(null, 'fill', current.fillColor);\r\n        this._ensureTransformGroup().appendChild(rect);\r\n      },\r\n      paintJpegXObject: function SVGGraphics_paintJpegXObject(objId, w, h) {\r\n        var imgObj = this.objs.get(objId);\r\n        var imgEl = this.svgFactory.createElement('svg:image');\r\n        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgObj.src);\r\n        imgEl.setAttributeNS(null, 'width', pf(w));\r\n        imgEl.setAttributeNS(null, 'height', pf(h));\r\n        imgEl.setAttributeNS(null, 'x', '0');\r\n        imgEl.setAttributeNS(null, 'y', pf(-h));\r\n        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / w) + ' ' + pf(-1 / h) + ')');\r\n        this._ensureTransformGroup().appendChild(imgEl);\r\n      },\r\n      paintImageXObject: function SVGGraphics_paintImageXObject(objId) {\r\n        var imgData = this.objs.get(objId);\r\n        if (!imgData) {\r\n          (0, _util.warn)('Dependent image isn\\'t ready yet');\r\n          return;\r\n        }\r\n        this.paintInlineImageXObject(imgData);\r\n      },\r\n      paintInlineImageXObject: function SVGGraphics_paintInlineImageXObject(imgData, mask) {\r\n        var width = imgData.width;\r\n        var height = imgData.height;\r\n        var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\r\n        var cliprect = this.svgFactory.createElement('svg:rect');\r\n        cliprect.setAttributeNS(null, 'x', '0');\r\n        cliprect.setAttributeNS(null, 'y', '0');\r\n        cliprect.setAttributeNS(null, 'width', pf(width));\r\n        cliprect.setAttributeNS(null, 'height', pf(height));\r\n        this.current.element = cliprect;\r\n        this.clip('nonzero');\r\n        var imgEl = this.svgFactory.createElement('svg:image');\r\n        imgEl.setAttributeNS(XLINK_NS, 'xlink:href', imgSrc);\r\n        imgEl.setAttributeNS(null, 'x', '0');\r\n        imgEl.setAttributeNS(null, 'y', pf(-height));\r\n        imgEl.setAttributeNS(null, 'width', pf(width) + 'px');\r\n        imgEl.setAttributeNS(null, 'height', pf(height) + 'px');\r\n        imgEl.setAttributeNS(null, 'transform', 'scale(' + pf(1 / width) + ' ' + pf(-1 / height) + ')');\r\n        if (mask) {\r\n          mask.appendChild(imgEl);\r\n        } else {\r\n          this._ensureTransformGroup().appendChild(imgEl);\r\n        }\r\n      },\r\n      paintImageMaskXObject: function SVGGraphics_paintImageMaskXObject(imgData) {\r\n        var current = this.current;\r\n        var width = imgData.width;\r\n        var height = imgData.height;\r\n        var fillColor = current.fillColor;\r\n        current.maskId = 'mask' + maskCount++;\r\n        var mask = this.svgFactory.createElement('svg:mask');\r\n        mask.setAttributeNS(null, 'id', current.maskId);\r\n        var rect = this.svgFactory.createElement('svg:rect');\r\n        rect.setAttributeNS(null, 'x', '0');\r\n        rect.setAttributeNS(null, 'y', '0');\r\n        rect.setAttributeNS(null, 'width', pf(width));\r\n        rect.setAttributeNS(null, 'height', pf(height));\r\n        rect.setAttributeNS(null, 'fill', fillColor);\r\n        rect.setAttributeNS(null, 'mask', 'url(#' + current.maskId + ')');\r\n        this.defs.appendChild(mask);\r\n        this._ensureTransformGroup().appendChild(rect);\r\n        this.paintInlineImageXObject(imgData, mask);\r\n      },\r\n      paintFormXObjectBegin: function SVGGraphics_paintFormXObjectBegin(matrix, bbox) {\r\n        if (Array.isArray(matrix) && matrix.length === 6) {\r\n          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n        }\r\n        if (Array.isArray(bbox) && bbox.length === 4) {\r\n          var width = bbox[2] - bbox[0];\r\n          var height = bbox[3] - bbox[1];\r\n          var cliprect = this.svgFactory.createElement('svg:rect');\r\n          cliprect.setAttributeNS(null, 'x', bbox[0]);\r\n          cliprect.setAttributeNS(null, 'y', bbox[1]);\r\n          cliprect.setAttributeNS(null, 'width', pf(width));\r\n          cliprect.setAttributeNS(null, 'height', pf(height));\r\n          this.current.element = cliprect;\r\n          this.clip('nonzero');\r\n          this.endPath();\r\n        }\r\n      },\r\n      paintFormXObjectEnd: function SVGGraphics_paintFormXObjectEnd() {},\r\n      _initialize: function _initialize(viewport) {\r\n        var svg = this.svgFactory.create(viewport.width, viewport.height);\r\n        var definitions = this.svgFactory.createElement('svg:defs');\r\n        svg.appendChild(definitions);\r\n        this.defs = definitions;\r\n        var rootGroup = this.svgFactory.createElement('svg:g');\r\n        rootGroup.setAttributeNS(null, 'transform', pm(viewport.transform));\r\n        svg.appendChild(rootGroup);\r\n        this.svg = rootGroup;\r\n        return svg;\r\n      },\r\n\r\n      _ensureClipGroup: function SVGGraphics_ensureClipGroup() {\r\n        if (!this.current.clipGroup) {\r\n          var clipGroup = this.svgFactory.createElement('svg:g');\r\n          clipGroup.setAttributeNS(null, 'clip-path', this.current.activeClipUrl);\r\n          this.svg.appendChild(clipGroup);\r\n          this.current.clipGroup = clipGroup;\r\n        }\r\n        return this.current.clipGroup;\r\n      },\r\n      _ensureTransformGroup: function SVGGraphics_ensureTransformGroup() {\r\n        if (!this.tgrp) {\r\n          this.tgrp = this.svgFactory.createElement('svg:g');\r\n          this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix));\r\n          if (this.current.activeClipUrl) {\r\n            this._ensureClipGroup().appendChild(this.tgrp);\r\n          } else {\r\n            this.svg.appendChild(this.tgrp);\r\n          }\r\n        }\r\n        return this.tgrp;\r\n      }\r\n    };\r\n    return SVGGraphics;\r\n  }();\r\n}\r\nexports.SVGGraphics = SVGGraphics;\r\n\r\n/***/ }),\r\n/* 128 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.PDFNodeStream = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _network_utils = __w_pdfjs_require__(39);\r\n\r\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\r\n\r\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar fs = require('fs');\r\nvar http = require('http');\r\nvar https = require('https');\r\nvar url = require('url');\r\n\r\nvar fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\r\nfunction parseUrl(sourceUrl) {\r\n  var parsedUrl = url.parse(sourceUrl);\r\n  if (parsedUrl.protocol === 'file:' || parsedUrl.host) {\r\n    return parsedUrl;\r\n  }\r\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\r\n    return url.parse('file:///' + sourceUrl);\r\n  }\r\n  if (!parsedUrl.host) {\r\n    parsedUrl.protocol = 'file:';\r\n  }\r\n  return parsedUrl;\r\n}\r\n\r\nvar PDFNodeStream = function () {\r\n  function PDFNodeStream(source) {\r\n    _classCallCheck(this, PDFNodeStream);\r\n\r\n    this.source = source;\r\n    this.url = parseUrl(source.url);\r\n    this.isHttp = this.url.protocol === 'http:' || this.url.protocol === 'https:';\r\n    this.isFsUrl = this.url.protocol === 'file:';\r\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\r\n    this._fullRequest = null;\r\n    this._rangeRequestReaders = [];\r\n  }\r\n\r\n  _createClass(PDFNodeStream, [{\r\n    key: 'getFullReader',\r\n    value: function getFullReader() {\r\n      (0, _util.assert)(!this._fullRequest);\r\n      this._fullRequest = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\r\n      return this._fullRequest;\r\n    }\r\n  }, {\r\n    key: 'getRangeReader',\r\n    value: function getRangeReader(start, end) {\r\n      var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\r\n      this._rangeRequestReaders.push(rangeReader);\r\n      return rangeReader;\r\n    }\r\n  }, {\r\n    key: 'cancelAllRequests',\r\n    value: function cancelAllRequests(reason) {\r\n      if (this._fullRequest) {\r\n        this._fullRequest.cancel(reason);\r\n      }\r\n      var readers = this._rangeRequestReaders.slice(0);\r\n      readers.forEach(function (reader) {\r\n        reader.cancel(reason);\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return PDFNodeStream;\r\n}();\r\n\r\nvar BaseFullReader = function () {\r\n  function BaseFullReader(stream) {\r\n    _classCallCheck(this, BaseFullReader);\r\n\r\n    this._url = stream.url;\r\n    this._done = false;\r\n    this._errored = false;\r\n    this._reason = null;\r\n    this.onProgress = null;\r\n    var source = stream.source;\r\n    this._contentLength = source.length;\r\n    this._loaded = 0;\r\n    this._filename = null;\r\n    this._disableRange = source.disableRange || false;\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n    if (!this._rangeChunkSize && !this._disableRange) {\r\n      this._disableRange = true;\r\n    }\r\n    this._isStreamingSupported = !source.disableStream;\r\n    this._isRangeSupported = !source.disableRange;\r\n    this._readableStream = null;\r\n    this._readCapability = (0, _util.createPromiseCapability)();\r\n    this._headersCapability = (0, _util.createPromiseCapability)();\r\n  }\r\n\r\n  _createClass(BaseFullReader, [{\r\n    key: 'read',\r\n    value: function read() {\r\n      var _this = this;\r\n\r\n      return this._readCapability.promise.then(function () {\r\n        if (_this._done) {\r\n          return Promise.resolve({\r\n            value: undefined,\r\n            done: true\r\n          });\r\n        }\r\n        if (_this._errored) {\r\n          return Promise.reject(_this._reason);\r\n        }\r\n        var chunk = _this._readableStream.read();\r\n        if (chunk === null) {\r\n          _this._readCapability = (0, _util.createPromiseCapability)();\r\n          return _this.read();\r\n        }\r\n        _this._loaded += chunk.length;\r\n        if (_this.onProgress) {\r\n          _this.onProgress({\r\n            loaded: _this._loaded,\r\n            total: _this._contentLength\r\n          });\r\n        }\r\n        var buffer = new Uint8Array(chunk).buffer;\r\n        return Promise.resolve({\r\n          value: buffer,\r\n          done: false\r\n        });\r\n      });\r\n    }\r\n  }, {\r\n    key: 'cancel',\r\n    value: function cancel(reason) {\r\n      if (!this._readableStream) {\r\n        this._error(reason);\r\n        return;\r\n      }\r\n      this._readableStream.destroy(reason);\r\n    }\r\n  }, {\r\n    key: '_error',\r\n    value: function _error(reason) {\r\n      this._errored = true;\r\n      this._reason = reason;\r\n      this._readCapability.resolve();\r\n    }\r\n  }, {\r\n    key: '_setReadableStream',\r\n    value: function _setReadableStream(readableStream) {\r\n      var _this2 = this;\r\n\r\n      this._readableStream = readableStream;\r\n      readableStream.on('readable', function () {\r\n        _this2._readCapability.resolve();\r\n      });\r\n      readableStream.on('end', function () {\r\n        readableStream.destroy();\r\n        _this2._done = true;\r\n        _this2._readCapability.resolve();\r\n      });\r\n      readableStream.on('error', function (reason) {\r\n        _this2._error(reason);\r\n      });\r\n      if (!this._isStreamingSupported && this._isRangeSupported) {\r\n        this._error(new _util.AbortException('streaming is disabled'));\r\n      }\r\n      if (this._errored) {\r\n        this._readableStream.destroy(this._reason);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'headersReady',\r\n    get: function get() {\r\n      return this._headersCapability.promise;\r\n    }\r\n  }, {\r\n    key: 'filename',\r\n    get: function get() {\r\n      return this._filename;\r\n    }\r\n  }, {\r\n    key: 'contentLength',\r\n    get: function get() {\r\n      return this._contentLength;\r\n    }\r\n  }, {\r\n    key: 'isRangeSupported',\r\n    get: function get() {\r\n      return this._isRangeSupported;\r\n    }\r\n  }, {\r\n    key: 'isStreamingSupported',\r\n    get: function get() {\r\n      return this._isStreamingSupported;\r\n    }\r\n  }]);\r\n\r\n  return BaseFullReader;\r\n}();\r\n\r\nvar BaseRangeReader = function () {\r\n  function BaseRangeReader(stream) {\r\n    _classCallCheck(this, BaseRangeReader);\r\n\r\n    this._url = stream.url;\r\n    this._done = false;\r\n    this._errored = false;\r\n    this._reason = null;\r\n    this.onProgress = null;\r\n    this._loaded = 0;\r\n    this._readableStream = null;\r\n    this._readCapability = (0, _util.createPromiseCapability)();\r\n    var source = stream.source;\r\n    this._isStreamingSupported = !source.disableStream;\r\n  }\r\n\r\n  _createClass(BaseRangeReader, [{\r\n    key: 'read',\r\n    value: function read() {\r\n      var _this3 = this;\r\n\r\n      return this._readCapability.promise.then(function () {\r\n        if (_this3._done) {\r\n          return Promise.resolve({\r\n            value: undefined,\r\n            done: true\r\n          });\r\n        }\r\n        if (_this3._errored) {\r\n          return Promise.reject(_this3._reason);\r\n        }\r\n        var chunk = _this3._readableStream.read();\r\n        if (chunk === null) {\r\n          _this3._readCapability = (0, _util.createPromiseCapability)();\r\n          return _this3.read();\r\n        }\r\n        _this3._loaded += chunk.length;\r\n        if (_this3.onProgress) {\r\n          _this3.onProgress({ loaded: _this3._loaded });\r\n        }\r\n        var buffer = new Uint8Array(chunk).buffer;\r\n        return Promise.resolve({\r\n          value: buffer,\r\n          done: false\r\n        });\r\n      });\r\n    }\r\n  }, {\r\n    key: 'cancel',\r\n    value: function cancel(reason) {\r\n      if (!this._readableStream) {\r\n        this._error(reason);\r\n        return;\r\n      }\r\n      this._readableStream.destroy(reason);\r\n    }\r\n  }, {\r\n    key: '_error',\r\n    value: function _error(reason) {\r\n      this._errored = true;\r\n      this._reason = reason;\r\n      this._readCapability.resolve();\r\n    }\r\n  }, {\r\n    key: '_setReadableStream',\r\n    value: function _setReadableStream(readableStream) {\r\n      var _this4 = this;\r\n\r\n      this._readableStream = readableStream;\r\n      readableStream.on('readable', function () {\r\n        _this4._readCapability.resolve();\r\n      });\r\n      readableStream.on('end', function () {\r\n        readableStream.destroy();\r\n        _this4._done = true;\r\n        _this4._readCapability.resolve();\r\n      });\r\n      readableStream.on('error', function (reason) {\r\n        _this4._error(reason);\r\n      });\r\n      if (this._errored) {\r\n        this._readableStream.destroy(this._reason);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'isStreamingSupported',\r\n    get: function get() {\r\n      return this._isStreamingSupported;\r\n    }\r\n  }]);\r\n\r\n  return BaseRangeReader;\r\n}();\r\n\r\nfunction createRequestOptions(url, headers) {\r\n  return {\r\n    protocol: url.protocol,\r\n    auth: url.auth,\r\n    host: url.hostname,\r\n    port: url.port,\r\n    path: url.path,\r\n    method: 'GET',\r\n    headers: headers\r\n  };\r\n}\r\n\r\nvar PDFNodeStreamFullReader = function (_BaseFullReader) {\r\n  _inherits(PDFNodeStreamFullReader, _BaseFullReader);\r\n\r\n  function PDFNodeStreamFullReader(stream) {\r\n    _classCallCheck(this, PDFNodeStreamFullReader);\r\n\r\n    var _this5 = _possibleConstructorReturn(this, (PDFNodeStreamFullReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamFullReader)).call(this, stream));\r\n\r\n    var handleResponse = function handleResponse(response) {\r\n      _this5._headersCapability.resolve();\r\n      _this5._setReadableStream(response);\r\n      var getResponseHeader = function getResponseHeader(name) {\r\n        return _this5._readableStream.headers[name.toLowerCase()];\r\n      };\r\n\r\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\r\n        getResponseHeader: getResponseHeader,\r\n        isHttp: stream.isHttp,\r\n        rangeChunkSize: _this5._rangeChunkSize,\r\n        disableRange: _this5._disableRange\r\n      }),\r\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\r\n          suggestedLength = _validateRangeRequest.suggestedLength;\r\n\r\n      _this5._isRangeSupported = allowRangeRequests;\r\n      _this5._contentLength = suggestedLength || _this5._contentLength;\r\n      _this5._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\r\n    };\r\n    _this5._request = null;\r\n    if (_this5._url.protocol === 'http:') {\r\n      _this5._request = http.request(createRequestOptions(_this5._url, stream.httpHeaders), handleResponse);\r\n    } else {\r\n      _this5._request = https.request(createRequestOptions(_this5._url, stream.httpHeaders), handleResponse);\r\n    }\r\n    _this5._request.on('error', function (reason) {\r\n      _this5._errored = true;\r\n      _this5._reason = reason;\r\n      _this5._headersCapability.reject(reason);\r\n    });\r\n    _this5._request.end();\r\n    return _this5;\r\n  }\r\n\r\n  return PDFNodeStreamFullReader;\r\n}(BaseFullReader);\r\n\r\nvar PDFNodeStreamRangeReader = function (_BaseRangeReader) {\r\n  _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);\r\n\r\n  function PDFNodeStreamRangeReader(stream, start, end) {\r\n    _classCallCheck(this, PDFNodeStreamRangeReader);\r\n\r\n    var _this6 = _possibleConstructorReturn(this, (PDFNodeStreamRangeReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamRangeReader)).call(this, stream));\r\n\r\n    _this6._httpHeaders = {};\r\n    for (var property in stream.httpHeaders) {\r\n      var value = stream.httpHeaders[property];\r\n      if (typeof value === 'undefined') {\r\n        continue;\r\n      }\r\n      _this6._httpHeaders[property] = value;\r\n    }\r\n    _this6._httpHeaders['Range'] = 'bytes=' + start + '-' + (end - 1);\r\n    _this6._request = null;\r\n    if (_this6._url.protocol === 'http:') {\r\n      _this6._request = http.request(createRequestOptions(_this6._url, _this6._httpHeaders), function (response) {\r\n        _this6._setReadableStream(response);\r\n      });\r\n    } else {\r\n      _this6._request = https.request(createRequestOptions(_this6._url, _this6._httpHeaders), function (response) {\r\n        _this6._setReadableStream(response);\r\n      });\r\n    }\r\n    _this6._request.on('error', function (reason) {\r\n      _this6._errored = true;\r\n      _this6._reason = reason;\r\n    });\r\n    _this6._request.end();\r\n    return _this6;\r\n  }\r\n\r\n  return PDFNodeStreamRangeReader;\r\n}(BaseRangeReader);\r\n\r\nvar PDFNodeStreamFsFullReader = function (_BaseFullReader2) {\r\n  _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);\r\n\r\n  function PDFNodeStreamFsFullReader(stream) {\r\n    _classCallCheck(this, PDFNodeStreamFsFullReader);\r\n\r\n    var _this7 = _possibleConstructorReturn(this, (PDFNodeStreamFsFullReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamFsFullReader)).call(this, stream));\r\n\r\n    var path = decodeURIComponent(_this7._url.path);\r\n    if (fileUriRegex.test(_this7._url.href)) {\r\n      path = path.replace(/^\\//, '');\r\n    }\r\n    fs.lstat(path, function (error, stat) {\r\n      if (error) {\r\n        _this7._errored = true;\r\n        _this7._reason = error;\r\n        _this7._headersCapability.reject(error);\r\n        return;\r\n      }\r\n      _this7._contentLength = stat.size;\r\n      _this7._setReadableStream(fs.createReadStream(path));\r\n      _this7._headersCapability.resolve();\r\n    });\r\n    return _this7;\r\n  }\r\n\r\n  return PDFNodeStreamFsFullReader;\r\n}(BaseFullReader);\r\n\r\nvar PDFNodeStreamFsRangeReader = function (_BaseRangeReader2) {\r\n  _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);\r\n\r\n  function PDFNodeStreamFsRangeReader(stream, start, end) {\r\n    _classCallCheck(this, PDFNodeStreamFsRangeReader);\r\n\r\n    var _this8 = _possibleConstructorReturn(this, (PDFNodeStreamFsRangeReader.__proto__ || Object.getPrototypeOf(PDFNodeStreamFsRangeReader)).call(this, stream));\r\n\r\n    var path = decodeURIComponent(_this8._url.path);\r\n    if (fileUriRegex.test(_this8._url.href)) {\r\n      path = path.replace(/^\\//, '');\r\n    }\r\n    _this8._setReadableStream(fs.createReadStream(path, {\r\n      start: start,\r\n      end: end - 1\r\n    }));\r\n    return _this8;\r\n  }\r\n\r\n  return PDFNodeStreamFsRangeReader;\r\n}(BaseRangeReader);\r\n\r\nexports.PDFNodeStream = PDFNodeStream;\r\n\r\n/***/ }),\r\n/* 129 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\r\n  var needsEncodingFixup = true;\r\n  var tmp = toParamRegExp('filename\\\\*', 'i').exec(contentDisposition);\r\n  if (tmp) {\r\n    tmp = tmp[1];\r\n    var filename = rfc2616unquote(tmp);\r\n    filename = unescape(filename);\r\n    filename = rfc5987decode(filename);\r\n    filename = rfc2047decode(filename);\r\n    return fixupEncoding(filename);\r\n  }\r\n  tmp = rfc2231getparam(contentDisposition);\r\n  if (tmp) {\r\n    var _filename = rfc2047decode(tmp);\r\n    return fixupEncoding(_filename);\r\n  }\r\n  tmp = toParamRegExp('filename', 'i').exec(contentDisposition);\r\n  if (tmp) {\r\n    tmp = tmp[1];\r\n    var _filename2 = rfc2616unquote(tmp);\r\n    _filename2 = rfc2047decode(_filename2);\r\n    return fixupEncoding(_filename2);\r\n  }\r\n  function toParamRegExp(attributePattern, flags) {\r\n    return new RegExp('(?:^|;)\\\\s*' + attributePattern + '\\\\s*=\\\\s*' + '(' + '[^\";\\\\s][^;\\\\s]*' + '|' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + ')', flags);\r\n  }\r\n  function textdecode(encoding, value) {\r\n    if (encoding) {\r\n      if (!/^[^\\x00-\\xFF]+$/.test(value)) {\r\n        return value;\r\n      }\r\n      try {\r\n        var decoder = new TextDecoder(encoding, { fatal: true });\r\n        var bytes = new Array(value.length);\r\n        for (var i = 0; i < value.length; ++i) {\r\n          bytes[i] = value.charCodeAt(0);\r\n        }\r\n        value = decoder.decode(new Uint8Array(bytes));\r\n        needsEncodingFixup = false;\r\n      } catch (e) {\r\n        if (/^utf-?8$/i.test(encoding)) {\r\n          value = decodeURIComponent(escape(value));\r\n          needsEncodingFixup = false;\r\n        }\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n  function fixupEncoding(value) {\r\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\r\n      return textdecode('utf-8', value);\r\n    }\r\n    return value;\r\n  }\r\n  function rfc2231getparam(contentDisposition) {\r\n    var matches = [],\r\n        match = void 0;\r\n    var iter = toParamRegExp('filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)', 'ig');\r\n    while ((match = iter.exec(contentDisposition)) !== null) {\r\n      var _match = match,\r\n          _match2 = _slicedToArray(_match, 4),\r\n          n = _match2[1],\r\n          quot = _match2[2],\r\n          part = _match2[3];\r\n\r\n      n = parseInt(n, 10);\r\n      if (n in matches) {\r\n        if (n === 0) {\r\n          break;\r\n        }\r\n        continue;\r\n      }\r\n      matches[n] = [quot, part];\r\n    }\r\n    var parts = [];\r\n    for (var _n = 0; _n < matches.length; ++_n) {\r\n      if (!(_n in matches)) {\r\n        break;\r\n      }\r\n\r\n      var _matches$_n = _slicedToArray(matches[_n], 2),\r\n          _quot = _matches$_n[0],\r\n          _part = _matches$_n[1];\r\n\r\n      _part = rfc2616unquote(_part);\r\n      if (_quot) {\r\n        _part = unescape(_part);\r\n        if (_n === 0) {\r\n          _part = rfc5987decode(_part);\r\n        }\r\n      }\r\n      parts.push(_part);\r\n    }\r\n    return parts.join('');\r\n  }\r\n  function rfc2616unquote(value) {\r\n    if (value.charAt(0) === '\"') {\r\n      var parts = value.slice(1).split('\\\\\"');\r\n      for (var i = 0; i < parts.length; ++i) {\r\n        var quotindex = parts[i].indexOf('\"');\r\n        if (quotindex !== -1) {\r\n          parts[i] = parts[i].slice(0, quotindex);\r\n          parts.length = i + 1;\r\n        }\r\n        parts[i] = parts[i].replace(/\\\\(.)/g, '$1');\r\n      }\r\n      value = parts.join('\"');\r\n    }\r\n    return value;\r\n  }\r\n  function rfc5987decode(extvalue) {\r\n    var encodingend = extvalue.indexOf('\\'');\r\n    if (encodingend === -1) {\r\n      return extvalue;\r\n    }\r\n    var encoding = extvalue.slice(0, encodingend);\r\n    var langvalue = extvalue.slice(encodingend + 1);\r\n    var value = langvalue.replace(/^[^']*'/, '');\r\n    return textdecode(encoding, value);\r\n  }\r\n  function rfc2047decode(value) {\r\n    if (value.slice(0, 2) !== '=?' || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\r\n      return value;\r\n    }\r\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (_, charset, encoding, text) {\r\n      if (encoding === 'q' || encoding === 'Q') {\r\n        text = text.replace(/_/g, ' ');\r\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (_, hex) {\r\n          return String.fromCharCode(parseInt(hex, 16));\r\n        });\r\n        return textdecode(charset, text);\r\n      }\r\n      try {\r\n        return atob(text);\r\n      } catch (e) {\r\n        return text;\r\n      }\r\n    });\r\n  }\r\n  return '';\r\n}\r\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\r\n\r\n/***/ }),\r\n/* 130 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.PDFFetchStream = undefined;\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _network_utils = __w_pdfjs_require__(39);\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction createFetchOptions(headers, withCredentials) {\r\n  return {\r\n    method: 'GET',\r\n    headers: headers,\r\n    mode: 'cors',\r\n    credentials: withCredentials ? 'include' : 'same-origin',\r\n    redirect: 'follow'\r\n  };\r\n}\r\n\r\nvar PDFFetchStream = function () {\r\n  function PDFFetchStream(source) {\r\n    _classCallCheck(this, PDFFetchStream);\r\n\r\n    this.source = source;\r\n    this.isHttp = /^https?:/i.test(source.url);\r\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\r\n    this._fullRequestReader = null;\r\n    this._rangeRequestReaders = [];\r\n  }\r\n\r\n  _createClass(PDFFetchStream, [{\r\n    key: 'getFullReader',\r\n    value: function getFullReader() {\r\n      (0, _util.assert)(!this._fullRequestReader);\r\n      this._fullRequestReader = new PDFFetchStreamReader(this);\r\n      return this._fullRequestReader;\r\n    }\r\n  }, {\r\n    key: 'getRangeReader',\r\n    value: function getRangeReader(begin, end) {\r\n      var reader = new PDFFetchStreamRangeReader(this, begin, end);\r\n      this._rangeRequestReaders.push(reader);\r\n      return reader;\r\n    }\r\n  }, {\r\n    key: 'cancelAllRequests',\r\n    value: function cancelAllRequests(reason) {\r\n      if (this._fullRequestReader) {\r\n        this._fullRequestReader.cancel(reason);\r\n      }\r\n      var readers = this._rangeRequestReaders.slice(0);\r\n      readers.forEach(function (reader) {\r\n        reader.cancel(reason);\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return PDFFetchStream;\r\n}();\r\n\r\nvar PDFFetchStreamReader = function () {\r\n  function PDFFetchStreamReader(stream) {\r\n    var _this = this;\r\n\r\n    _classCallCheck(this, PDFFetchStreamReader);\r\n\r\n    this._stream = stream;\r\n    this._reader = null;\r\n    this._loaded = 0;\r\n    this._filename = null;\r\n    var source = stream.source;\r\n    this._withCredentials = source.withCredentials;\r\n    this._contentLength = source.length;\r\n    this._headersCapability = (0, _util.createPromiseCapability)();\r\n    this._disableRange = source.disableRange || false;\r\n    this._rangeChunkSize = source.rangeChunkSize;\r\n    if (!this._rangeChunkSize && !this._disableRange) {\r\n      this._disableRange = true;\r\n    }\r\n    this._isStreamingSupported = !source.disableStream;\r\n    this._isRangeSupported = !source.disableRange;\r\n    this._headers = new Headers();\r\n    for (var property in this._stream.httpHeaders) {\r\n      var value = this._stream.httpHeaders[property];\r\n      if (typeof value === 'undefined') {\r\n        continue;\r\n      }\r\n      this._headers.append(property, value);\r\n    }\r\n    var url = source.url;\r\n    fetch(url, createFetchOptions(this._headers, this._withCredentials)).then(function (response) {\r\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\r\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\r\n      }\r\n      _this._reader = response.body.getReader();\r\n      _this._headersCapability.resolve();\r\n      var getResponseHeader = function getResponseHeader(name) {\r\n        return response.headers.get(name);\r\n      };\r\n\r\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\r\n        getResponseHeader: getResponseHeader,\r\n        isHttp: _this._stream.isHttp,\r\n        rangeChunkSize: _this._rangeChunkSize,\r\n        disableRange: _this._disableRange\r\n      }),\r\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\r\n          suggestedLength = _validateRangeRequest.suggestedLength;\r\n\r\n      _this._isRangeSupported = allowRangeRequests;\r\n      _this._contentLength = suggestedLength || _this._contentLength;\r\n      _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\r\n      if (!_this._isStreamingSupported && _this._isRangeSupported) {\r\n        _this.cancel(new _util.AbortException('streaming is disabled'));\r\n      }\r\n    }).catch(this._headersCapability.reject);\r\n    this.onProgress = null;\r\n  }\r\n\r\n  _createClass(PDFFetchStreamReader, [{\r\n    key: 'read',\r\n    value: function read() {\r\n      var _this2 = this;\r\n\r\n      return this._headersCapability.promise.then(function () {\r\n        return _this2._reader.read().then(function (_ref) {\r\n          var value = _ref.value,\r\n              done = _ref.done;\r\n\r\n          if (done) {\r\n            return Promise.resolve({\r\n              value: value,\r\n              done: done\r\n            });\r\n          }\r\n          _this2._loaded += value.byteLength;\r\n          if (_this2.onProgress) {\r\n            _this2.onProgress({\r\n              loaded: _this2._loaded,\r\n              total: _this2._contentLength\r\n            });\r\n          }\r\n          var buffer = new Uint8Array(value).buffer;\r\n          return Promise.resolve({\r\n            value: buffer,\r\n            done: false\r\n          });\r\n        });\r\n      });\r\n    }\r\n  }, {\r\n    key: 'cancel',\r\n    value: function cancel(reason) {\r\n      if (this._reader) {\r\n        this._reader.cancel(reason);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'headersReady',\r\n    get: function get() {\r\n      return this._headersCapability.promise;\r\n    }\r\n  }, {\r\n    key: 'filename',\r\n    get: function get() {\r\n      return this._filename;\r\n    }\r\n  }, {\r\n    key: 'contentLength',\r\n    get: function get() {\r\n      return this._contentLength;\r\n    }\r\n  }, {\r\n    key: 'isRangeSupported',\r\n    get: function get() {\r\n      return this._isRangeSupported;\r\n    }\r\n  }, {\r\n    key: 'isStreamingSupported',\r\n    get: function get() {\r\n      return this._isStreamingSupported;\r\n    }\r\n  }]);\r\n\r\n  return PDFFetchStreamReader;\r\n}();\r\n\r\nvar PDFFetchStreamRangeReader = function () {\r\n  function PDFFetchStreamRangeReader(stream, begin, end) {\r\n    var _this3 = this;\r\n\r\n    _classCallCheck(this, PDFFetchStreamRangeReader);\r\n\r\n    this._stream = stream;\r\n    this._reader = null;\r\n    this._loaded = 0;\r\n    var source = stream.source;\r\n    this._withCredentials = source.withCredentials;\r\n    this._readCapability = (0, _util.createPromiseCapability)();\r\n    this._isStreamingSupported = !source.disableStream;\r\n    this._headers = new Headers();\r\n    for (var property in this._stream.httpHeaders) {\r\n      var value = this._stream.httpHeaders[property];\r\n      if (typeof value === 'undefined') {\r\n        continue;\r\n      }\r\n      this._headers.append(property, value);\r\n    }\r\n    var rangeStr = begin + '-' + (end - 1);\r\n    this._headers.append('Range', 'bytes=' + rangeStr);\r\n    var url = source.url;\r\n    fetch(url, createFetchOptions(this._headers, this._withCredentials)).then(function (response) {\r\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\r\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\r\n      }\r\n      _this3._readCapability.resolve();\r\n      _this3._reader = response.body.getReader();\r\n    });\r\n    this.onProgress = null;\r\n  }\r\n\r\n  _createClass(PDFFetchStreamRangeReader, [{\r\n    key: 'read',\r\n    value: function read() {\r\n      var _this4 = this;\r\n\r\n      return this._readCapability.promise.then(function () {\r\n        return _this4._reader.read().then(function (_ref2) {\r\n          var value = _ref2.value,\r\n              done = _ref2.done;\r\n\r\n          if (done) {\r\n            return Promise.resolve({\r\n              value: value,\r\n              done: done\r\n            });\r\n          }\r\n          _this4._loaded += value.byteLength;\r\n          if (_this4.onProgress) {\r\n            _this4.onProgress({ loaded: _this4._loaded });\r\n          }\r\n          var buffer = new Uint8Array(value).buffer;\r\n          return Promise.resolve({\r\n            value: buffer,\r\n            done: false\r\n          });\r\n        });\r\n      });\r\n    }\r\n  }, {\r\n    key: 'cancel',\r\n    value: function cancel(reason) {\r\n      if (this._reader) {\r\n        this._reader.cancel(reason);\r\n      }\r\n    }\r\n  }, {\r\n    key: 'isStreamingSupported',\r\n    get: function get() {\r\n      return this._isStreamingSupported;\r\n    }\r\n  }]);\r\n\r\n  return PDFFetchStreamRangeReader;\r\n}();\r\n\r\nexports.PDFFetchStream = PDFFetchStream;\r\n\r\n/***/ }),\r\n/* 131 */\r\n/***/ (function(module, exports, __w_pdfjs_require__) {\r\n\r\n\"use strict\";\r\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.NetworkManager = exports.PDFNetworkStream = undefined;\r\n\r\nvar _util = __w_pdfjs_require__(0);\r\n\r\nvar _network_utils = __w_pdfjs_require__(39);\r\n\r\nvar _global_scope = __w_pdfjs_require__(18);\r\n\r\nvar _global_scope2 = _interopRequireDefault(_global_scope);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n;\r\nvar OK_RESPONSE = 200;\r\nvar PARTIAL_CONTENT_RESPONSE = 206;\r\nfunction NetworkManager(url, args) {\r\n  this.url = url;\r\n  args = args || {};\r\n  this.isHttp = /^https?:/i.test(url);\r\n  this.httpHeaders = this.isHttp && args.httpHeaders || {};\r\n  this.withCredentials = args.withCredentials || false;\r\n  this.getXhr = args.getXhr || function NetworkManager_getXhr() {\r\n    return new XMLHttpRequest();\r\n  };\r\n  this.currXhrId = 0;\r\n  this.pendingRequests = Object.create(null);\r\n  this.loadedRequests = Object.create(null);\r\n}\r\nfunction getArrayBuffer(xhr) {\r\n  var data = xhr.response;\r\n  if (typeof data !== 'string') {\r\n    return data;\r\n  }\r\n  var array = (0, _util.stringToBytes)(data);\r\n  return array.buffer;\r\n}\r\nvar supportsMozChunked = function supportsMozChunkedClosure() {\r\n  try {\r\n    var x = new XMLHttpRequest();\r\n    x.open('GET', _global_scope2.default.location.href);\r\n    x.responseType = 'moz-chunked-arraybuffer';\r\n    return x.responseType === 'moz-chunked-arraybuffer';\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}();\r\nNetworkManager.prototype = {\r\n  requestRange: function NetworkManager_requestRange(begin, end, listeners) {\r\n    var args = {\r\n      begin: begin,\r\n      end: end\r\n    };\r\n    for (var prop in listeners) {\r\n      args[prop] = listeners[prop];\r\n    }\r\n    return this.request(args);\r\n  },\r\n  requestFull: function NetworkManager_requestFull(listeners) {\r\n    return this.request(listeners);\r\n  },\r\n  request: function NetworkManager_request(args) {\r\n    var xhr = this.getXhr();\r\n    var xhrId = this.currXhrId++;\r\n    var pendingRequest = this.pendingRequests[xhrId] = { xhr: xhr };\r\n    xhr.open('GET', this.url);\r\n    xhr.withCredentials = this.withCredentials;\r\n    for (var property in this.httpHeaders) {\r\n      var value = this.httpHeaders[property];\r\n      if (typeof value === 'undefined') {\r\n        continue;\r\n      }\r\n      xhr.setRequestHeader(property, value);\r\n    }\r\n    if (this.isHttp && 'begin' in args && 'end' in args) {\r\n      var rangeStr = args.begin + '-' + (args.end - 1);\r\n      xhr.setRequestHeader('Range', 'bytes=' + rangeStr);\r\n      pendingRequest.expectedStatus = 206;\r\n    } else {\r\n      pendingRequest.expectedStatus = 200;\r\n    }\r\n    var useMozChunkedLoading = supportsMozChunked && !!args.onProgressiveData;\r\n    if (useMozChunkedLoading) {\r\n      xhr.responseType = 'moz-chunked-arraybuffer';\r\n      pendingRequest.onProgressiveData = args.onProgressiveData;\r\n      pendingRequest.mozChunked = true;\r\n    } else {\r\n      xhr.responseType = 'arraybuffer';\r\n    }\r\n    if (args.onError) {\r\n      xhr.onerror = function (evt) {\r\n        args.onError(xhr.status);\r\n      };\r\n    }\r\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\r\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\r\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\r\n    pendingRequest.onDone = args.onDone;\r\n    pendingRequest.onError = args.onError;\r\n    pendingRequest.onProgress = args.onProgress;\r\n    xhr.send(null);\r\n    return xhrId;\r\n  },\r\n  onProgress: function NetworkManager_onProgress(xhrId, evt) {\r\n    var pendingRequest = this.pendingRequests[xhrId];\r\n    if (!pendingRequest) {\r\n      return;\r\n    }\r\n    if (pendingRequest.mozChunked) {\r\n      var chunk = getArrayBuffer(pendingRequest.xhr);\r\n      pendingRequest.onProgressiveData(chunk);\r\n    }\r\n    var onProgress = pendingRequest.onProgress;\r\n    if (onProgress) {\r\n      onProgress(evt);\r\n    }\r\n  },\r\n  onStateChange: function NetworkManager_onStateChange(xhrId, evt) {\r\n    var pendingRequest = this.pendingRequests[xhrId];\r\n    if (!pendingRequest) {\r\n      return;\r\n    }\r\n    var xhr = pendingRequest.xhr;\r\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\r\n      pendingRequest.onHeadersReceived();\r\n      delete pendingRequest.onHeadersReceived;\r\n    }\r\n    if (xhr.readyState !== 4) {\r\n      return;\r\n    }\r\n    if (!(xhrId in this.pendingRequests)) {\r\n      return;\r\n    }\r\n    delete this.pendingRequests[xhrId];\r\n    if (xhr.status === 0 && this.isHttp) {\r\n      if (pendingRequest.onError) {\r\n        pendingRequest.onError(xhr.status);\r\n      }\r\n      return;\r\n    }\r\n    var xhrStatus = xhr.status || OK_RESPONSE;\r\n    var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\r\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\r\n      if (pendingRequest.onError) {\r\n        pendingRequest.onError(xhr.status);\r\n      }\r\n      return;\r\n    }\r\n    this.loadedRequests[xhrId] = true;\r\n    var chunk = getArrayBuffer(xhr);\r\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\r\n      var rangeHeader = xhr.getResponseHeader('Content-Range');\r\n      var matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\r\n      var begin = parseInt(matches[1], 10);\r\n      pendingRequest.onDone({\r\n        begin: begin,\r\n        chunk: chunk\r\n      });\r\n    } else if (pendingRequest.onProgressiveData) {\r\n      pendingRequest.onDone(null);\r\n    } else if (chunk) {\r\n      pendingRequest.onDone({\r\n        begin: 0,\r\n        chunk: chunk\r\n      });\r\n    } else if (pendingRequest.onError) {\r\n      pendingRequest.onError(xhr.status);\r\n    }\r\n  },\r\n  hasPendingRequests: function NetworkManager_hasPendingRequests() {\r\n    for (var xhrId in this.pendingRequests) {\r\n      return true;\r\n    }\r\n    return false;\r\n  },\r\n  getRequestXhr: function NetworkManager_getXhr(xhrId) {\r\n    return this.pendingRequests[xhrId].xhr;\r\n  },\r\n  isStreamingRequest: function NetworkManager_isStreamingRequest(xhrId) {\r\n    return !!this.pendingRequests[xhrId].onProgressiveData;\r\n  },\r\n  isPendingRequest: function NetworkManager_isPendingRequest(xhrId) {\r\n    return xhrId in this.pendingRequests;\r\n  },\r\n  isLoadedRequest: function NetworkManager_isLoadedRequest(xhrId) {\r\n    return xhrId in this.loadedRequests;\r\n  },\r\n  abortAllRequests: function NetworkManager_abortAllRequests() {\r\n    for (var xhrId in this.pendingRequests) {\r\n      this.abortRequest(xhrId | 0);\r\n    }\r\n  },\r\n  abortRequest: function NetworkManager_abortRequest(xhrId) {\r\n    var xhr = this.pendingRequests[xhrId].xhr;\r\n    delete this.pendingRequests[xhrId];\r\n    xhr.abort();\r\n  }\r\n};\r\nfunction PDFNetworkStream(source) {\r\n  this._source = source;\r\n  this._manager = new NetworkManager(source.url, {\r\n    httpHeaders: source.httpHeaders,\r\n    withCredentials: source.withCredentials\r\n  });\r\n  this._rangeChunkSize = source.rangeChunkSize;\r\n  this._fullRequestReader = null;\r\n  this._rangeRequestReaders = [];\r\n}\r\nPDFNetworkStream.prototype = {\r\n  _onRangeRequestReaderClosed: function PDFNetworkStream_onRangeRequestReaderClosed(reader) {\r\n    var i = this._rangeRequestReaders.indexOf(reader);\r\n    if (i >= 0) {\r\n      this._rangeRequestReaders.splice(i, 1);\r\n    }\r\n  },\r\n  getFullReader: function PDFNetworkStream_getFullReader() {\r\n    (0, _util.assert)(!this._fullRequestReader);\r\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\r\n    return this._fullRequestReader;\r\n  },\r\n  getRangeReader: function PDFNetworkStream_getRangeReader(begin, end) {\r\n    var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\r\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\r\n    this._rangeRequestReaders.push(reader);\r\n    return reader;\r\n  },\r\n  cancelAllRequests: function PDFNetworkStream_cancelAllRequests(reason) {\r\n    if (this._fullRequestReader) {\r\n      this._fullRequestReader.cancel(reason);\r\n    }\r\n    var readers = this._rangeRequestReaders.slice(0);\r\n    readers.forEach(function (reader) {\r\n      reader.cancel(reason);\r\n    });\r\n  }\r\n};\r\nfunction PDFNetworkStreamFullRequestReader(manager, source) {\r\n  this._manager = manager;\r\n  var args = {\r\n    onHeadersReceived: this._onHeadersReceived.bind(this),\r\n    onProgressiveData: source.disableStream ? null : this._onProgressiveData.bind(this),\r\n    onDone: this._onDone.bind(this),\r\n    onError: this._onError.bind(this),\r\n    onProgress: this._onProgress.bind(this)\r\n  };\r\n  this._url = source.url;\r\n  this._fullRequestId = manager.requestFull(args);\r\n  this._headersReceivedCapability = (0, _util.createPromiseCapability)();\r\n  this._disableRange = source.disableRange || false;\r\n  this._contentLength = source.length;\r\n  this._rangeChunkSize = source.rangeChunkSize;\r\n  if (!this._rangeChunkSize && !this._disableRange) {\r\n    this._disableRange = true;\r\n  }\r\n  this._isStreamingSupported = false;\r\n  this._isRangeSupported = false;\r\n  this._cachedChunks = [];\r\n  this._requests = [];\r\n  this._done = false;\r\n  this._storedError = undefined;\r\n  this._filename = null;\r\n  this.onProgress = null;\r\n}\r\nPDFNetworkStreamFullRequestReader.prototype = {\r\n  _onHeadersReceived: function PDFNetworkStreamFullRequestReader_onHeadersReceived() {\r\n    var fullRequestXhrId = this._fullRequestId;\r\n    var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\r\n    var getResponseHeader = function getResponseHeader(name) {\r\n      return fullRequestXhr.getResponseHeader(name);\r\n    };\r\n\r\n    var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\r\n      getResponseHeader: getResponseHeader,\r\n      isHttp: this._manager.isHttp,\r\n      rangeChunkSize: this._rangeChunkSize,\r\n      disableRange: this._disableRange\r\n    }),\r\n        allowRangeRequests = _validateRangeRequest.allowRangeRequests,\r\n        suggestedLength = _validateRangeRequest.suggestedLength;\r\n\r\n    if (allowRangeRequests) {\r\n      this._isRangeSupported = true;\r\n    }\r\n    this._contentLength = suggestedLength || this._contentLength;\r\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\r\n    var networkManager = this._manager;\r\n    if (networkManager.isStreamingRequest(fullRequestXhrId)) {\r\n      this._isStreamingSupported = true;\r\n    } else if (this._isRangeSupported) {\r\n      networkManager.abortRequest(fullRequestXhrId);\r\n    }\r\n    this._headersReceivedCapability.resolve();\r\n  },\r\n  _onProgressiveData: function PDFNetworkStreamFullRequestReader_onProgressiveData(chunk) {\r\n    if (this._requests.length > 0) {\r\n      var requestCapability = this._requests.shift();\r\n      requestCapability.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n    } else {\r\n      this._cachedChunks.push(chunk);\r\n    }\r\n  },\r\n  _onDone: function PDFNetworkStreamFullRequestReader_onDone(args) {\r\n    if (args) {\r\n      this._onProgressiveData(args.chunk);\r\n    }\r\n    this._done = true;\r\n    if (this._cachedChunks.length > 0) {\r\n      return;\r\n    }\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n    this._requests = [];\r\n  },\r\n  _onError: function PDFNetworkStreamFullRequestReader_onError(status) {\r\n    var url = this._url;\r\n    var exception = (0, _network_utils.createResponseStatusError)(status, url);\r\n    this._storedError = exception;\r\n    this._headersReceivedCapability.reject(exception);\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.reject(exception);\r\n    });\r\n    this._requests = [];\r\n    this._cachedChunks = [];\r\n  },\r\n  _onProgress: function PDFNetworkStreamFullRequestReader_onProgress(data) {\r\n    if (this.onProgress) {\r\n      this.onProgress({\r\n        loaded: data.loaded,\r\n        total: data.lengthComputable ? data.total : this._contentLength\r\n      });\r\n    }\r\n  },\r\n  get filename() {\r\n    return this._filename;\r\n  },\r\n  get isRangeSupported() {\r\n    return this._isRangeSupported;\r\n  },\r\n  get isStreamingSupported() {\r\n    return this._isStreamingSupported;\r\n  },\r\n  get contentLength() {\r\n    return this._contentLength;\r\n  },\r\n  get headersReady() {\r\n    return this._headersReceivedCapability.promise;\r\n  },\r\n  read: function PDFNetworkStreamFullRequestReader_read() {\r\n    if (this._storedError) {\r\n      return Promise.reject(this._storedError);\r\n    }\r\n    if (this._cachedChunks.length > 0) {\r\n      var chunk = this._cachedChunks.shift();\r\n      return Promise.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n    }\r\n    if (this._done) {\r\n      return Promise.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    }\r\n    var requestCapability = (0, _util.createPromiseCapability)();\r\n    this._requests.push(requestCapability);\r\n    return requestCapability.promise;\r\n  },\r\n  cancel: function PDFNetworkStreamFullRequestReader_cancel(reason) {\r\n    this._done = true;\r\n    this._headersReceivedCapability.reject(reason);\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n    this._requests = [];\r\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\r\n      this._manager.abortRequest(this._fullRequestId);\r\n    }\r\n    this._fullRequestReader = null;\r\n  }\r\n};\r\nfunction PDFNetworkStreamRangeRequestReader(manager, begin, end) {\r\n  this._manager = manager;\r\n  var args = {\r\n    onDone: this._onDone.bind(this),\r\n    onProgress: this._onProgress.bind(this)\r\n  };\r\n  this._requestId = manager.requestRange(begin, end, args);\r\n  this._requests = [];\r\n  this._queuedChunk = null;\r\n  this._done = false;\r\n  this.onProgress = null;\r\n  this.onClosed = null;\r\n}\r\nPDFNetworkStreamRangeRequestReader.prototype = {\r\n  _close: function PDFNetworkStreamRangeRequestReader_close() {\r\n    if (this.onClosed) {\r\n      this.onClosed(this);\r\n    }\r\n  },\r\n  _onDone: function PDFNetworkStreamRangeRequestReader_onDone(data) {\r\n    var chunk = data.chunk;\r\n    if (this._requests.length > 0) {\r\n      var requestCapability = this._requests.shift();\r\n      requestCapability.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n    } else {\r\n      this._queuedChunk = chunk;\r\n    }\r\n    this._done = true;\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n    this._requests = [];\r\n    this._close();\r\n  },\r\n  _onProgress: function PDFNetworkStreamRangeRequestReader_onProgress(evt) {\r\n    if (!this.isStreamingSupported && this.onProgress) {\r\n      this.onProgress({ loaded: evt.loaded });\r\n    }\r\n  },\r\n  get isStreamingSupported() {\r\n    return false;\r\n  },\r\n  read: function PDFNetworkStreamRangeRequestReader_read() {\r\n    if (this._queuedChunk !== null) {\r\n      var chunk = this._queuedChunk;\r\n      this._queuedChunk = null;\r\n      return Promise.resolve({\r\n        value: chunk,\r\n        done: false\r\n      });\r\n    }\r\n    if (this._done) {\r\n      return Promise.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    }\r\n    var requestCapability = (0, _util.createPromiseCapability)();\r\n    this._requests.push(requestCapability);\r\n    return requestCapability.promise;\r\n  },\r\n  cancel: function PDFNetworkStreamRangeRequestReader_cancel(reason) {\r\n    this._done = true;\r\n    this._requests.forEach(function (requestCapability) {\r\n      requestCapability.resolve({\r\n        value: undefined,\r\n        done: true\r\n      });\r\n    });\r\n    this._requests = [];\r\n    if (this._manager.isPendingRequest(this._requestId)) {\r\n      this._manager.abortRequest(this._requestId);\r\n    }\r\n    this._close();\r\n  }\r\n};\r\nexports.PDFNetworkStream = PDFNetworkStream;\r\nexports.NetworkManager = NetworkManager;\r\n\r\n/***/ })\r\n/******/ ]);\r\n});\r\n//# sourceMappingURL=pdf.js.map",null]}